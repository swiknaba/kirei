# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rom-changeset` gem.
# Please instead update this file by running `bin/tapioca gem rom-changeset`.

# source://rom-changeset//lib/rom/changeset.rb#7
module ROM
  class << self
    # source://rom-core/5.3.0/lib/rom/create_container.rb#66
    def container(*args, &block); end
  end
end

# Abstract Changeset class
#
# If you inherit from this class you need to configure additional settings
#
# @abstract
# @example define a custom changeset using :upsert command
#   class NewTag < ROM::Changeset[:tags]
#   command_type :upsert
#   end
#
# source://rom-changeset//lib/rom/changeset.rb#18
class ROM::Changeset
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Cache::Methods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::Dry::Core::Cache
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # Return a command for this changeset
  #
  # @api private
  # @return [ROM::Command]
  #
  # source://rom-changeset//lib/rom/changeset.rb#161
  def command; end

  # Return configured command compiler options
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-changeset//lib/rom/changeset.rb#170
  def command_compiler_options; end

  # Persist changeset
  #
  # @api public
  # @example
  #   changeset = users.changeset(name: 'Jane')
  #   changeset.commit
  #   # => { id: 1, name: 'Jane' }
  # @return [Hash, Array]
  #
  # source://rom-changeset//lib/rom/changeset.rb#143
  def commit; end

  # Return string representation of the changeset
  #
  # @api public
  # @return [String]
  #
  # source://rom-changeset//lib/rom/changeset.rb#152
  def inspect; end

  # Return a new changeset with provided relation
  #
  # New options can be provided too
  #
  # @api public
  # @param relation [Relation]
  # @param new_options [Hash]
  # @return [Changeset]
  #
  # source://rom-changeset//lib/rom/changeset.rb#129
  def new(relation, **new_options); end

  # source://rom-core/5.3.0/lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # Create a changeset class preconfigured for a specific relation
    #
    # @api public
    # @example
    #   class NewUserChangeset < ROM::Changeset::Create[:users]
    #   end
    #
    #   users.changeset(NewUserChangeset).data(name: 'Jane')
    #
    # source://rom-changeset//lib/rom/changeset.rb#106
    def [](relation_name); end

    # Enable a plugin for the changeset
    #
    # @api public
    #
    # source://rom-changeset//lib/rom/changeset.rb#115
    def use(plugin, **options); end
  end
end

# Associated changesets automatically set up FKs
#
# @api public
#
# source://rom-changeset//lib/rom/changeset/associated.rb#10
class ROM::Changeset::Associated
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # Associate with other changesets
  #
  # @api public
  # @return [Associated]
  # @see Changeset#associate
  #
  # source://rom-changeset//lib/rom/changeset/associated.rb#65
  def associate(other, name = T.unsafe(nil)); end

  # Create a composed command
  #
  # This works *only* with parent => child(ren) changeset hierarchy
  #
  # @api public
  # @example using existing parent data
  #   user_changeset = users.changeset(name: 'Jane')
  #   task_changeset = tasks.changeset(title: 'Task One')
  #
  #   user = users.create(user_changeset)
  #   task = tasks.create(task_changeset.associate(user, :user))
  # @example saving both parent and child in one go
  #   user_changeset = users.changeset(name: 'Jane')
  #   task_changeset = tasks.changeset(title: 'Task One')
  #
  #   task = tasks.create(task_changeset.associate(user, :user))
  # @return [ROM::Command::Composite]
  #
  # source://rom-changeset//lib/rom/changeset/associated.rb#89
  def command; end

  # Commit changeset's composite command
  #
  # @api public
  # @example
  #   task_changeset = tasks.
  #   changeset(title: 'Task One').
  #   associate(user, :user).
  #   commit
  #   # {:id => 1, :user_id => 1, title: 'Task One'}
  # @return [Array<Hash>, Hash]
  #
  # source://rom-changeset//lib/rom/changeset/associated.rb#54
  def commit; end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/associated.rb#105
  def relation; end

  # source://rom-core/5.3.0/lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # Infer association name from an object with a schema
    #
    # This expects other to be an object with a schema that includes a primary key
    # attribute with :source meta information. This makes it work with both structs
    # and relations
    #
    # @api private
    # @see Stateful#associate
    #
    # source://rom-changeset//lib/rom/changeset/associated.rb#30
    def infer_assoc_name(other); end
  end
end

# Changeset specialization for create commands
#
# @api public
# @see Changeset::Stateful
#
# source://rom-changeset//lib/rom/changeset/create.rb#10
class ROM::Changeset::Create < ::ROM::Changeset::Stateful
  # @api public
  #
  # source://rom-changeset//lib/rom/changeset/create.rb#13
  def command; end
end

# Changeset specialization for delete commands
#
# Delete changesets will execute delete command for its relation, which
# means proper restricted relations should be used with this changeset.
#
# @api public
#
# source://rom-changeset//lib/rom/changeset/delete.rb#11
class ROM::Changeset::Delete < ::ROM::Changeset; end

# Namespace for changeset extensions
#
# @api public
#
# source://rom-changeset//lib/rom/changeset/extensions/relation.rb#10
module ROM::Changeset::Extensions; end

# Composable data transformation pipe used by default in changesets
#
# @api private
#
# source://rom-changeset//lib/rom/changeset/pipe.rb#12
class ROM::Changeset::Pipe < ::Transproc::Transformer
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#55
  def >>(other, for_diff: T.unsafe(nil)); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#40
  def [](*args); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#44
  def bind(context); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#70
  def call(data); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#55
  def compose(other, for_diff: T.unsafe(nil)); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#74
  def for_diff(data); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/pipe.rb#78
  def new(processor, **opts); end

  # source://rom-core/5.3.0/lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # @api private
    #
    # source://rom-changeset//lib/rom/changeset/pipe.rb#36
    def [](name_or_proc); end

    # @api private
    #
    # source://rom-changeset//lib/rom/changeset/pipe.rb#22
    def new(*args, **opts); end
  end
end

# Transproc Registry useful for pipe
#
# @api private
#
# source://rom-changeset//lib/rom/changeset/pipe_registry.rb#11
module ROM::Changeset::PipeRegistry
  extend ::Transproc::Registry

  class << self
    # @api private
    #
    # source://rom-changeset//lib/rom/changeset/pipe_registry.rb#17
    def add_timestamps(data); end

    # @api private
    #
    # source://rom-changeset//lib/rom/changeset/pipe_registry.rb#22
    def touch(data); end
  end
end

# Stateful changesets carry data and can transform it into
# a different structure compatible with a persistence backend
#
# @abstract
#
# source://rom-changeset//lib/rom/changeset/stateful.rb#11
class ROM::Changeset::Stateful < ::ROM::Changeset
  # Associate a changeset with another changeset or hash-like object
  #
  # @api public
  # @example with another changeset
  #   new_user = users.changeset(name: 'Jane')
  #   new_task = users.changeset(:tasks, title: 'A task')
  #
  #   new_task.associate(new_user, :users)
  # @example with a hash-like object
  #   user = users.users.by_pk(1).one
  #   new_task = users.changeset(:tasks, title: 'A task')
  #
  #   new_task.associate(user, :users)
  # @param other [#to_hash, Changeset] Other changeset or hash-like object
  # @param name [Symbol] The association identifier from schema
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#225
  def associate(other, name = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#248
  def command_compiler_options; end

  # Commit stateful changeset
  #
  # @api public
  # @see Changeset#commit
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#203
  def commit; end

  # Return changeset with data
  #
  # @api public
  # @param data [Hash]
  # @return [Changeset]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#170
  def data(data); end

  # Pipe changeset's data using custom steps define on the pipe.
  # You should use #map instead except updating timestamp fields.
  # Calling changeset.extend builds a pipe that excludes certain
  # steps for generating the diff. Currently the only place where
  # it is used is update changesets with the `:touch` step, i.e.
  # `changeset.extend(:touch).diff` will exclude `:updated_at`
  # from the diff.
  #
  # @api public
  # @return [Changeset]
  # @see Changeset::Stateful#map
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#151
  def extend(*steps, **options, &block); end

  # Return string representation of the changeset
  #
  # @api public
  # @return [String]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#243
  def inspect; end

  # Pipe changeset's data using custom steps define on the pipe
  #
  # @api public
  # @overload map
  # @overload map
  # @overload map
  # @return [Changeset]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#134
  def map(*steps, &block); end

  # Data transformation pipe
  #
  # @api private
  # @return [Changeset::Pipe]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#257
  def pipe; end

  # Return command result type
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#234
  def result; end

  # Coerce changeset to an array
  #
  # This will send the data through the pipe
  #
  # @api public
  # @return [Array]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#193
  def to_a; end

  # Coerce changeset to an array
  #
  # This will send the data through the pipe
  #
  # @api public
  # @return [Array]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#193
  def to_ary; end

  # Coerce changeset to a hash
  #
  # This will send the data through the pipe
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#181
  def to_h; end

  # Coerce changeset to a hash
  #
  # This will send the data through the pipe
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#181
  def to_hash; end

  private

  # @api private
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#269
  def method_missing(meth, *args, **_arg2, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-changeset//lib/rom/changeset/stateful.rb#264
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # Build default pipe object
    #
    # This can be overridden in a custom changeset subclass
    #
    # @return [Pipe]
    #
    # source://rom-changeset//lib/rom/changeset/stateful.rb#89
    def default_pipe(context); end

    # Define a changeset mapping excluded from diffs
    #
    # @api public
    # @return [Array<Pipe>, Transproc::Function] ]
    # @see Changeset::Stateful.map
    # @see Changeset::Stateful#extend
    #
    # source://rom-changeset//lib/rom/changeset/stateful.rb#76
    def extend(*_arg0, &block); end

    # @api private
    # @private
    #
    # source://rom-changeset//lib/rom/changeset/stateful.rb#94
    def inherited(klass); end

    # Define a changeset mapping
    #
    # Subsequent mapping definitions will be composed together
    # and applied in the order they way defined
    #
    # @api public
    # @example Transformation DSL
    #   class NewUser < ROM::Changeset::Create
    #   map do
    #   unwrap :address, prefix: true
    #   end
    #   end
    # @example Using custom block
    #   class NewUser < ROM::Changeset::Create
    #   map do |tuple|
    #   tuple.merge(created_at: Time.now)
    #   end
    #   end
    # @example Multiple mappings (executed in the order of definition)
    #   class NewUser < ROM::Changeset::Create
    #   map do
    #   unwrap :address, prefix: true
    #   end
    #
    #   map do |tuple|
    #   tuple.merge(created_at: Time.now)
    #   end
    #   end
    # @return [Array<Pipe>, Transproc::Function] ]
    # @see https://github.com/solnic/transproc Transproc
    #
    # source://rom-changeset//lib/rom/changeset/stateful.rb#60
    def map(**options, &block); end

    # @api private
    #
    # source://rom-changeset//lib/rom/changeset/stateful.rb#102
    def pipes; end
  end
end

# Default no-op pipe
#
# source://rom-changeset//lib/rom/changeset/stateful.rb#13
ROM::Changeset::Stateful::EMPTY_PIPE = T.let(T.unsafe(nil), ROM::Changeset::Pipe)

# Changeset specialization for update commands
#
# Update changesets will only execute their commands when
# the data is different from the original tuple. Original tuple
# is fetched from changeset's relation using `one` method.
#
# @api public
# @example
#   users.by_pk(1).changeset(:update, name: "Jane Doe").commit
# @see Changeset::Stateful
#
# source://rom-changeset//lib/rom/changeset/update.rb#17
class ROM::Changeset::Update < ::ROM::Changeset::Stateful
  # Return if there's no diff between the original and changeset data
  #
  # @api public
  # @return [TrueClass, FalseClass]
  #
  # source://rom-changeset//lib/rom/changeset/update.rb#56
  def clean?; end

  # Commit update changeset if there's a diff
  #
  # This returns original tuple if there's no diff
  #
  # @api public
  # @return [Hash]
  # @see Changeset#commit
  #
  # source://rom-changeset//lib/rom/changeset/update.rb#29
  def commit; end

  # Calculate the diff between the original and changeset data
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-changeset//lib/rom/changeset/update.rb#65
  def diff; end

  # Return true if there's a diff between original and changeset data
  #
  # @api public
  # @return [TrueClass, FalseClass]
  #
  # source://rom-changeset//lib/rom/changeset/update.rb#47
  def diff?; end

  # Return original tuple that this changeset may update
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-changeset//lib/rom/changeset/update.rb#38
  def original; end
end

# source://rom-changeset//lib/rom/plugins/relation/changeset.rb#12
module ROM::Plugins
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable::Methods

  class << self
    # source://rom-core/5.3.0/lib/rom/plugins.rb#14
    def register(entity_type, plugin_type: T.unsafe(nil), adapter: T.unsafe(nil)); end
  end
end

# source://rom-changeset//lib/rom/plugins/relation/changeset.rb#13
module ROM::Plugins::Relation; end

# Relation plugin which adds `Relation#changeset` method
#
# @api public
#
# source://rom-changeset//lib/rom/plugins/relation/changeset.rb#17
module ROM::Plugins::Relation::Changeset
  extend ::ROM::Notifications::Listener
end

# Relation instance methods provided by the Changeset plugin
#
# @api public
#
# source://rom-changeset//lib/rom/plugins/relation/changeset.rb#33
module ROM::Plugins::Relation::Changeset::InstanceMethods
  # Create a changeset for a relation
  #
  # @api public
  # @overload changeset
  # @overload changeset
  #
  # source://rom-changeset//lib/rom/plugins/relation/changeset.rb#83
  def changeset(type, data = T.unsafe(nil)); end
end

# @api public
#
# source://rom-changeset//lib/rom/plugins/relation/changeset.rb#18
ROM::Plugins::Relation::Changeset::TYPES = T.let(T.unsafe(nil), Hash)

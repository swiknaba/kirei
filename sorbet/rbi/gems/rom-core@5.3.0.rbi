# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rom-core` gem.
# Please instead update this file by running `bin/tapioca gem rom-core`.

# Constants and errors common in the whole library
#
# source://rom-core//lib/rom/constants.rb#4
module ROM
  include ::Dry::Core::Constants
  extend ::ROM::Global

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/create_container.rb#66
    def container(*args, &block); end
  end
end

# source://rom-core//lib/rom/constants.rb#7
class ROM::AdapterLoadError < ::StandardError; end

# Exception raised when a component is configured with an adapter that's not loaded
#
# source://rom-core//lib/rom/constants.rb#10
class ROM::AdapterNotPresentError < ::StandardError
  # @api private
  # @return [AdapterNotPresentError] a new instance of AdapterNotPresentError
  #
  # source://rom-core//lib/rom/constants.rb#12
  def initialize(adapter, component); end
end

# Store a set of registries grouped by adapter
#
# @api private
#
# source://rom-core//lib/rom/plugin_registry.rb#93
class ROM::AdapterPluginsContainer
  # @api private
  # @return [AdapterPluginsContainer] a new instance of AdapterPluginsContainer
  #
  # source://rom-core//lib/rom/plugin_registry.rb#105
  def initialize(type); end

  # Return the plugin for a given adapter
  #
  # @api public
  # @param name [Symbol] The name of the plugin
  # @param adapter_name [Symbol] (:default) The name of the adapter used
  # @raise [UnknownPluginError] if no plugin is found with the given name
  #
  # source://rom-core//lib/rom/plugin_registry.rb#134
  def [](name, adapter_name = T.unsafe(nil)); end

  # Return the plugin registry for a specific adapter
  #
  # @api private
  # @param name [Symbol] The name of the adapter
  # @return [AdapterRegistry]
  #
  # source://rom-core//lib/rom/plugin_registry.rb#117
  def adapter(name); end

  # Return the plugin for a given adapter
  #
  # @api public
  # @param name [Symbol] The name of the plugin
  # @param adapter_name [Symbol] (:default) The name of the adapter used
  # @raise [UnknownPluginError] if no plugin is found with the given name
  #
  # source://rom-core//lib/rom/plugin_registry.rb#134
  def fetch(name, adapter_name = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#122
  def register(name, mod, options); end

  # Return the existing registries
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/plugin_registry.rb#99
  def registries; end

  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#102
  def type; end
end

# Association set contains a registry with associations defined
# in schema DSL
#
# @api public
#
# source://rom-core//lib/rom/association_set.rb#10
class ROM::AssociationSet < ::ROM::Registry
  # @api private
  # @return [AssociationSet] a new instance of AssociationSet
  #
  # source://rom-core//lib/rom/association_set.rb#12
  def initialize(*_arg0, **_arg1); end
end

# source://rom-core//lib/rom/associations/through_identifier.rb#6
module ROM::Associations; end

# Abstract association class
#
# @api public
#
# source://rom-core//lib/rom/associations/abstract.rb#11
class ROM::Associations::Abstract
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::ROM::Memoizable
  include ::Dry::Core::Equalizer::Methods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::ROM::Memoizable::ClassInterface

  # Return if an association has an alias
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#53
  def aliased?; end

  # Applies custom view to the default association view
  #
  # @api protected
  # @return [Relation]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#128
  def apply_view(schema, relation); end

  # Return association alias
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#62
  def as; end

  # Return combine keys hash
  #
  # Combine keys are used for merging associated data together, typically these
  # are the same as fk<=>pk mapping
  #
  # @api public
  # @return [Hash<Symbol=>Symbol>]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def combine_keys; end

  # Return association foreign key name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#90
  def foreign_key; end

  # Return names of source PKs and target FKs
  #
  # @api private
  # @return [Array<Symbol>]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def join_key_map; end

  # Return the name of a key in tuples under which loaded association data are returned
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#119
  def key; end

  # Return association canonical name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#71
  def name; end

  # Return target relation configured as a combine node
  #
  # @api private
  # @return [Relation]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#159
  def node; end

  # Return if a custom view should override default association view
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#110
  def override?; end

  # Prepare association's target relation for composition
  #
  # @api private
  # @return [Relation]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#184
  def prepare(target); end

  # Return result type
  #
  # This can be either :one or :many
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#101
  def result; end

  # Return if this association's source relation is the same as the target
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#197
  def self_ref?; end

  # Return the name of a custom relation view that should be use to
  # extend or override default association view
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#81
  def view; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  # Return target relation as a wrap node
  #
  # @api private
  # @return [Relation]
  #
  # source://rom-core//lib/rom/associations/abstract.rb#171
  def wrap; end

  class << self
    # Create an association object
    #
    # @api public
    # @param definition [Definition] The association definition object
    # @param relations [RelationRegistry] The relation registry
    #
    # source://rom-core//lib/rom/associations/abstract.rb#39
    def new(definition, relations); end
  end
end

# source://rom-core//lib/rom/associations/definitions/abstract.rb#11
module ROM::Associations::Definitions; end

# Abstract association definition object
#
# @api public
#
# source://rom-core//lib/rom/associations/definitions/abstract.rb#15
class ROM::Associations::Definitions::Abstract
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # Return true if association is aliased
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/associations/definitions/abstract.rb#117
  def aliased?; end

  # Return true if association's default relation view should be overridden by a custom one
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/associations/definitions/abstract.rb#108
  def override?; end

  # Return association class for a given definition object
  #
  # @api public
  # @return [Class]
  #
  # source://rom-core//lib/rom/associations/definitions/abstract.rb#126
  def type; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # Instantiate a new association definition
    #
    # @api public
    # @option opts
    # @option opts
    # @option opts
    # @option opts
    # @option opts
    # @param source [Symbol] The name of the source dataset
    # @param target [Symbol] The name of the target dataset
    # @param opts [Hash] The option hash
    #
    # source://rom-core//lib/rom/associations/definitions/abstract.rb#74
    def new(source, target, **opts); end

    # @api private
    #
    # source://rom-core//lib/rom/associations/definitions/abstract.rb#91
    def process_options(target, options); end

    # @api private
    #
    # source://rom-core//lib/rom/associations/definitions/abstract.rb#83
    def resolve_target_name(target, options); end
  end
end

# @api private
#
# source://rom-core//lib/rom/associations/definitions/many_to_many.rb#10
class ROM::Associations::Definitions::ManyToMany < ::ROM::Associations::Definitions::Abstract
  # @api private
  #
  # source://rom-core//lib/rom/associations/definitions/many_to_many.rb#23
  def through_assoc_name; end

  # @api private
  #
  # source://rom-core//lib/rom/associations/definitions/many_to_many.rb#18
  def through_relation; end
end

# @api private
#
# source://rom-core//lib/rom/associations/definitions/many_to_one.rb#9
class ROM::Associations::Definitions::ManyToOne < ::ROM::Associations::Definitions::Abstract; end

# @api private
#
# source://rom-core//lib/rom/associations/definitions/one_to_many.rb#9
class ROM::Associations::Definitions::OneToMany < ::ROM::Associations::Definitions::Abstract; end

# @api private
#
# source://rom-core//lib/rom/associations/definitions/one_to_one.rb#9
class ROM::Associations::Definitions::OneToOne < ::ROM::Associations::Definitions::Abstract; end

# @api private
#
# source://rom-core//lib/rom/associations/definitions/one_to_one_through.rb#9
class ROM::Associations::Definitions::OneToOneThrough < ::ROM::Associations::Definitions::ManyToMany; end

# Abstract many-to-many association type
#
# @api public
#
# source://rom-core//lib/rom/associations/many_to_many.rb#11
class ROM::Associations::ManyToMany < ::ROM::Associations::Abstract
  # @api private
  # @return [ManyToMany] a new instance of ManyToMany
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#17
  def initialize(*_arg0, **_arg1); end

  # Associate child tuples with the provided parent
  #
  # @api private
  # @param children [Array<Hash>] An array with child tuples
  # @param parent [Array, Hash] An array with parent tuples or a single tuple
  # @return [Array<Hash>]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#67
  def associate(children, parent); end

  # Adapters should implement this method
  #
  # @abstract
  # @api public
  # @raise [NotImplementedError]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#28
  def call(*_arg0); end

  # Return configured or inferred FK name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def foreign_key; end

  # Return association for many-to-many-through
  #
  # @api protected
  # @return [Association]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def join_assoc; end

  # Return a [pk, fk] mapping for source/target relations
  #
  # @api protected
  # @return [Array<Symbol>]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def join_key_map; end

  # @api public
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#14
  def join_relation; end

  # Return parent's relation combine keys
  #
  # @api private
  # @return [Hash<Symbol=>Symbol>]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#55
  def parent_combine_keys; end

  # Return join-relation name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#46
  def through; end

  protected

  # Primary key name on the source side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#87
  def source_key; end

  # Foreign key name on the target side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/many_to_many.rb#96
  def target_key; end
end

# Abstract many-to-one association type
#
# @api public
#
# source://rom-core//lib/rom/associations/many_to_one.rb#10
class ROM::Associations::ManyToOne < ::ROM::Associations::Abstract
  # Associate child with a parent
  #
  # @api private
  # @param child [Hash] The child tuple
  # @param parent [Hash] The parent tuple
  # @return [Hash]
  #
  # source://rom-core//lib/rom/associations/many_to_one.rb#37
  def associate(child, parent); end

  # Adapters must implement this method
  #
  # @abstract
  # @api public
  # @raise [NotImplementedError]
  #
  # source://rom-core//lib/rom/associations/many_to_one.rb#16
  def call(*_arg0); end

  # Return configured or inferred FK name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def foreign_key; end

  protected

  # Return foreign key on the source side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/many_to_one.rb#49
  def source_key; end

  # Return primary key on the target side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/many_to_one.rb#58
  def target_key; end
end

# Abstract one-to-many association
#
# @api public
#
# source://rom-core//lib/rom/associations/one_to_many.rb#10
class ROM::Associations::OneToMany < ::ROM::Associations::Abstract
  # Associate child tuple with a parent
  #
  # @api private
  # @param child [Hash] The child tuple
  # @param parent [Hash] The parent tuple
  # @return [Hash]
  #
  # source://rom-core//lib/rom/associations/one_to_many.rb#37
  def associate(child, parent); end

  # Adapters must implement this method
  #
  # @abstract
  # @api public
  # @raise [NotImplementedError]
  #
  # source://rom-core//lib/rom/associations/one_to_many.rb#16
  def call(*_arg0); end

  # Return configured or inferred FK name
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def foreign_key; end

  protected

  # Return primary key on the source side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/one_to_many.rb#49
  def source_key; end

  # Return foreign key name on the target side
  #
  # @api protected
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/associations/one_to_many.rb#58
  def target_key; end
end

# @api private
#
# source://rom-core//lib/rom/associations/through_identifier.rb#8
class ROM::Associations::ThroughIdentifier
  # @api private
  # @return [ThroughIdentifier] a new instance of ThroughIdentifier
  #
  # source://rom-core//lib/rom/associations/through_identifier.rb#29
  def initialize(source, target, assoc_name); end

  # @api private
  #
  # source://rom-core//lib/rom/associations/through_identifier.rb#16
  def assoc_name; end

  # @api private
  #
  # source://rom-core//lib/rom/associations/through_identifier.rb#10
  def source; end

  # @api private
  #
  # source://rom-core//lib/rom/associations/through_identifier.rb#13
  def target; end

  # @api private
  #
  # source://rom-core//lib/rom/associations/through_identifier.rb#36
  def to_sym; end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/associations/through_identifier.rb#19
    def [](source, target, assoc_name = T.unsafe(nil)); end

    # @api private
    #
    # source://rom-core//lib/rom/associations/through_identifier.rb#24
    def default_assoc_name(relation); end
  end
end

# Schema attributes provide meta information about types and an API
# for additional operations. This class can be extended by adapters to provide
# database-specific features. In example rom-sql provides SQL::Attribute
# with more features like creating SQL expressions for queries.
#
# Schema attributes are accessible through canonical relation schemas and
# instance-level schemas.
#
# @api public
#
# source://rom-core//lib/rom/attribute.rb#17
class ROM::Attribute
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Memoizable
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Memoizable::ClassInterface
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  #
  # source://rom-core//lib/rom/attribute.rb#60
  def [](value = T.unsafe(nil)); end

  # Return new attribute type with provided alias
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :user_id, Types::Integer
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   aliased_user_id = Users.schema[:user_id].aliased(:id)
  #
  #   aliased_user_id.aliased?
  #   # => true
  #
  #   aliased_user_id.name
  #   # => :user_id
  #
  #   aliased_user_id.alias
  #   # => :id
  # @param name [Symbol] The alias
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#232
  def aliased(name); end

  # Return true if this attribute has a configured alias
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :user_id, Types::Integer, alias: :id
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   Users.schema[:user_id].aliased?
  #   # => true
  #
  #   Users.schema[:name].aliased?
  #   # => false
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/attribute.rb#131
  def aliased?; end

  # Return new attribute type with provided alias
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :user_id, Types::Integer
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   aliased_user_id = Users.schema[:user_id].aliased(:id)
  #
  #   aliased_user_id.aliased?
  #   # => true
  #
  #   aliased_user_id.name
  #   # => :user_id
  #
  #   aliased_user_id.alias
  #   # => :id
  # @param name [Symbol] The alias
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#232
  def as(name); end

  # Check if the attribute type is equal to another
  #
  # @api public
  # @param other [Dry::Type, Attribute]
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/attribute.rb#330
  def eql?(other); end

  # Return true if this attribute type is a foreign key
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :id, Types::Integer
  #   attribute :user_id, Types.ForeignKey(:users)
  #   end
  #   end
  #
  #   Users.schema[:user_id].foreign_key?
  #   # => true
  #
  #   Users.schema[:id].foreign_key?
  #   # => false
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/attribute.rb#108
  def foreign_key?; end

  # Return string representation of the attribute type
  #
  # @api public
  # @return [String]
  #
  # source://rom-core//lib/rom/attribute.rb#316
  def inspect; end

  # Return tuple key
  #
  # When schemas are projected with aliased attributes, we need a simple access to tuple keys
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :user_id, Types::Integer, alias: :id
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   Users.schema[:id].key
  #   # :id
  #
  #   Users.schema.project(Users.schema[:id].aliased(:user_id)).key
  #   # :user_id
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/attribute.rb#202
  def key; end

  # Return attribute type with additional meta information
  #
  # Return meta information hash if no opts are provided
  #
  # @api public
  # @param opts [Hash] The meta options
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#303
  def meta(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def meta_options_ast; end

  # Return nullable attribute
  #
  # @api public
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#367
  def optional; end

  # Return new attribute type with an alias using provided prefix
  #
  # @api public
  # @example
  #   class Users < ROM::Relation[:memory]
  #   schema do
  #   attribute :id, Types::Integer
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   prefixed_id = Users.schema[:id].prefixed
  #
  #   prefixed_id.aliased?
  #   # => true
  #
  #   prefixed_id.name
  #   # => :id
  #
  #   prefixed_id.alias
  #   # => :users_id
  #
  #   prefixed_id = Users.schema[:id].prefixed(:user)
  #
  #   prefixed_id.alias
  #   # => :user_id
  # @param prefix [Symbol] The prefix (defaults to source.dataset)
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#268
  def prefixed(prefix = T.unsafe(nil)); end

  # Return string representation of the attribute type
  #
  # @api public
  # @return [String]
  #
  # source://rom-core//lib/rom/attribute.rb#316
  def pretty_inspect; end

  # Return true if this attribute type is a primary key
  #
  # @api public
  # @example
  #   class Users < ROM::Relation[:memory]
  #   schema do
  #   attribute :id, Types::Integer
  #   attribute :name, Types::String
  #
  #   primary_key :id
  #   end
  #   end
  #
  #   Users.schema[:id].primary_key?
  #   # => true
  #
  #   Users.schema[:name].primary_key?
  #   # => false
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/attribute.rb#85
  def primary_key?; end

  # Return if this attribute type has additional attribute type for reading
  # tuple values
  #
  # @api private
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/attribute.rb#340
  def read?; end

  # Return source relation of this attribute type
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :id, Types::Integer
  #   attribute :user_id, Types.ForeignKey(:users)
  #   end
  #   end
  #
  #   Users.schema[:id].source
  #   # => :tasks
  #
  #   Users.schema[:user_id].source
  #   # => :tasks
  # @return [Symbol, Relation::Name]
  #
  # source://rom-core//lib/rom/attribute.rb#154
  def source; end

  # Return target relation of this attribute type
  #
  # @api public
  # @example
  #   class Tasks < ROM::Relation[:memory]
  #   schema do
  #   attribute :id, Types::Integer
  #   attribute :user_id, Types.ForeignKey(:users)
  #   end
  #   end
  #
  #   Users.schema[:id].target
  #   # => nil
  #
  #   Users.schema[:user_id].target
  #   # => :users
  # @return [NilClass, Symbol, Relation::Name]
  #
  # source://rom-core//lib/rom/attribute.rb#177
  def target; end

  # Return AST for the type
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_ast; end

  # Return AST for the read type
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_read_ast; end

  # Return read type
  #
  # @api private
  # @return [Dry::Types::Type]
  #
  # source://rom-core//lib/rom/attribute.rb#349
  def to_read_type; end

  # Return write type
  #
  # @api private
  # @return [Dry::Types::Type]
  #
  # source://rom-core//lib/rom/attribute.rb#358
  def to_write_type; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  # Return attribute type wrapped for the specified relation name
  #
  # @api public
  # @param name [Symbol] The name of the source relation (defaults to source.dataset)
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/attribute.rb#290
  def wrapped(name = T.unsafe(nil)); end

  # Return if the attribute type is from a wrapped relation
  #
  # Wrapped attributes are used when two schemas from different relations
  # are merged together. This way we can identify them easily and handle
  # correctly in places like auto-mapping.
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/attribute.rb#279
  def wrapped?; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/attribute.rb#408
  def method_missing(meth, *args, **_arg2, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/attribute.rb#373
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# @api public
#
# source://rom-core//lib/rom/attribute.rb#23
ROM::Attribute::META_OPTIONS = T.let(T.unsafe(nil), Array)

# source://rom-core//lib/rom/constants.rb#32
class ROM::AttributeAlreadyDefinedError < ::StandardError; end

# Relation extension which provides auto-currying of relation view methods
#
# @api private
#
# source://rom-core//lib/rom/auto_curry.rb#7
module ROM::AutoCurry
  # @api private
  #
  # source://rom-core//lib/rom/auto_curry.rb#31
  def auto_curried_methods; end

  # Auto-curry a method
  #
  # @api private
  # @param name [Symbol] The name of a method
  #
  # source://rom-core//lib/rom/auto_curry.rb#40
  def auto_curry(name, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/auto_curry.rb#26
  def auto_curry_busy?; end

  # @api private
  #
  # source://rom-core//lib/rom/auto_curry.rb#18
  def auto_curry_guard; end

  class << self
    # @api private
    # @private
    #
    # source://rom-core//lib/rom/auto_curry.rb#8
    def extended(klass); end
  end
end

# AutoRegistration is used to load component files automatically from the provided directory path
#
# @api public
#
# source://rom-core//lib/rom/setup/auto_registration.rb#17
class ROM::AutoRegistration
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # Load command files
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration.rb#64
  def commands; end

  # Load mapper files
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration.rb#71
  def mappers; end

  # Load relation files
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration.rb#57
  def relations; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # Load given component files
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration.rb#80
  def load_entities(entity); end
end

# @api public
#
# source://rom-core//lib/rom/setup/auto_registration.rb#24
ROM::AutoRegistration::DEFAULT_MAPPING = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://rom-core//lib/rom/setup/auto_registration.rb#20
ROM::AutoRegistration::NamespaceType = T.let(T.unsafe(nil), Dry::Types::Sum::Constrained)

# @api public
#
# source://rom-core//lib/rom/setup/auto_registration.rb#22
ROM::AutoRegistration::PathnameType = T.let(T.unsafe(nil), Dry::Types::Constructor)

# source://rom-core//lib/rom/setup/auto_registration_strategies/base.rb#7
module ROM::AutoRegistrationStrategies; end

# Base class for registration strategies
#
# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/base.rb#11
class ROM::AutoRegistrationStrategies::Base
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end
end

# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/base.rb#16
ROM::AutoRegistrationStrategies::Base::EXTENSION_REGEX = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/base.rb#14
ROM::AutoRegistrationStrategies::Base::PathnameType = T.let(T.unsafe(nil), Dry::Types::Constrained)

# Custom namespace strategy loads components and assumes they are defined
# within the provided namespace
#
# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#15
class ROM::AutoRegistrationStrategies::CustomNamespace < ::ROM::AutoRegistrationStrategies::Base
  # Loads components
  #
  # @api private
  # @raise [NameError]
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#27
  def call; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#78
  def file_path; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#63
  def filename; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#56
  def name_error_message(attempted); end

  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#68
  def ns_const; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/custom_namespace.rb#73
  def path_arr; end
end

# NoNamespace strategy assumes components are not defined within a namespace
#
# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/no_namespace.rb#14
class ROM::AutoRegistrationStrategies::NoNamespace < ::ROM::AutoRegistrationStrategies::Base
  # Load components
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/no_namespace.rb#26
  def call; end
end

# WithNamespace strategy assumes components are defined within a namespace
# that matches top-level directory name.
#
# @api private
#
# source://rom-core//lib/rom/setup/auto_registration_strategies/with_namespace.rb#14
class ROM::AutoRegistrationStrategies::WithNamespace < ::ROM::AutoRegistrationStrategies::Base
  # Load components
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/auto_registration_strategies/with_namespace.rb#22
  def call; end
end

# Thread-safe cache used by various rom components
#
# @api private
#
# source://rom-core//lib/rom/cache.rb#9
class ROM::Cache
  # @api private
  # @return [Cache] a new instance of Cache
  #
  # source://rom-core//lib/rom/cache.rb#48
  def initialize; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#53
  def [](key); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#58
  def fetch_or_store(*args, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#73
  def inspect; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#68
  def namespaced(namespace); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#10
  def objects; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#63
  def size; end
end

# @api private
#
# source://rom-core//lib/rom/cache.rb#13
class ROM::Cache::Namespaced
  # @api private
  # @return [Namespaced] a new instance of Namespaced
  #
  # source://rom-core//lib/rom/cache.rb#21
  def initialize(cache, namespace); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#27
  def [](key); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#15
  def cache; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#32
  def fetch_or_store(*args, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#42
  def inspect; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#18
  def namespace; end

  # @api private
  #
  # source://rom-core//lib/rom/cache.rb#37
  def size; end
end

class ROM::Changeset
  extend ::Dry::Initializer
  extend ::Dry::Core::Constants

  # source://rom-changeset/5.3.0/lib/rom/changeset.rb#161
  def command; end

  # source://rom-changeset/5.3.0/lib/rom/changeset.rb#170
  def command_compiler_options; end

  # source://rom-changeset/5.3.0/lib/rom/changeset.rb#143
  def commit; end

  # source://rom-changeset/5.3.0/lib/rom/changeset.rb#152
  def inspect; end

  # source://rom-changeset/5.3.0/lib/rom/changeset.rb#129
  def new(relation, **new_options); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # source://rom-changeset/5.3.0/lib/rom/changeset.rb#106
    def [](relation_name); end

    # source://rom-changeset/5.3.0/lib/rom/changeset.rb#115
    def use(plugin, **options); end
  end
end

class ROM::Changeset::Associated
  extend ::Dry::Initializer

  # source://rom-changeset/5.3.0/lib/rom/changeset/associated.rb#65
  def associate(other, name = T.unsafe(nil)); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/associated.rb#89
  def command; end

  # source://rom-changeset/5.3.0/lib/rom/changeset/associated.rb#54
  def commit; end

  # source://rom-changeset/5.3.0/lib/rom/changeset/associated.rb#105
  def relation; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # source://rom-changeset/5.3.0/lib/rom/changeset/associated.rb#30
    def infer_assoc_name(other); end
  end
end

class ROM::Changeset::Pipe < ::Transproc::Transformer
  extend ::Dry::Initializer

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#55
  def >>(other, for_diff: T.unsafe(nil)); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#40
  def [](*args); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#44
  def bind(context); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#70
  def call(data); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#55
  def compose(other, for_diff: T.unsafe(nil)); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#74
  def for_diff(data); end

  # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#78
  def new(processor, **opts); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  class << self
    # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#36
    def [](name_or_proc); end

    # source://rom-changeset/5.3.0/lib/rom/changeset/pipe.rb#22
    def new(*args, **opts); end
  end
end

# Base command class with factory class-level interface and setup-related logic
#
# @private
#
# source://rom-core//lib/rom/commands/class_interface.rb#9
class ROM::Command
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Commands
  include ::ROM::Pipeline::Operator
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::ROM::Command::ClassInterface

  # Call the command and return one or many tuples
  #
  # This method will apply before/after hooks automatically
  #
  # @api public
  #
  # source://rom-core//lib/rom/command.rb#268
  def [](*args, &block); end

  # Return a new command with appended after hooks
  #
  # @api public
  # @param hooks [Array<Hash>] A list of after hooks configurations
  # @return [Command]
  #
  # source://rom-core//lib/rom/command.rb#357
  def after(*hooks); end

  # List of after hooks
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/command.rb#375
  def after_hooks; end

  # Return a new command with appended before hooks
  #
  # @api public
  # @param hooks [Array<Hash>] A list of before hooks configurations
  # @return [Command]
  #
  # source://rom-core//lib/rom/command.rb#346
  def before(*hooks); end

  # List of before hooks
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/command.rb#366
  def before_hooks; end

  # Call the command and return one or many tuples
  #
  # This method will apply before/after hooks automatically
  #
  # @api public
  #
  # source://rom-core//lib/rom/command.rb#268
  def call(*args, &block); end

  # Compose this command with other commands
  #
  # Composed commands can handle nested input
  #
  # @api public
  # @return [Command::Graph]
  #
  # source://rom-core//lib/rom/command.rb#326
  def combine(*others); end

  # Check if this command is curried
  #
  # @api public
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/command.rb#335
  def curried?; end

  # Curry this command with provided args
  #
  # Curried command can be called without args. If argument is a graph input processor,
  # lazy command will be returned, which is used for handling nested input hashes.
  #
  # @api public
  # @return [Command, Lazy]
  #
  # source://rom-core//lib/rom/command.rb#311
  def curry(*args); end

  # Execute the command
  #
  # @abstract
  # @api private
  # @raise [NotImplementedError]
  # @return [Array] an array with inserted tuples
  #
  # source://rom-core//lib/rom/command.rb#256
  def execute(*_arg0); end

  # Return gateway of this command's relation
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/command.rb#245
  def gateway; end

  # Check if this command is a graph
  #
  # @api private
  # @return [false]
  #
  # source://rom-core//lib/rom/command.rb#411
  def graph?; end

  # Check if this command has any hooks
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/command.rb#393
  def hooks?; end

  # Check if this command is lazy
  #
  # @api private
  # @return [false]
  #
  # source://rom-core//lib/rom/command.rb#402
  def lazy?; end

  # Check if this command returns many tuples
  #
  # @api private
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/command.rb#429
  def many?; end

  # Yields tuples for insertion or return an enumerator
  #
  # @api private
  #
  # source://rom-core//lib/rom/command.rb#445
  def map_input_tuples(tuples, &mapper); end

  # Return name of this command's relation
  #
  # @api public
  # @return [ROM::Relation::Name]
  #
  # source://rom-core//lib/rom/command.rb#236
  def name; end

  # Return a new command with other source relation
  #
  # This can be used to restrict command with a specific relation
  #
  # @api public
  # @return [Command]
  #
  # source://rom-core//lib/rom/command.rb#386
  def new(new_relation); end

  # Check if this command returns a single tuple
  #
  # @api private
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/command.rb#420
  def one?; end

  # Check if this command is restrictible through relation
  #
  # @api private
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/command.rb#438
  def restrictible?; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # Apply provided hooks
  #
  # Used by #call
  #
  # @api private
  # @return [Array<Hash>]
  #
  # source://rom-core//lib/rom/command.rb#473
  def apply_hooks(hooks, tuples, *args); end

  # Hook called by Pipeline to get composite class for commands
  #
  # @api private
  # @return [Class]
  #
  # source://rom-core//lib/rom/command.rb#462
  def composite_class; end

  # Pipes a dataset through command's relation
  #
  # @api private
  # @return [Array]
  #
  # source://rom-core//lib/rom/command.rb#489
  def wrap_dataset(dataset); end
end

# source://rom-core//lib/rom/commands/class_interface.rb#10
module ROM::Command::ClassInterface
  # Return adapter specific sub-class based on the adapter identifier
  #
  # This is a syntax sugar to make things consistent
  #
  # @api public
  # @example
  #   ROM::Commands::Create[:memory]
  #   # => ROM::Memory::Commands::Create
  # @param adapter [Symbol] identifier
  # @return [Class]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#42
  def [](adapter); end

  # Return namespaces that contains command subclasses of a specific adapter
  #
  # @api private
  # @param adapter [Symbol] identifier
  # @return [Module]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#53
  def adapter_namespace(adapter); end

  # Set after-execute hooks
  #
  # @api public
  # @overload after
  # @overload after
  # @return [Array<Hash, Symbol>] A list of all configured after hooks
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#210
  def after(*hooks); end

  # Set before-execute hooks
  #
  # @api public
  # @overload before
  # @overload before
  # @return [Array<Hash, Symbol>] A list of all configured before hooks
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#165
  def before(*hooks); end

  # Build a command class for a specific relation with options
  #
  # @api public
  # @example
  #   class CreateUser < ROM::Commands::Create[:memory]
  #   end
  #
  #   command = CreateUser.build(rom.relations[:users])
  # @param relation [Relation]
  # @param options [Hash]
  # @return [Command]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#73
  def build(relation, **options); end

  # Create a command class with a specific type
  #
  # @api public
  # @param name [Symbol] Command name
  # @param type [Class] Command class
  # @return [Class, Object]
  # @yield [Class]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#87
  def create_class(name, type, &block); end

  # Return default name of the command class based on its name
  #
  # During setup phase this is used by defalut as `register_as` option
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#238
  def default_name; end

  # Extend a command class with relation view methods
  #
  # @api public
  # @param relation [Relation]
  # @return [Class]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#124
  def extend_for_relation(relation); end

  # This hook sets up default class state
  #
  # @api private
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#14
  def inherited(klass); end

  # Return default options based on class macros
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#247
  def options; end

  # @api private
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#252
  def relation_methods_mod(relation_class); end

  # Set new or more hooks
  #
  # @api private
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#221
  def set_hooks(type, hooks); end

  # Use a configured plugin in this relation
  #
  # @api public
  # @example
  #   class CreateUser < ROM::Commands::Create[:memory]
  #   use :pagintion
  #
  #   per_page 30
  #   end
  # @option options
  # @param plugin [Symbol]
  # @param options [Hash]
  #
  # source://rom-core//lib/rom/commands/class_interface.rb#113
  def use(plugin, **options); end

  class << self
    # Sets up the base class
    #
    # @api private
    #
    # source://rom-core//lib/rom/commands/class_interface.rb#23
    def extended(klass); end
  end
end

# @api public
#
# source://rom-core//lib/rom/command.rb#197
ROM::Command::CommandType = T.let(T.unsafe(nil), Dry::Types::Enum)

# @api public
#
# source://rom-core//lib/rom/command.rb#198
ROM::Command::Result = T.let(T.unsafe(nil), Dry::Types::Enum)

# Builds commands for relations.
#
# This class is used by repositories to automatically create commands for
# their relations. This is used both by `Repository#command` method and
# `commands` repository class macros.
#
# @api private
#
# source://rom-core//lib/rom/command_compiler.rb#17
class ROM::CommandCompiler
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # Return a specific command type for a given adapter and relation AST
  #
  # This class holds its own registry where all generated commands are being
  # stored
  #
  # CommandProxy is returned for complex command graphs as they expect root
  # relation name to be present in the input, which we don't want to have
  # in repositories. It might be worth looking into removing this requirement
  # from rom core Command::Graph API.
  #
  # @api private
  # @overload []
  #
  # source://rom-core//lib/rom/command_compiler.rb#89
  def [](*args); end

  # Return a specific command type for a given adapter and relation AST
  #
  # This class holds its own registry where all generated commands are being
  # stored
  #
  # CommandProxy is returned for complex command graphs as they expect root
  # relation name to be present in the input, which we don't want to have
  # in repositories. It might be worth looking into removing this requirement
  # from rom core Command::Graph API.
  #
  # @api private
  # @overload []
  #
  # source://rom-core//lib/rom/command_compiler.rb#89
  def call(*args); end

  # @api private
  #
  # source://rom-core//lib/rom/command_compiler.rb#116
  def type; end

  # @api private
  #
  # source://rom-core//lib/rom/command_compiler.rb#123
  def visit(ast, *args); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # Build a command object for a specific relation
  #
  # The command will be prepared for handling associations if it's a combined
  # relation. Additional plugins will be enabled if they are configured for
  # this compiler.
  #
  # @api private
  # @param rel_name [Symbol] A relation identifier from the container registry
  # @param type [Symbol] The command type
  # @param rel_meta [Hash] Meta information from relation AST
  # @param parent_relation [Symbol] Optional parent relation identifier
  # @return [ROM::Command]
  #
  # source://rom-core//lib/rom/command_compiler.rb#190
  def register_command(rel_name, type, rel_meta, parent_relation = T.unsafe(nil)); end

  # Return default result type
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/command_compiler.rb#225
  def result; end

  # Sets up `associates` plugin for a given command class and relation
  #
  # @api private
  # @param klass [Class] The command class
  # @param relation [Relation] The relation for the command
  #
  # source://rom-core//lib/rom/command_compiler.rb#235
  def setup_associates(klass, relation, _meta, parent_relation); end

  # @api private
  #
  # source://rom-core//lib/rom/command_compiler.rb#172
  def visit_attribute(*_args); end

  # @api private
  #
  # source://rom-core//lib/rom/command_compiler.rb#131
  def visit_relation(node, parent_relation = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/command_compiler.rb#21
    def registry; end
  end
end

# source://rom-core//lib/rom/constants.rb#26
class ROM::CommandError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#57
class ROM::CommandNotFoundError < ::ROM::ElementNotFoundError
  # source://rom-core//lib/rom/constants.rb#59
  def set_message(key, registry); end
end

# TODO: look into making command graphs work without the root key in the input
#       so that we can get rid of this wrapper
#
# @api private
#
# source://rom-core//lib/rom/command_proxy.rb#10
class ROM::CommandProxy
  # @api private
  # @return [CommandProxy] a new instance of CommandProxy
  #
  # source://rom-core//lib/rom/command_proxy.rb#14
  def initialize(command, root = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/command_proxy.rb#25
  def >>(other); end

  # @api private
  #
  # source://rom-core//lib/rom/command_proxy.rb#20
  def call(input); end

  # @api private
  #
  # source://rom-core//lib/rom/command_proxy.rb#11
  def command; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/command_proxy.rb#30
  def restrictible?; end

  # @api private
  #
  # source://rom-core//lib/rom/command_proxy.rb#11
  def root; end
end

# Specialized registry class for commands
#
# @api public
#
# source://rom-core//lib/rom/command_registry.rb#12
class ROM::CommandRegistry < ::ROM::Registry
  # Return a command from the registry
  #
  # If mapper is set command will be turned into a composite command with
  # auto-mapping
  #
  # @api public
  # @overload []
  # @overload []
  # @return [Command, Command::Composite]
  #
  # source://rom-core//lib/rom/command_registry.rb#63
  def [](*args); end

  # Specify a mapper that should be used for commands from this registry
  #
  # @api public
  # @example
  #   entity_commands = rom.commands[:users].map_with(:entity)
  # @param mapper_name [Symbol] The name of a registered mapper
  # @return [CommandRegistry]
  #
  # source://rom-core//lib/rom/command_registry.rb#89
  def map_with(mapper_name); end

  # @api private
  #
  # source://rom-core//lib/rom/command_registry.rb#94
  def set_compiler(compiler); end

  # @api private
  #
  # source://rom-core//lib/rom/command_registry.rb#99
  def set_mappers(mappers); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # Allow retrieving commands using dot-notation
  #
  # @api private
  #
  # source://rom-core//lib/rom/command_registry.rb#115
  def method_missing(name, *_arg1); end

  # Allow checking if a certain command is available using dot-notation
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/command_registry.rb#108
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/command_registry.rb#37
    def element_not_found_error; end
  end
end

# source://rom-core//lib/rom/commands/composite.rb#6
module ROM::Commands; end

# Composite command that consists of left and right commands
#
# @api public
#
# source://rom-core//lib/rom/commands/composite.rb#10
class ROM::Commands::Composite < ::ROM::Pipeline::Composite
  # Calls the composite command
  #
  # Right command is called with a result from the left one
  #
  # @api public
  # @return [Object]
  #
  # source://rom-core//lib/rom/commands/composite.rb#18
  def [](*args); end

  # Calls the composite command
  #
  # Right command is called with a result from the left one
  #
  # @api public
  # @return [Object]
  #
  # source://rom-core//lib/rom/commands/composite.rb#18
  def call(*args); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/commands/composite.rb#50
  def decorate?(response); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/commands/composite.rb#40
  def graph?; end

  # @api private
  #
  # source://rom-core//lib/rom/commands/composite.rb#45
  def result; end
end

# Create command
#
# This command inserts a new tuple into a relation
#
# @abstract
#
# source://rom-core//lib/rom/commands/create.rb#12
class ROM::Commands::Create < ::ROM::Command; end

# Delete command
#
# This command removes tuples from its target relation
#
# @abstract
#
# source://rom-core//lib/rom/commands/delete.rb#12
class ROM::Commands::Delete < ::ROM::Command; end

# Command graph
#
# @api private
#
# source://rom-core//lib/rom/commands/graph/input_evaluator.rb#5
class ROM::Commands::Graph
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Pipeline::Operator
  include ::ROM::Pipeline
  include ::ROM::Pipeline::Proxy
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::ROM::Commands::Graph::ClassInterface

  # Calls root and all nodes with the result from root
  #
  # Graph results are mappable through `combine` operation in mapper DSL
  #
  # @api public
  # @example
  #   create_user = rom.commands[:users].create
  #   create_task = rom.commands[:tasks].create
  #
  #   command = create_user
  #   .curry(name: 'Jane')
  #   .combine(create_task.curry(title: 'Task'))
  #
  #   command.call
  # @return [Array] nested array with command results
  #
  # source://rom-core//lib/rom/commands/graph.rb#52
  def call(*args); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/commands/graph.rb#78
  def graph?; end

  # @api private
  def left; end

  # @api private
  def right; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # @api public
  #
  # source://rom-core//lib/rom/commands/graph.rb#85
  def composite_class; end
end

# Class methods for command Graph
#
# @api private
#
# source://rom-core//lib/rom/commands/graph/class_interface.rb#11
module ROM::Commands::Graph::ClassInterface
  # Build a command graph recursively
  #
  # This is used by `Container#command` when array with options is passed in
  #
  # @api private
  # @param registry [Registry] The command registry from container
  # @param options [Array] The options array
  # @param path [Array] The path for input evaluator proc
  # @return [Graph]
  #
  # source://rom-core//lib/rom/commands/graph/class_interface.rb#23
  def build(registry, options, path = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/commands/graph/class_interface.rb#28
  def build_command(registry, spec, other, path); end
end

# Evaluator for lazy commands which extracts values for commands from nested hashes
#
# @api private
#
# source://rom-core//lib/rom/commands/graph/input_evaluator.rb#9
class ROM::Commands::Graph::InputEvaluator
  include ::Dry::Core::Equalizer::Methods

  # Initialize a new input evaluator
  #
  # @api private
  # @return [InputEvaluator]
  #
  # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#59
  def initialize(tuple_path, excluded_keys); end

  # Evaluate input hash
  #
  # @api private
  # @param input [Hash] The input hash
  # @param index [Integer] Optional index
  # @return [Hash]
  #
  # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#71
  def call(input, index = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#22
  def exclude_proc; end

  # @api private
  #
  # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#18
  def excluded_keys; end

  # @api private
  #
  # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#14
  def tuple_path; end

  class << self
    # Build an input evaluator
    #
    # @api private
    # @param tuple_path [Array<Symbol>] The tuple path
    # @param nodes [Array]
    # @return [InputEvaluator]
    #
    # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#32
    def build(tuple_path, nodes); end

    # Return default exclude_proc
    #
    # @api private
    #
    # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#50
    def exclude_proc(excluded_keys); end

    # @api private
    #
    # source://rom-core//lib/rom/commands/graph/input_evaluator.rb#37
    def extract_excluded_keys(nodes); end
  end
end

# Lazy command wraps another command and evaluates its input when called
#
# @api private
#
# source://rom-core//lib/rom/commands/lazy.rb#11
class ROM::Commands::Lazy
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Lazy] a new instance of Lazy
  #
  # source://rom-core//lib/rom/commands/lazy.rb#36
  def initialize(command, evaluator, command_proc = T.unsafe(nil)); end

  # Compose a lazy command with another one
  #
  # @api public
  # @return [Composite]
  # @see Commands::Abstract#>>
  #
  # source://rom-core//lib/rom/commands/lazy.rb#58
  def >>(other); end

  # Evaluate command's input using the input proc and pass to command
  #
  # @api public
  # @raise [NotImplementedError]
  # @return [Array, Hash]
  #
  # source://rom-core//lib/rom/commands/lazy.rb#47
  def call(*_args); end

  # Combine with other lazy commands
  #
  # @api public
  # @return [Graph]
  # @see Abstract#combine
  #
  # source://rom-core//lib/rom/commands/lazy.rb#69
  def combine(*others); end

  # @api private
  # @attr_reader command [Command] The wrapped command
  #
  # source://rom-core//lib/rom/commands/lazy.rb#15
  def command; end

  # @api private
  #
  # source://rom-core//lib/rom/commands/lazy.rb#22
  def command_proc; end

  # @api private
  # @attr_reader evaluator [Proc] The proc that will evaluate the input
  #
  # source://rom-core//lib/rom/commands/lazy.rb#20
  def evaluator; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/commands/lazy.rb#74
  def lazy?; end

  # @api private
  # @attr_reader command [Command] The wrapped command
  #
  # source://rom-core//lib/rom/commands/lazy.rb#15
  def unwrap; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/commands/lazy.rb#86
  def method_missing(name, *args, **_arg2, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/commands/lazy.rb#79
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/commands/lazy.rb#25
    def [](command); end
  end
end

# Lazy command wrapper for create commands
#
# @api public
#
# source://rom-core//lib/rom/commands/lazy/create.rb#9
class ROM::Commands::Lazy::Create < ::ROM::Commands::Lazy
  # Execute a command
  #
  # @api public
  # @return [Hash, Array<Hash>]
  # @see Command::Create#call
  #
  # source://rom-core//lib/rom/commands/lazy/create.rb#17
  def call(*args); end
end

# Lazy command wrapper for delete commands
#
# @api public
#
# source://rom-core//lib/rom/commands/lazy/delete.rb#9
class ROM::Commands::Lazy::Delete < ::ROM::Commands::Lazy
  # Execute a lazy delete command
  #
  # @api public
  # @return [Hash, Array<Hash>]
  # @see Commands::Delete#call
  #
  # source://rom-core//lib/rom/commands/lazy/delete.rb#17
  def call(*args); end
end

# Lazy command wrapper for update commands
#
# @api public
#
# source://rom-core//lib/rom/commands/lazy/update.rb#9
class ROM::Commands::Lazy::Update < ::ROM::Commands::Lazy
  # Execute a lazy update command
  #
  # @api public
  # @return [Hash, Array<Hash>]
  # @see Commands::Update#call
  #
  # source://rom-core//lib/rom/commands/lazy/update.rb#17
  def call(*args); end
end

# Update command
#
# This command updates all tuples in its relation with new attributes
#
# @abstract
#
# source://rom-core//lib/rom/commands/update.rb#12
class ROM::Commands::Update < ::ROM::Command; end

# This extension is only used for environment objects to configure arbitrary options, each
# adapter can use them according to what they need.
#
# @api private
#
# source://rom-core//lib/rom/support/configurable.rb#8
module ROM::Configurable
  # Return config instance
  #
  # @api private
  # @return [Config]
  #
  # source://rom-core//lib/rom/support/configurable.rb#86
  def config; end

  # Yield config instance
  #
  # @api public
  # @return [self]
  # @yield [config]
  #
  # source://rom-core//lib/rom/support/configurable.rb#95
  def configure; end
end

# @api private
#
# source://rom-core//lib/rom/support/configurable.rb#9
class ROM::Configurable::Config
  # @api private
  # @return [Config] a new instance of Config
  #
  # source://rom-core//lib/rom/support/configurable.rb#17
  def initialize(settings = T.unsafe(nil)); end

  # Return a setting
  #
  # @api public
  # @return [Mixed]
  #
  # source://rom-core//lib/rom/support/configurable.rb#26
  def [](name); end

  # @api private
  #
  # source://rom-core//lib/rom/support/configurable.rb#45
  def dup; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/configurable.rb#31
  def key?(name); end

  # @api private
  #
  # source://rom-core//lib/rom/support/configurable.rb#14
  def settings; end

  # @api private
  #
  # source://rom-core//lib/rom/support/configurable.rb#35
  def to_hash; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/support/configurable.rb#51
  def dup_settings(settings); end

  # @api private
  #
  # source://rom-core//lib/rom/support/configurable.rb#62
  def method_missing(meth, *args, &_block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/configurable.rb#40
  def respond_to_missing?(_name, _include_private = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/configurable.rb#76
  def writer?(name); end
end

# @api private
#
# source://rom-core//lib/rom/support/configurable.rb#10
ROM::Configurable::Config::WRITER_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rom-core//lib/rom/configuration.rb#11
class ROM::Configuration
  include ::ROM::ConfigurationDSL
  extend ::Forwardable
  extend ::ROM::Notifications

  # Initialize a new configuration
  #
  # @api private
  # @return [Configuration]
  # @see Environment#initialize
  #
  # source://rom-core//lib/rom/configuration.rb#52
  def initialize(*args, &block); end

  # Return gateway identified by name
  #
  # @api private
  # @return [Gateway]
  #
  # source://rom-core//lib/rom/configuration.rb#85
  def [](name); end

  # @api private
  #
  # source://rom-core//lib/rom/configuration.rb#102
  def adapter_for_gateway(gateway); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def auto_registration(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def command_classes(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def configure(*args, **_arg1, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/configuration.rb#119
  def default_adapter; end

  # @api private
  #
  # source://rom-core//lib/rom/configuration.rb#97
  def default_gateway; end

  # Returns the value of attribute environment.
  #
  # source://rom-core//lib/rom/configuration.rb#29
  def environment; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def gateways(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def gateways_map(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def mapper_classes(*args, **_arg1, &block); end

  # Returns the value of attribute notifications.
  #
  # source://rom-core//lib/rom/configuration.rb#37
  def notifications; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register_command(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register_mapper(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register_plugin(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register_relation(*args, **_arg1, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/configuration.rb#109
  def relation_classes(gateway = T.unsafe(nil)); end

  # Hook for respond_to? used internally
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/configuration.rb#92
  def respond_to?(name, include_all = T.unsafe(nil)); end

  # Returns the value of attribute setup.
  #
  # source://rom-core//lib/rom/configuration.rb#33
  def setup; end

  # Apply a plugin to the configuration
  #
  # @api public
  # @param plugin [Mixed] The plugin identifier, usually a Symbol
  # @param options [Hash] Plugin options
  # @return [Configuration]
  #
  # source://rom-core//lib/rom/configuration.rb#68
  def use(plugin, options = T.unsafe(nil)); end

  private

  # Returns gateway if method is a name of a registered gateway
  #
  # @api private
  # @return [Gateway]
  #
  # source://rom-core//lib/rom/configuration.rb#130
  def method_missing(name, *_arg1); end
end

# source://rom-core//lib/rom/configuration.rb#25
class ROM::Configuration::NoDefaultAdapterError < ::StandardError; end

# This extends Configuration class with the DSL methods
#
# @api public
#
# source://rom-core//lib/rom/configuration_dsl/relation.rb#6
module ROM::ConfigurationDSL
  # Command definition DSL
  #
  # @api public
  # @example
  #   setup.commands(:users) do
  #   define(:create) do
  #   input NewUserParams
  #   result :one
  #   end
  #
  #   define(:update) do
  #   input UserParams
  #   result :many
  #   end
  #
  #   define(:delete) do
  #   result :many
  #   end
  #   end
  #
  # source://rom-core//lib/rom/configuration_dsl.rb#51
  def commands(name, &block); end

  # Mapper definition DSL
  #
  # @api public
  #
  # source://rom-core//lib/rom/configuration_dsl.rb#58
  def mappers(&block); end

  # Configures a plugin for a specific adapter to be enabled for all relations
  #
  # @api public
  # @example
  #   config = ROM::Configuration.new(:sql, 'sqlite::memory')
  #
  #   config.plugin(:sql, relations: :instrumentation) do |p|
  #   p.notifications = MyNotificationsBackend
  #   end
  #
  #   config.plugin(:sql, relations: :pagination)
  # @param adapter [Symbol] The adapter identifier
  # @param spec [Hash<Symbol=>Symbol>] Component identifier => plugin identifier
  # @return [Plugin]
  #
  # source://rom-core//lib/rom/configuration_dsl.rb#79
  def plugin(adapter, spec, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/configuration_dsl.rb#93
  def plugin_registry; end

  # Relation definition DSL
  #
  # @api public
  # @example
  #   setup.relation(:users) do
  #   def names
  #   project(:name)
  #   end
  #   end
  #
  # source://rom-core//lib/rom/configuration_dsl.rb#22
  def relation(name, options = T.unsafe(nil), &block); end
end

# Setup DSL-specific command extensions
#
# @private
#
# source://rom-core//lib/rom/configuration_dsl/command.rb#10
class ROM::ConfigurationDSL::Command
  class << self
    # Generate a command subclass
    #
    # This is used by Setup#commands DSL and its `define` block
    #
    # @api private
    #
    # source://rom-core//lib/rom/configuration_dsl/command.rb#16
    def build_class(name, relation, options = T.unsafe(nil), &block); end

    # Create a command subclass name based on adapter, type and relation
    #
    # @api private
    #
    # source://rom-core//lib/rom/configuration_dsl/command.rb#33
    def generate_class_name(adapter, command_type, relation); end
  end
end

# Command `define` DSL used by Setup#commands
#
# @private
#
# source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#10
class ROM::ConfigurationDSL::CommandDSL
  # @api private
  # @return [CommandDSL] a new instance of CommandDSL
  #
  # source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#14
  def initialize(relation, adapter = T.unsafe(nil), &block); end

  # Returns the value of attribute adapter.
  #
  # source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#11
  def adapter; end

  # Returns the value of attribute command_classes.
  #
  # source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#11
  def command_classes; end

  # Define a command class
  #
  # @api public
  # @option options
  # @param name [Symbol] of the command
  # @param options [Hash]
  # @return [Class] generated class
  #
  # source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#30
  def define(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute relation.
  #
  # source://rom-core//lib/rom/configuration_dsl/command_dsl.rb#11
  def relation; end
end

# Mapper definition DSL used by Setup DSL
#
# @private
#
# source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#10
class ROM::ConfigurationDSL::MapperDSL
  # @api private
  # @return [MapperDSL] a new instance of MapperDSL
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#14
  def initialize(configuration, mapper_classes, block); end

  # Returns the value of attribute configuration.
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#11
  def configuration; end

  # Define a mapper class
  #
  # @api public
  # @param name [Symbol] of the mapper
  # @param options [Hash]
  # @return [Class]
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#32
  def define(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute defined_mappers.
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#11
  def defined_mappers; end

  # Returns the value of attribute mapper_classes.
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#11
  def mapper_classes; end

  # TODO
  #
  # @api public
  #
  # source://rom-core//lib/rom/configuration_dsl/mapper_dsl.rb#40
  def register(relation, mappers); end
end

# Setup DSL-specific relation extensions
#
# @private
#
# source://rom-core//lib/rom/configuration_dsl/relation.rb#10
class ROM::ConfigurationDSL::Relation
  class << self
    # Generate a relation subclass
    #
    # This is used by Setup#relation DSL
    #
    # @api private
    #
    # source://rom-core//lib/rom/configuration_dsl/relation.rb#16
    def build_class(name, options = T.unsafe(nil)); end
  end
end

# ROM container is an isolated environment with no global state where all
# components are registered. Container objects provide access to your
# relations, commands and mappers. ROM containers are usually configured and
# handled via framework integrations, although it is easy to use them
# standalone.
#
# There are 3 types of container setup:
#
# * Setup DSL - a simple block-based configuration which allows configuring
#   all components and gives you back a container instance. This type is suitable
#   for small scripts, or in some cases rake tasks
# * Explicit setup - this type requires creating a configuration object,
#   registering component classes (ie relation classes) and passing the config
#   to container builder function. This type is suitable when your environment
#   is not typical and you need full control over component registration
# * Explicit setup with auto-registration - same as explicit setup but allows
#   you to configure auto-registration mechanism which will register component
#   classes for you, based on dir/file naming conventions. This is the most
#   common type of setup that's used by framework integrations
#
# @api public
# @example in-line setup
#   rom = ROM.container(:sql, 'sqlite::memory') do |config|
#   config.default.create_table :users do
#   primary_key :id
#   column :name, String, null: false
#   end
#
#   config.relation(:users) do
#   schema(infer: true)
#
#   def by_name(name)
#   where(name: name)
#   end
#   end
#   end
#
#   rom.relations[:users].insert(name: "Jane")
#
#   rom.relations[:users].by_name("Jane").to_a
#   # [{:id=>1, :name=>"Jane"}]
# @example multi-step setup with explicit component classes
#   config = ROM::Configuration.new(:sql, 'sqlite::memory')
#
#   config.default.create_table :users do
#   primary_key :id
#   column :name, String, null: false
#   end
#
#   class Users < ROM::Relation[:sql]
#   schema(:users, infer: true)
#
#   def by_name(name)
#   where(name: name)
#   end
#   end
#
#   config.register_relation(Users)
#
#   rom = ROM.container(config)
#
#   rom.relations[:users].insert(name: "Jane")
#
#   rom.relations[:users].by_name("Jane").to_a
#   # [{:id=>1, :name=>"Jane"}]
# @example multi-step setup with auto-registration
#   config = ROM::Configuration.new(:sql, 'sqlite::memory')
#   config.auto_registration('./persistence', namespace: false)
#
#   config.default.create_table :users do
#   primary_key :id
#   column :name, String, null: false
#   end
#
#   # ./persistence/relations/users.rb
#   class Users < ROM::Relation[:sql]
#   schema(infer: true)
#
#   def by_name(name)
#   where(name: name)
#   end
#   end
#
#   rom = ROM.container(config)
#
#   rom.relations[:users].insert(name: "Jane")
#
#   rom.relations[:users].by_name("Jane").to_a
#   # [{:id=>1, :name=>"Jane"}]
#
# source://rom-core//lib/rom/container.rb#99
class ROM::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # Return command registry
  #
  # @api public
  # @return [Hash<Symbol=>CommandRegistry]] Hash<Symbol=>CommandRegistry]
  #
  # source://rom-core//lib/rom/container.rb#145
  def commands; end

  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#83
  def config; end

  # Disconnect all gateways
  #
  # @api public
  # @example
  #   rom = ROM.container(:sql, 'sqlite://my_db.sqlite')
  #   rom.relations[:users].insert(name: "Jane")
  #   rom.disconnect
  # @return [Hash<Symbol=>Gateway>] a hash with disconnected gateways
  #
  # source://rom-core//lib/rom/container.rb#159
  def disconnect; end

  # Return registered gateways
  #
  # @api public
  # @return [Hash<Symbol=>Gateway>]
  #
  # source://rom-core//lib/rom/container.rb#118
  def gateways; end

  # Return mapper registry for all relations
  #
  # @api public
  # @return [Hash<Symbol=>MapperRegistry]] Hash<Symbol=>MapperRegistry]
  #
  # source://rom-core//lib/rom/container.rb#127
  def mappers; end

  # Return relation registry
  #
  # @api public
  # @return [RelationRegistry]
  #
  # source://rom-core//lib/rom/container.rb#136
  def relations; end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/container.rb#104
    def new(gateways, relations, mappers, commands); end
  end
end

# @api private
#
# source://rom-core//lib/rom/create_container.rb#10
class ROM::CreateContainer
  # @api private
  # @return [CreateContainer] a new instance of CreateContainer
  #
  # source://rom-core//lib/rom/create_container.rb#15
  def initialize(environment, setup); end

  # @api private
  #
  # source://rom-core//lib/rom/create_container.rb#12
  def container; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/create_container.rb#22
  def finalize(environment, setup); end
end

# source://rom-core//lib/rom/constants.rb#78
class ROM::DuplicateConfigurationError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#79
class ROM::DuplicateContainerError < ::StandardError; end

# Exception raised when an element inside a component registry is not found
#
# source://rom-core//lib/rom/constants.rb#43
class ROM::ElementNotFoundError < ::KeyError
  # @api private
  # @return [ElementNotFoundError] a new instance of ElementNotFoundError
  #
  # source://rom-core//lib/rom/constants.rb#45
  def initialize(key, registry); end

  # @api private
  #
  # source://rom-core//lib/rom/constants.rb#50
  def set_message(key, registry); end
end

# source://rom-core//lib/rom/constants.rb#20
class ROM::EnvAlreadyFinalizedError < ::StandardError; end

# Core gateway configuration interface
#
# @api private
#
# source://rom-core//lib/rom/environment.rb#10
class ROM::Environment
  include ::ROM::Configurable

  # @api private
  # @return [Environment] a new instance of Environment
  #
  # source://rom-core//lib/rom/environment.rb#16
  def initialize(*args); end

  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#13
  def gateways; end

  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#13
  def gateways_map; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#26
  def configure_gateways(*args); end

  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#65
  def load_config(config, hash); end

  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#39
  def normalize_gateway_args(*args); end

  # Build gateways using the setup interface
  #
  # @api private
  #
  # source://rom-core//lib/rom/environment.rb#46
  def normalize_gateways(gateways_config); end
end

# This giant builds an container using defined classes for core parts of ROM
#
# It is used by the setup object after it's done gathering class definitions
#
# @private
#
# source://rom-core//lib/rom/setup/finalize/finalize_commands.rb#8
class ROM::Finalize
  # @api private
  # @return [Finalize] a new instance of Finalize
  #
  # source://rom-core//lib/rom/setup/finalize.rb#30
  def initialize(options); end

  # Return adapter identifier for a given gateway object
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/setup/finalize.rb#51
  def adapter_for(gateway); end

  # Returns the value of attribute command_classes.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def command_classes; end

  # Returns the value of attribute config.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def config; end

  # Returns the value of attribute gateways.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def gateways; end

  # Returns the value of attribute mapper_classes.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def mapper_classes; end

  # Returns the value of attribute mapper_objects.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def mapper_objects; end

  # Returns the value of attribute notifications.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def notifications; end

  # Returns the value of attribute plugins.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def plugins; end

  # Returns the value of attribute relation_classes.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def relation_classes; end

  # Returns the value of attribute repo_adapter.
  #
  # source://rom-core//lib/rom/setup/finalize.rb#25
  def repo_adapter; end

  # Run the finalization process
  #
  # This creates relations, mappers and commands
  #
  # @api private
  # @return [Container]
  #
  # source://rom-core//lib/rom/setup/finalize.rb#62
  def run!; end

  private

  # Build entire command registries
  #
  # This includes both classes created via DSL and explicit definitions
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize.rb#101
  def load_commands(relations); end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize.rb#92
  def load_mappers; end

  # Build entire relation registry from all known relation subclasses
  #
  # This includes both classes created via DSL and explicit definitions
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize.rb#79
  def load_relations(mappers); end
end

# source://rom-core//lib/rom/setup/finalize/finalize_commands.rb#9
class ROM::Finalize::FinalizeCommands
  # Build command registry hash for provided relations
  #
  # @api private
  # @param relations [RelationRegistry] registry
  # @param gateways [Hash]
  # @param command_classes [Array] a list of command subclasses
  # @return [FinalizeCommands] a new instance of FinalizeCommands
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_commands.rb#19
  def initialize(relations, gateways, command_classes, notifications); end

  # Returns the value of attribute notifications.
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_commands.rb#10
  def notifications; end

  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_commands.rb#29
  def run!; end
end

# source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#7
class ROM::Finalize::FinalizeMappers
  # @api private
  # @return [FinalizeMappers] a new instance of FinalizeMappers
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#11
  def initialize(mapper_classes, mapper_objects); end

  # Returns the value of attribute mapper_classes.
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#8
  def mapper_classes; end

  # Returns the value of attribute mapper_objects.
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#8
  def mapper_objects; end

  # Returns the value of attribute registry_hash.
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#8
  def registry_hash; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#24
  def run!; end

  private

  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#55
  def build_mappers(relation_name); end

  # source://rom-core//lib/rom/setup/finalize/finalize_mappers.rb#42
  def check_duplicate_registered_mappers; end
end

# source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#9
class ROM::Finalize::FinalizeRelations
  # Build relation registry of specified descendant classes
  #
  # This is used by the setup
  #
  # @api private
  # @param gateways [Hash]
  # @param relation_classes [Array] a list of relation descendants
  # @return [FinalizeRelations] a new instance of FinalizeRelations
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#20
  def initialize(gateways, relation_classes, notifications:, mappers: T.unsafe(nil), plugins: T.unsafe(nil)); end

  # @api private
  # @return [ROM::Relation]
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#71
  def build_relation(klass, registry); end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#112
  def mapper_registry(rel_key, rel_class); end

  # Returns the value of attribute notifications.
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#10
  def notifications; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#123
  def plugin_options; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#138
  def relation_names; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#128
  def relation_plugins; end

  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#31
  def run!; end

  # @api private
  #
  # source://rom-core//lib/rom/setup/finalize/finalize_relations.rb#133
  def schema_plugins; end
end

# Abstract gateway class
#
# Every adapter needs to inherit from this class and implement
# required interface
#
# @abstract
# @api public
#
# source://rom-core//lib/rom/gateway.rb#15
class ROM::Gateway
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Notifications::Listener

  # Returns the adapter, defined for the class
  #
  # @api public
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/gateway.rb#133
  def adapter; end

  # @api public
  #
  # source://rom-core//lib/rom/gateway.rb#37
  def connection; end

  # Disconnect is optional and it's a no-op by default
  #
  # @api public
  #
  # source://rom-core//lib/rom/gateway.rb#166
  def disconnect; end

  # A generic interface for returning default logger
  #
  # Adapters should implement this method as handling loggers is different
  # across adapters. This is a no-op by default and returns nil.
  #
  # @api public
  # @return [NilClass]
  #
  # source://rom-core//lib/rom/gateway.rb#159
  def logger; end

  # Runs a block inside a transaction. The underlying transaction engine
  # is adapter-specific
  #
  # @api public
  # @param opts [Hash] Transaction options
  # @return The result of yielding the block or +nil+ if
  #   the transaction was rolled back
  #
  # source://rom-core//lib/rom/gateway.rb#179
  def transaction(opts = T.unsafe(nil), &block); end

  # A generic interface for setting up a logger
  #
  # This is not a required interface, it's a no-op by default
  #
  # @abstract
  # @api public
  #
  # source://rom-core//lib/rom/gateway.rb#147
  def use_logger(*_arg0); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/gateway.rb#186
  def transaction_runner(_); end

  class << self
    # Get gateway subclass for a specific adapter
    #
    # @api private
    # @param type [Symbol] Adapter identifier
    # @return [Class]
    #
    # source://rom-core//lib/rom/gateway.rb#114
    def class_from_symbol(type); end

    # Set up a gateway
    #
    # @api public
    # @overload setup
    # @overload setup
    # @return [Gateway] a specific gateway subclass
    #
    # source://rom-core//lib/rom/gateway.rb#81
    def setup(gateway_or_scheme, *args, **_arg2); end
  end
end

# Globally accessible public interface exposed via ROM module
#
# @api public
#
# source://rom-core//lib/rom/global/plugin_dsl.rb#4
module ROM::Global
  # An internal adapter identifier => adapter module map used by setup
  #
  # @api private
  # @return [Hash<Symbol=>Module>]
  #
  # source://rom-core//lib/rom/global.rb#26
  def adapters; end

  # An internal identifier => plugin map used by the setup
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/global.rb#33
  def plugin_registry; end

  # Global plugin setup DSL
  #
  # @api public
  # @example
  #   ROM.plugins do
  #   register :publisher, Plugin::Publisher, type: :command
  #   end
  #
  # source://rom-core//lib/rom/global.rb#43
  def plugins(*args, &block); end

  # Register adapter namespace under a specified identifier
  #
  # @api private
  # @param identifier [Symbol]
  # @param adapter [Class, Module]
  # @return [self]
  #
  # source://rom-core//lib/rom/global.rb#55
  def register_adapter(identifier, adapter); end

  class << self
    # Set base global registries in ROM constant
    #
    # @api private
    #
    # source://rom-core//lib/rom/global.rb#14
    def extended(rom); end
  end
end

# plugin registration DSL
#
# @private
#
# source://rom-core//lib/rom/global/plugin_dsl.rb#8
class ROM::Global::PluginDSL
  # @api private
  # @return [PluginDSL] a new instance of PluginDSL
  #
  # source://rom-core//lib/rom/global/plugin_dsl.rb#24
  def initialize(registry, defaults = T.unsafe(nil), &block); end

  # Register plugins for a specific adapter
  #
  # @api public
  # @param type [Symbol] The adapter identifier
  #
  # source://rom-core//lib/rom/global/plugin_dsl.rb#46
  def adapter(type, &block); end

  # Default options passed to plugin registration
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/global/plugin_dsl.rb#14
  def defaults; end

  # Register a plugin
  #
  # @api public
  # @param name [Symbol] of the plugin
  # @param mod [Module] to include
  # @param options [Hash]
  #
  # source://rom-core//lib/rom/global/plugin_dsl.rb#37
  def register(name, mod, options = T.unsafe(nil)); end

  # Plugin registry
  #
  # @api private
  # @return [PluginRegistry]
  #
  # source://rom-core//lib/rom/global/plugin_dsl.rb#21
  def registry; end
end

# Header provides information about data mapping of a specific relation
#
# Processors use headers to build objects that process raw relations that go
# through mappers.
#
# @private
#
# source://rom-core//lib/rom/header/attribute.rb#4
class ROM::Header
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Header] a new instance of Header
  #
  # source://rom-core//lib/rom/header.rb#66
  def initialize(attributes, options = T.unsafe(nil)); end

  # Return attribute identified by its name
  #
  # @api private
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/header.rb#108
  def [](name); end

  # Return if there are any aliased attributes
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/header.rb#90
  def aliased?; end

  # @api private
  #
  # source://rom-core//lib/rom/header.rb#28
  def attributes; end

  # Return all Combined attributes
  #
  # @api private
  # @return [Array<Combined>]
  #
  # source://rom-core//lib/rom/header.rb#117
  def combined; end

  # @api private
  #
  # source://rom-core//lib/rom/header.rb#25
  def copy_keys; end

  # Iterate over attributes
  #
  # @api private
  # @yield [Attribute]
  #
  # source://rom-core//lib/rom/header.rb#83
  def each; end

  # Return attribute keys
  #
  # An attribute key corresponds to tuple attribute names
  #
  # @api private
  #
  # source://rom-core//lib/rom/header.rb#99
  def keys; end

  # @api private
  # @return [Hash] attribute key/name mapping for all primitive attributes
  #
  # source://rom-core//lib/rom/header.rb#33
  def mapping; end

  # @api private
  # @return [Class] optional model associated with a header
  #
  # source://rom-core//lib/rom/header.rb#19
  def model; end

  # Return all non-primitive attributes that don't require mapping
  #
  # @api private
  # @return [Array<Group,Fold,Ungroup,Unfold,Wrap,Unwrap>]
  #
  # source://rom-core//lib/rom/header.rb#153
  def non_primitives; end

  # @api private
  # @return [Array] all attribute names that are popping from a tuple
  #
  # source://rom-core//lib/rom/header.rb#43
  def pop_keys; end

  # Returns all attributes that require postprocessing
  #
  # @api private
  # @return [Array<Ungroup,Unfold>]
  #
  # source://rom-core//lib/rom/header.rb#135
  def postprocessed; end

  # Returns all attributes that require preprocessing
  #
  # @api private
  # @return [Array<Group,Fold>]
  #
  # source://rom-core//lib/rom/header.rb#126
  def preprocessed; end

  # Return all primitive attributes that require mapping
  #
  # @api private
  # @return [Array<Attribute>]
  #
  # source://rom-core//lib/rom/header.rb#162
  def primitives; end

  # @api private
  #
  # source://rom-core//lib/rom/header.rb#22
  def reject_keys; end

  # @api private
  # @return [Array] all attribute keys that are in a tuple
  #
  # source://rom-core//lib/rom/header.rb#38
  def tuple_keys; end

  # Return all Wrap attributes
  #
  # @api private
  # @return [Array<Wrap>]
  #
  # source://rom-core//lib/rom/header.rb#144
  def wraps; end

  private

  # Find all attribute matching specific attribute class (not kind)
  #
  # @api private
  # @return [Array<Attribute>]
  #
  # source://rom-core//lib/rom/header.rb#173
  def by_type(*types); end

  # Set mapping hash from primitive attributes
  #
  # @api private
  #
  # source://rom-core//lib/rom/header.rb#180
  def initialize_mapping; end

  # Set all tuple keys from all attributes popping from Unwrap and Ungroup
  #
  # @api private
  #
  # source://rom-core//lib/rom/header.rb#194
  def initialize_pop_keys; end

  # Set all tuple keys from all attributes going deep into Wrap and Group too
  #
  # @api private
  #
  # source://rom-core//lib/rom/header.rb#187
  def initialize_tuple_keys; end

  class << self
    # Coerce array with attribute definitions into a header object
    #
    # @api private
    # @param input [Array<Array>] attribute name/option pairs
    # @param options [Hash]
    # @return [Header]
    #
    # source://rom-core//lib/rom/header.rb#53
    def coerce(input, options = T.unsafe(nil)); end
  end
end

# Array is an embedded attribute type
#
# source://rom-core//lib/rom/header/attribute.rb#136
class ROM::Header::Array < ::ROM::Header::Embedded; end

# An attribute provides information about a specific attribute in a tuple
#
# This may include information about how an attribute should be renamed,
# or how its value should coerced.
#
# More complex attributes describe how an attribute should be transformed.
#
# @private
#
# source://rom-core//lib/rom/header/attribute.rb#13
class ROM::Header::Attribute
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Attribute] a new instance of Attribute
  #
  # source://rom-core//lib/rom/header/attribute.rb#67
  def initialize(name, meta); end

  # Return if an attribute should be aliased
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/header/attribute.rb#84
  def aliased?; end

  # @api private
  # @return [Symbol] key of an attribute that corresponds to tuple attribute
  #
  # source://rom-core//lib/rom/header/attribute.rb#24
  def key; end

  # Return :key-to-:name mapping hash
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/header/attribute.rb#93
  def mapping; end

  # @api private
  # @return [Hash] additional meta information
  #
  # source://rom-core//lib/rom/header/attribute.rb#34
  def meta; end

  # @api private
  # @return [Symbol] name of an attribute
  #
  # source://rom-core//lib/rom/header/attribute.rb#19
  def name; end

  # @api private
  # @return [Symbol] type identifier (defaults to :object)
  #
  # source://rom-core//lib/rom/header/attribute.rb#29
  def type; end

  # Return if an attribute has a specific type identifier
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/header/attribute.rb#77
  def typed?; end

  # @return [Boolean]
  #
  # source://rom-core//lib/rom/header/attribute.rb#97
  def union?; end

  class << self
    # Return attribute class for a given meta hash
    #
    # @api private
    # @param meta [Hash] hash with type information and optional transformation info
    # @return [Class]
    #
    # source://rom-core//lib/rom/header/attribute.rb#43
    def [](meta); end

    # Coerce an array with attribute meta-data into an attribute object
    #
    # @api private
    # @param input [Array<Symbol,Hash>] attribute name/options pair
    # @return [Attribute]
    #
    # source://rom-core//lib/rom/header/attribute.rb#55
    def coerce(input); end
  end
end

# Combined is an embedded attribute type describing combination of multiple
# relations
#
# source://rom-core//lib/rom/header/attribute.rb#143
class ROM::Header::Combined < ::ROM::Header::Embedded; end

# Embedded attribute is a special attribute type that has a header
#
# This is the base of complex attributes like Hash or Group
#
# @private
#
# source://rom-core//lib/rom/header/attribute.rb#107
class ROM::Header::Embedded < ::ROM::Header::Attribute
  # @api private
  # @return [Embedded] a new instance of Embedded
  #
  # source://rom-core//lib/rom/header/attribute.rb#116
  def initialize(*_arg0); end

  # return [Header] header of an attribute
  #
  # @api private
  #
  # source://rom-core//lib/rom/header/attribute.rb#113
  def header; end

  # source://rom-core//lib/rom/header/attribute.rb#130
  def pop_keys; end

  # Return tuple keys from the header
  #
  # @api private
  # @return [Array<Symbol>]
  #
  # source://rom-core//lib/rom/header/attribute.rb#126
  def tuple_keys; end
end

# Exclude is a special type of Attribute to be removed
#
# source://rom-core//lib/rom/header/attribute.rb#170
class ROM::Header::Exclude < ::ROM::Header::Attribute; end

# Fold is a special type of Array attribute that requires folding
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#163
class ROM::Header::Fold < ::ROM::Header::Array; end

# Group is a special type of Array attribute that requires grouping
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#155
class ROM::Header::Group < ::ROM::Header::Array; end

# Hash is an embedded attribute type
#
# source://rom-core//lib/rom/header/attribute.rb#139
class ROM::Header::Hash < ::ROM::Header::Embedded; end

# TYPE_MAP is a (hash) map of ROM::Header identifiers to ROM::Header types
#
# @private
#
# source://rom-core//lib/rom/header/attribute.rb#175
ROM::Header::TYPE_MAP = T.let(T.unsafe(nil), Hash)

# Unfold is a special type of Array attribute that requires unfolding
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#167
class ROM::Header::Unfold < ::ROM::Header::Array; end

# Ungroup is a special type of Array attribute that requires ungrouping
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#159
class ROM::Header::Ungroup < ::ROM::Header::Array; end

# Unwrap is a special type of Hash attribute that requires unwrapping
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#151
class ROM::Header::Unwrap < ::ROM::Header::Hash; end

# Wrap is a special type of Hash attribute that requires wrapping
# transformation
#
# source://rom-core//lib/rom/header/attribute.rb#147
class ROM::Header::Wrap < ::ROM::Header::Hash; end

# source://rom-core//lib/rom/support/inflector.rb#4
ROM::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# @api private
#
# source://rom-core//lib/rom/initializer.rb#7
module ROM::Initializer
  class << self
    # @api private
    # @private
    #
    # source://rom-core//lib/rom/initializer.rb#49
    def extended(base); end
  end
end

# @api private
#
# source://rom-core//lib/rom/initializer.rb#9
module ROM::Initializer::DefineWithHook
  # @api private
  #
  # source://rom-core//lib/rom/initializer.rb#25
  def __define_with__; end

  # @api private
  #
  # source://rom-core//lib/rom/initializer.rb#17
  def option(*_arg0, **_arg1); end

  # @api private
  #
  # source://rom-core//lib/rom/initializer.rb#11
  def param(*_arg0, **_arg1); end
end

# @api private
#
# source://rom-core//lib/rom/initializer.rb#56
module ROM::Initializer::InstanceMethods
  def class; end

  # This makes sure we memoize options before an object becomes frozen
  #
  # @api public
  #
  # source://rom-core//lib/rom/initializer.rb#74
  def freeze; end

  def instance_variable_get(_arg0); end

  # Instance options
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-core//lib/rom/initializer.rb#62
  def options; end
end

# @api private
#
# source://rom-core//lib/rom/create_container.rb#45
class ROM::InlineCreateContainer < ::ROM::CreateContainer
  # @api private
  # @return [InlineCreateContainer] a new instance of InlineCreateContainer
  #
  # source://rom-core//lib/rom/create_container.rb#47
  def initialize(*args, &block); end
end

# source://rom-core//lib/rom/constants.rb#82
class ROM::InvalidOptionKeyError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#81
class ROM::InvalidOptionValueError < ::StandardError; end

# Exception raised when a reserved keyword is used as a relation name
#
# source://rom-core//lib/rom/constants.rb#25
class ROM::InvalidRelationName < ::StandardError
  # @api private
  # @return [InvalidRelationName] a new instance of InvalidRelationName
  #
  # source://rom-core//lib/rom/constants.rb#37
  def initialize(relation); end
end

# source://rom-core//lib/rom/constants.rb#27
class ROM::KeyMissing < ::ROM::CommandError; end

# Mapper is a simple object that uses transformers to load relations
#
# @private
#
# source://rom-core//lib/rom/mapper/model_dsl.rb#6
class ROM::Mapper
  include ::ROM::Mapper::DSL
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Mapper::DSL::ClassMethods

  # @api private
  # @return [Mapper] a new instance of Mapper
  #
  # source://rom-core//lib/rom/mapper.rb#78
  def initialize(header, processor = T.unsafe(nil)); end

  # Process a relation using the transformers
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper.rb#96
  def call(relation); end

  # @api private
  # @return [Header] header that was used to build the transformers
  #
  # source://rom-core//lib/rom/mapper.rb#29
  def header; end

  # @api private
  # @return [Class] optional model that is instantiated by a mapper
  #
  # source://rom-core//lib/rom/mapper.rb#89
  def model; end

  # @api private
  # @return [Object] transformers object built by a processor
  #
  # source://rom-core//lib/rom/mapper.rb#24
  def transformers; end

  class << self
    # Build a mapper using provided processor type
    #
    # @api private
    # @return [Mapper]
    #
    # source://rom-core//lib/rom/mapper.rb#65
    def build(header = T.unsafe(nil), processor = T.unsafe(nil)); end

    # Prepares an array of headers for a potentially multistep mapper
    #
    # @api private
    # @raise [MapperMisconfiguredError]
    # @return [Array<Header>]
    #
    # source://rom-core//lib/rom/mapper.rb#53
    def headers(header); end

    # @api private
    # @return [Hash] registered processors
    #
    # source://rom-core//lib/rom/mapper.rb#34
    def processors; end

    # Register a processor class
    #
    # @api private
    # @return [Hash]
    #
    # source://rom-core//lib/rom/mapper.rb#43
    def register_processor(processor); end

    # @api private
    #
    # source://rom-core//lib/rom/mapper.rb#70
    def registry(descendants); end
  end
end

# Mapper attribute DSL exposed by mapper subclasses
#
# This class is private even though its methods are exposed by mappers.
# Typically it's not meant to be used directly.
#
# TODO: break this madness down into smaller pieces
#
# @api private
#
# source://rom-core//lib/rom/mapper/attribute_dsl.rb#16
class ROM::Mapper::AttributeDSL
  include ::ROM::Mapper::ModelDSL

  # @api private
  # @param attributes [Array] accumulator array
  # @param options [Hash]
  # @return [AttributeDSL] a new instance of AttributeDSL
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#25
  def initialize(attributes, options); end

  # Define a mapping attribute with its options and/or block
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.attribute(:name)
  #   dsl.attribute(:email, from: 'user_email')
  #   dsl.attribute(:name) { 'John' }
  #   dsl.attribute(:name) { |t| t.upcase }
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#79
  def attribute(name, options = T.unsafe(nil), &block); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def attributes; end

  # Define an embedded combined attribute that requires "combine" transformation
  #
  # Typically this can be used to process results of eager-loading
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.combine(:tags, user_id: :id) do
  #   model Tag
  #
  #   attribute :name
  #   end
  # @param name [Symbol]
  # @param options [Hash] @option options [Hash] :on The "join keys"
  #   @option options [Symbol] :type The type, either :array (default) or :hash
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#333
  def combine(name, options, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def copy_keys; end

  # Define an embedded attribute
  #
  # Block exposes the attribute dsl too
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.embedded :tags, type: :array do
  #   attribute :name
  #   end
  #
  #   dsl.embedded :address, type: :hash do
  #   model Address
  #   attribute :name
  #   end
  # @option options
  # @option options
  # @param name [Symbol] attribute
  # @param options [Hash]
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#132
  def embedded(name, options, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#90
  def exclude(name); end

  # Define an embedded hash attribute that requires "fold" transformation
  #
  # Typically this is used in sql context to fold single joined field
  # to the array of values.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.fold(tags: [:name])
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#277
  def fold(*args, &block); end

  # Define an embedded hash attribute that requires "grouping" transformation
  #
  # Typically this is used in sql context when relation is a join.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.group(tags: [:name])
  #
  #   dsl.group(:tags) do
  #   model Tag
  #   attribute :name
  #   end
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#232
  def group(*args, &block); end

  # Generate a header from attribute definitions
  #
  # @api private
  # @return [Header]
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#351
  def header; end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def options; end

  # Redefine the prefix for the following attributes
  #
  # @api public
  # @example
  #
  #   dsl = AttributeDSL.new([])
  #   dsl.attribute(:prefix, 'user')
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#44
  def prefix(value = T.unsafe(nil)); end

  # Redefine the prefix separator for the following attributes
  #
  # @api public
  # @example
  #
  #   dsl = AttributeDSL.new([])
  #   dsl.attribute(:prefix_separator, '.')
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#60
  def prefix_separator(value = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def reject_keys; end

  # Perform transformations sequentially
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new()
  #
  #   dsl.step do
  #   attribute :name
  #   end
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#104
  def step(options = T.unsafe(nil), &block); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def steps; end

  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#19
  def symbolize_keys; end

  # Define an embedded hash attribute that requires "unfold" transformation
  #
  # Typically this is used in non-sql context to convert array of
  # values (like in Cassandra 'SET' or 'LIST' types) to array of tuples.
  #
  # Source values are assigned to the first key, the other keys being left blank.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.unfold(tags: [:name, :type], from: :tags_list)
  #
  #   dsl.unfold :tags, from: :tags_list do
  #   attribute :name, from: :tag_name
  #   attribute :type, from: :tag_type
  #   end
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#304
  def unfold(name, options = T.unsafe(nil)); end

  # Define an embedded array attribute that requires "ungrouping" transformation
  #
  # Typically this is used in non-sql context being prepared for import to sql.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #   dsl.ungroup(tags: [:name])
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#257
  def ungroup(*args, &block); end

  # Define an embedded hash attribute that requires "unwrapping" transformation
  #
  # Typically this is used in no-sql context to normalize data before
  # inserting to sql gateway.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.unwrap(address: [:street, :zipcode, :city])
  #
  #   dsl.unwrap(:address) do
  #   attribute :street
  #   attribute :zipcode
  #   attribute :city
  #   end
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#203
  def unwrap(*args, &block); end

  # Define an embedded hash attribute that requires "wrapping" transformation
  #
  # Typically this is used in sql context when relation is a join.
  #
  # @api public
  # @example
  #   dsl = AttributeDSL.new([])
  #
  #   dsl.wrap(address: [:street, :zipcode, :city])
  #
  #   dsl.wrap(:address) do
  #   model Address
  #   attribute :street
  #   attribute :zipcode
  #   attribute :city
  #   end
  # @see AttributeDSL#embedded
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#170
  def wrap(*args, &block); end

  private

  # Add a new attribute and make sure it overrides previous definition
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#449
  def add_attribute(name, options); end

  # Define attributes from a nested block
  #
  # Used by embedded, wrap and group
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#412
  def attributes_from_block(name, options, &block); end

  # Define attributes from the `name => attributes` hash syntax
  #
  # Used by wrap and group
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#424
  def attributes_from_hash(hash, options); end

  # Infer mapper header for an embedded attribute
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#436
  def attributes_from_mapper(mapper, name, options); end

  # Create another instance of the dsl for nested definitions
  #
  # This is used by embedded, wrap and group
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#399
  def dsl(name_or_attrs, options, &block); end

  # Ensure the mapping configuration isn't ambiguous
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#468
  def ensure_mapper_configuration(method_name, args, block_present); end

  # Create a new dsl instance of potentially overidden options
  #
  # Embedded, wrap and group can override top-level options like `prefix`
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#459
  def new(options, &block); end

  # Remove the attribute used somewhere else (in wrap, group, model etc.)
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#360
  def remove(*names); end

  # Handle attribute options common for all definitions
  #
  # @api private
  # @yield [attr_options]
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#367
  def with_attr_options(name, options = T.unsafe(nil)); end

  # Handle "name or options" syntax used by `wrap` and `group`
  #
  # @api private
  # @yield [name, options, ]
  #
  # source://rom-core//lib/rom/mapper/attribute_dsl.rb#383
  def with_name_or_options(*args); end
end

# Setup DSL-specific mapper extensions
#
# @private
#
# source://rom-core//lib/rom/mapper/builder.rb#8
class ROM::Mapper::Builder
  class << self
    # Generate a mapper subclass
    #
    # This is used by Setup#mappers DSL
    #
    # @api private
    #
    # source://rom-core//lib/rom/mapper/builder.rb#14
    def build_class(name, mapper_registry, options = T.unsafe(nil), &block); end
  end
end

# Mapper class-level DSL including Attribute DSL and Model DSL
#
# source://rom-core//lib/rom/mapper/dsl.rb#8
module ROM::Mapper::DSL
  mixes_in_class_methods ::Dry::Core::ClassAttributes
  mixes_in_class_methods ::ROM::Mapper::DSL::ClassMethods

  class << self
    # Extend mapper class with macros and DSL methods
    #
    # @api private
    #
    # source://rom-core//lib/rom/mapper/dsl.rb#12
    def included(klass); end
  end
end

# Class methods for all mappers
#
# @private
#
# source://rom-core//lib/rom/mapper/dsl.rb#20
module ROM::Mapper::DSL::ClassMethods
  # Return base_relation used for creating mapper registry
  #
  # This is used to "gather" mappers under same root name
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#50
  def base_relation; end

  # Return header of the mapper
  #
  # This is memoized so mutating mapper class won't have an effect wrt
  # header after it was initialized for the first time.
  #
  # TODO: freezing mapper class here is probably a good idea
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#62
  def header; end

  # Set base ivars for the mapper class
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#24
  def inherited(klass); end

  # include a registered plugin in this mapper
  #
  # @api public
  # @option options
  # @param plugin [Symbol]
  # @param options [Hash]
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#39
  def use(plugin, options = T.unsafe(nil)); end

  private

  # Return default attributes that might have been inherited from the
  # superclass
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#89
  def attributes; end

  # Create the attribute DSL instance used by the mapper class
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#101
  def dsl; end

  # Delegate Attribute DSL method to the dsl instance
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#108
  def method_missing(name, *args, **_arg2, &block); end

  # Return default Attribute DSL options based on settings of the mapper
  # class
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#77
  def options; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/mapper/dsl.rb#67
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

# Model DSL allows setting a model class
#
# @private
#
# source://rom-core//lib/rom/mapper/model_dsl.rb#10
module ROM::Mapper::ModelDSL
  # Returns the value of attribute attributes.
  #
  # source://rom-core//lib/rom/mapper/model_dsl.rb#11
  def attributes; end

  # Returns the value of attribute builder.
  #
  # source://rom-core//lib/rom/mapper/model_dsl.rb#11
  def builder; end

  # Returns the value of attribute klass.
  #
  # source://rom-core//lib/rom/mapper/model_dsl.rb#11
  def klass; end

  # Set or generate a model
  #
  # @api public
  # @example
  #   class MyDefinition
  #   include ROM::Mapper::ModelDSL
  #
  #   def initialize
  #   @attributes = [[:name], [:title]]
  #   end
  #   end
  #
  #   definition = MyDefinition.new
  #
  #   # just set a model constant
  #   definition.model(User)
  #
  #   # generate model class for the attributes
  #   definition.model(name: 'User')
  #
  # source://rom-core//lib/rom/mapper/model_dsl.rb#35
  def model(options = T.unsafe(nil)); end

  private

  # Build a model class using a specialized builder
  #
  # @api private
  #
  # source://rom-core//lib/rom/mapper/model_dsl.rb#51
  def build_class; end
end

# source://rom-core//lib/rom/mapper/model_dsl.rb#13
ROM::Mapper::ModelDSL::DEFAULT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rom-core//lib/rom/constants.rb#22
class ROM::MapperAlreadyDefinedError < ::StandardError; end

# @api private
#
# source://rom-core//lib/rom/mapper_compiler.rb#12
class ROM::MapperCompiler
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  # @return [MapperCompiler] a new instance of MapperCompiler
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#26
  def initialize(*_arg0, **_arg1); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#34
  def [](ast); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#34
  def call(ast); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#24
  def mapper_options; end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#22
  def struct_compiler; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#41
  def visit(node); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#73
  def visit_attribute(node); end

  # @api private
  #
  # source://rom-core//lib/rom/mapper_compiler.rb#46
  def visit_relation(node); end
end

# source://rom-core//lib/rom/constants.rb#23
class ROM::MapperMisconfiguredError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#55
class ROM::MapperMissingError < ::ROM::ElementNotFoundError; end

# @private
#
# source://rom-core//lib/rom/mapper_registry.rb#9
class ROM::MapperRegistry < ::ROM::Registry
  # @api public
  # @see Registry
  #
  # source://rom-core//lib/rom/mapper_registry.rb#23
  def [](*args); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/mapper_registry.rb#11
    def element_not_found_error; end
  end
end

# @api private
#
# source://rom-core//lib/rom/support/memoizable.rb#5
module ROM::Memoizable
  mixes_in_class_methods ::ROM::Memoizable::ClassInterface

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#27
  def __memoized__; end

  class << self
    # @api private
    # @private
    #
    # source://rom-core//lib/rom/support/memoizable.rb#22
    def included(klass); end
  end
end

# @api private
#
# source://rom-core//lib/rom/support/memoizable.rb#8
module ROM::Memoizable::ClassInterface
  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#10
  def memoize(*names); end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#14
  def new(*_arg0, **_arg1); end
end

# @api private
#
# source://rom-core//lib/rom/support/memoizable.rb#6
ROM::Memoizable::MEMOIZED_HASH = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://rom-core//lib/rom/support/memoizable.rb#30
class ROM::Memoizable::Memoizer < ::Module
  # @api private
  # @return [Memoizer] a new instance of Memoizer
  #
  # source://rom-core//lib/rom/support/memoizable.rb#35
  def initialize(klass, names); end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#31
  def klass; end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#32
  def names; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#44
  def define_memoizable_names!; end
end

# source://rom-core//lib/rom/constants.rb#31
class ROM::MissingAdapterIdentifierError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#64
class ROM::MissingSchemaClassError < ::StandardError
  # source://rom-core//lib/rom/constants.rb#66
  def initialize(klass); end
end

# source://rom-core//lib/rom/constants.rb#71
class ROM::MissingSchemaError < ::StandardError
  # source://rom-core//lib/rom/constants.rb#73
  def initialize(klass); end
end

# Model builders can be used to build model classes for mappers
#
# This is used when you define a mapper and setup a model using :name option.
#
# @example
#   # this will define User model for you
#   class UserMapper < ROM::Mapper
#   model name: 'User'
#   attribute :id
#   attribute :name
#   end
# @private
#
# source://rom-core//lib/rom/model_builder.rb#19
class ROM::ModelBuilder
  # @api private
  # @return [ModelBuilder] a new instance of ModelBuilder
  #
  # source://rom-core//lib/rom/model_builder.rb#49
  def initialize(options = T.unsafe(nil)); end

  # Build a model class supporting specific attributes
  #
  # @api private
  # @return [Class]
  #
  # source://rom-core//lib/rom/model_builder.rb#78
  def call(attrs); end

  # Returns the value of attribute const_name.
  #
  # source://rom-core//lib/rom/model_builder.rb#22
  def const_name; end

  # Define a model class constant
  #
  # @api private
  #
  # source://rom-core//lib/rom/model_builder.rb#69
  def define_const; end

  # Returns the value of attribute klass.
  #
  # source://rom-core//lib/rom/model_builder.rb#22
  def klass; end

  # Returns the value of attribute name.
  #
  # source://rom-core//lib/rom/model_builder.rb#20
  def name; end

  # Returns the value of attribute namespace.
  #
  # source://rom-core//lib/rom/model_builder.rb#22
  def namespace; end

  class << self
    # Return model builder subclass based on type
    #
    # @api private
    # @param type [Symbol]
    # @return [Class]
    #
    # source://rom-core//lib/rom/model_builder.rb#31
    def [](type); end

    # Build a model class
    #
    # @api private
    # @return [Class]
    #
    # source://rom-core//lib/rom/model_builder.rb#44
    def call(*args); end
  end
end

# PORO model class builder
#
# @private
#
# source://rom-core//lib/rom/model_builder.rb#87
class ROM::ModelBuilder::PORO < ::ROM::ModelBuilder
  # source://rom-core//lib/rom/model_builder.rb#88
  def define_class(attrs); end
end

# source://rom-core//lib/rom/constants.rb#24
class ROM::NoRelationError < ::StandardError; end

# Notification subsystem
#
# This is an abstract event bus that implements a simple pub/sub protocol.
# The Notifications module is used in the setup process to decouple
# different modules from each other.
#
# @example
#   class Setup
#   extend ROM::Notifications
#
#   register_event('setup.before_setup')
#   register_event('setup.after_setup')
#
#   def initialize
#   @bus = Notifications.event_bus(:setup)
#   end
#
#   def setup
#   @bus.trigger('setup.before_setup', at: Time.now)
#   # ...
#   @bus.trigger('setup.after_setup', at: Time.now)
#   end
#   end
#
#   class Plugin
#   extend ROM::Notifications::Listener
#
#   subscribe('setup.after_setup') do |event|
#   puts "Loaded at #{event.at.iso8601}"
#   end
#   end
#
# source://rom-core//lib/rom/support/notifications.rb#38
module ROM::Notifications
  extend ::ROM::Notifications::Publisher

  # Register an event
  #
  # @api public
  # @param id [String] A unique event key
  # @param info [Hash]
  #
  # source://rom-core//lib/rom/support/notifications.rb#158
  def register_event(id, info = T.unsafe(nil)); end

  class << self
    # Build an event bus
    #
    # @api public
    # @param id [Symbol] Bus key
    # @return [Notifications::EventBus] A new bus
    #
    # source://rom-core//lib/rom/support/notifications.rb#178
    def event_bus(id); end

    # @api private
    #
    # source://rom-core//lib/rom/support/notifications.rb#163
    def events; end

    # @api private
    #
    # source://rom-core//lib/rom/support/notifications.rb#168
    def listeners; end
  end
end

# Event object
#
# @api public
#
# source://rom-core//lib/rom/support/notifications.rb#77
class ROM::Notifications::Event
  include ::Dry::Core::Equalizer::Methods

  # Initialize a new event
  #
  # @api private
  # @param id [Symbol] The event identifier
  # @param payload [Hash] Optional payload
  # @return [Event]
  #
  # source://rom-core//lib/rom/support/notifications.rb#92
  def initialize(id, payload = T.unsafe(nil)); end

  # Get data from the payload
  #
  # @api public
  # @param name [String, Symbol]
  #
  # source://rom-core//lib/rom/support/notifications.rb#102
  def [](name); end

  # @api public
  #
  # source://rom-core//lib/rom/support/notifications.rb#82
  def id; end

  # Get or set a payload
  #
  # @api public
  # @overload
  # @overload payload
  #
  # source://rom-core//lib/rom/support/notifications.rb#126
  def payload(data = T.unsafe(nil)); end

  # Coerce an event to a hash
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-core//lib/rom/support/notifications.rb#111
  def to_h; end

  # Coerce an event to a hash
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-core//lib/rom/support/notifications.rb#111
  def to_hash; end

  # Trigger the event
  #
  # @api private
  # @param listener [#call]
  # @param query [Hash]
  #
  # source://rom-core//lib/rom/support/notifications.rb#140
  def trigger(listener, query = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/notifications.rb#145
  def trigger?(query); end
end

# Event bus
#
# An event bus stores listeners (callbacks) and events
#
# @api public
#
# source://rom-core//lib/rom/support/notifications.rb#203
class ROM::Notifications::EventBus
  include ::ROM::Notifications::Publisher

  # Initialize a new event bus
  #
  # @api public
  # @param id [Symbol] The bus identifier
  # @param events [Hash] A hash with events
  # @param listeners [Hash] A hash with listeners
  # @return [EventBus] a new instance of EventBus
  #
  # source://rom-core//lib/rom/support/notifications.rb#225
  def initialize(id, events: T.unsafe(nil), listeners: T.unsafe(nil)); end

  # @api public
  #
  # source://rom-core//lib/rom/support/notifications.rb#212
  def events; end

  # @api public
  #
  # source://rom-core//lib/rom/support/notifications.rb#208
  def id; end

  # @api public
  #
  # source://rom-core//lib/rom/support/notifications.rb#216
  def listeners; end
end

# source://rom-core//lib/rom/support/notifications.rb#39
ROM::Notifications::LISTENERS_HASH = T.let(T.unsafe(nil), Hash)

# Extension for objects that can listen to events
#
# @api public
#
# source://rom-core//lib/rom/support/notifications.rb#185
module ROM::Notifications::Listener
  # Subscribe to events
  #
  # @api public
  # @param event_id [String] The event key
  # @param query [Hash] An optional event filter
  # @return [Object] self
  #
  # source://rom-core//lib/rom/support/notifications.rb#193
  def subscribe(event_id, query = T.unsafe(nil), &block); end
end

# Extension used for classes that can trigger events
#
# @api public
#
# source://rom-core//lib/rom/support/notifications.rb#44
module ROM::Notifications::Publisher
  # Subscribe to events.
  # If the query parameter is provided, filters events by payload.
  #
  # @api public
  # @param event_id [String] The event key
  # @param query [Hash] An optional event filter
  # @return [Object] self
  # @yield [block] The callback
  #
  # source://rom-core//lib/rom/support/notifications.rb#54
  def subscribe(event_id, query = T.unsafe(nil), &block); end

  # Trigger an event
  #
  # @api public
  # @param event_id [String] The event key
  # @param payload [Hash] An optional payload
  #
  # source://rom-core//lib/rom/support/notifications.rb#65
  def trigger(event_id, payload = T.unsafe(nil)); end
end

# ROM's open structs are used for relations with empty schemas.
# Such relations may exist in cases like using raw SQL strings
# where schema was not explicitly defined using `view` DSL.
#
# @api public
#
# source://rom-core//lib/rom/open_struct.rb#9
class ROM::OpenStruct
  # @api private
  # @return [OpenStruct] a new instance of OpenStruct
  #
  # source://rom-core//lib/rom/open_struct.rb#13
  def initialize(attributes); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/open_struct.rb#27
  def method_missing(meth, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/open_struct.rb#20
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# @api public
#
# source://rom-core//lib/rom/open_struct.rb#10
ROM::OpenStruct::IVAR = T.let(T.unsafe(nil), Proc)

# Data pipeline common interface
#
# @api private
#
# source://rom-core//lib/rom/pipeline.rb#7
module ROM::Pipeline
  include ::ROM::Pipeline::Operator

  # Send data through specified mappers
  #
  # @api public
  # @return [Relation::Composite]
  #
  # source://rom-core//lib/rom/pipeline.rb#41
  def map_with(*names); end
end

# Base composite class with left-to-right pipeline behavior
#
# @api private
#
# source://rom-core//lib/rom/pipeline.rb#84
class ROM::Pipeline::Composite
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Pipeline::Proxy

  # @api private
  # @return [Composite] a new instance of Composite
  #
  # source://rom-core//lib/rom/pipeline.rb#98
  def initialize(left, right); end

  # Compose this composite with another object
  #
  # @api public
  #
  # source://rom-core//lib/rom/pipeline.rb#106
  def >>(other); end

  # @api private
  #
  # source://rom-core//lib/rom/pipeline.rb#92
  def left; end

  # @api private
  #
  # source://rom-core//lib/rom/pipeline.rb#95
  def right; end
end

# Common `>>` operator extension
#
# @api private
#
# source://rom-core//lib/rom/pipeline.rb#11
module ROM::Pipeline::Operator
  # Compose two relation with a left-to-right composition
  #
  # @api public
  # @example
  #   users.by_name('Jane') >> tasks.for_users
  # @param other [Relation] The right relation
  # @return [Relation::Composite]
  #
  # source://rom-core//lib/rom/pipeline.rb#22
  def >>(other); end

  private

  # @api private
  # @raise [NotImplementedError]
  #
  # source://rom-core//lib/rom/pipeline.rb#29
  def composite_class; end
end

# Forwards messages to the left side of a pipeline
#
# @api private
#
# source://rom-core//lib/rom/pipeline.rb#49
module ROM::Pipeline::Proxy
  private

  # Check if response from method missing should be decorated
  #
  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/pipeline.rb#60
  def decorate?(response); end

  # @api private
  #
  # source://rom-core//lib/rom/pipeline.rb#65
  def method_missing(name, *args, **_arg2, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/pipeline.rb#51
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# Plugin is a simple object used to store plugin configurations
#
# @private
#
# source://rom-core//lib/rom/plugin.rb#11
class ROM::Plugin
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::ROM::Configurable
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # Apply this plugin to the target
  #
  # @api private
  # @param target [Class, Object]
  #
  # source://rom-core//lib/rom/plugin.rb#35
  def apply_to(target, **options); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end
end

# Stores all registered plugins
#
# @api private
#
# source://rom-core//lib/rom/plugin_registry.rb#11
class ROM::PluginRegistry
  # @api private
  # @return [PluginRegistry] a new instance of PluginRegistry
  #
  # source://rom-core//lib/rom/plugin_registry.rb#16
  def initialize; end

  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#45
  def [](type); end

  # Register a plugin for future use
  #
  # relation or mapper)
  # applies to. Leave blank for all adapters
  #
  # @api private
  # @option options
  # @option options
  # @param name [Symbol] The registration name for the plugin
  # @param mod [Module] The plugin to register
  # @param options [Hash] optional configuration data
  #
  # source://rom-core//lib/rom/plugin_registry.rb#29
  def register(name, mod, options = T.unsafe(nil)); end

  # Old API compatibility
  #
  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#52
  def singularize(type); end

  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#34
  def type(type); end

  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#13
  def types; end
end

# Registry of all known plugin types (command, relation, mapper, etc)
#
# @api private
#
# source://rom-core//lib/rom/plugins.rb#9
module ROM::Plugins
  extend ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/plugins.rb#14
    def register(entity_type, plugin_type: T.unsafe(nil), adapter: T.unsafe(nil)); end
  end
end

# source://rom-core//lib/rom/plugins/command/schema.rb#5
module ROM::Plugins::Command; end

# Command plugin which sets input processing function via relation schema
#
# @api private
#
# source://rom-core//lib/rom/plugins/command/schema.rb#9
module ROM::Plugins::Command::Schema
  mixes_in_class_methods ::ROM::Plugins::Command::Schema::ClassInterface

  class << self
    # @api private
    # @private
    #
    # source://rom-core//lib/rom/plugins/command/schema.rb#10
    def included(klass); end
  end
end

# @api private
#
# source://rom-core//lib/rom/plugins/command/schema.rb#16
module ROM::Plugins::Command::Schema::ClassInterface
  # Build a command and set it input to relation's input_schema
  #
  # @api public
  # @return [Command]
  # @see Command.build
  #
  # source://rom-core//lib/rom/plugins/command/schema.rb#24
  def build(relation, **options); end
end

# A plugin for automatically adding timestamp values
# when executing a command
#
# Set up attributes to timestamp when the command is called
#
# @api public
# @example
#   class CreateTask < ROM::Commands::Create[:sql]
#   result :one
#   use :timestamps, timestamps: %i(created_at, updated_at), datestamps: %i(:written)
#   end
#
#   create_user = rom.command(:user).create.curry(name: 'Jane')
#
#   result = create_user.call
#   result[:created_at]  #=> Time.now.utc
#
# source://rom-core//lib/rom/plugins/command/timestamps.rb#25
class ROM::Plugins::Command::Timestamps < ::Module
  # @api public
  # @return [Timestamps] a new instance of Timestamps
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#27
  def initialize(timestamps: T.unsafe(nil), datestamps: T.unsafe(nil)); end

  # @api public
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#26
  def datestamps; end

  # @api private
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#38
  def included(klass); end

  # @api public
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#45
  def initialize_timestamp_attributes(klass); end

  # @api private
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#33
  def store_attributes(attr); end

  # @api public
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#26
  def timestamps; end
end

# @api public
#
# source://rom-core//lib/rom/plugins/command/timestamps.rb#98
module ROM::Plugins::Command::Timestamps::ClassInterface
  # Set up attributes to datestamp when the command is called
  #
  # @api public
  # @example
  #   class CreateTask < ROM::Commands::Create[:sql]
  #   result :one
  #   use :timestamps
  #   datestamps :created_on, :updated_on
  #   end
  #
  #   create_user = rom.command(:user).create.curry(name: 'Jane')
  #
  #   result = create_user.call
  #   result[:created_at]  #=> Date.today
  # @param names [Array<Symbol>] A list of attribute names
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#139
  def datestamp(*names); end

  # Set up attributes to datestamp when the command is called
  #
  # @api public
  # @example
  #   class CreateTask < ROM::Commands::Create[:sql]
  #   result :one
  #   use :timestamps
  #   datestamps :created_on, :updated_on
  #   end
  #
  #   create_user = rom.command(:user).create.curry(name: 'Jane')
  #
  #   result = create_user.call
  #   result[:created_at]  #=> Date.today
  # @param names [Array<Symbol>] A list of attribute names
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#139
  def datestamps(*names); end

  # Set up attributes to timestamp when the command is called
  #
  # @api private
  # @api public
  # @example
  #   class CreateTask < ROM::Commands::Create[:sql]
  #   result :one
  #   use :timestamps
  #   timestamps :created_at, :updated_at
  #   end
  #
  #   create_user = rom.command(:user).create.curry(name: 'Jane')
  #
  #   result = create_user.call
  #   result[:created_at]  #=> Time.now.utc
  # @param names [Array<Symbol>] A list of attribute names
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#117
  def timestamp(*names); end

  # Set up attributes to timestamp when the command is called
  #
  # @api private
  # @api public
  # @example
  #   class CreateTask < ROM::Commands::Create[:sql]
  #   result :one
  #   use :timestamps
  #   timestamps :created_at, :updated_at
  #   end
  #
  #   create_user = rom.command(:user).create.curry(name: 'Jane')
  #
  #   result = create_user.call
  #   result[:created_at]  #=> Time.now.utc
  # @param names [Array<Symbol>] A list of attribute names
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#117
  def timestamps(*names); end
end

# @api public
#
# source://rom-core//lib/rom/plugins/command/timestamps.rb#54
module ROM::Plugins::Command::Timestamps::InstanceMethods
  # @api private
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#61
  def datestamp_columns; end

  # Set the timestamp attributes on the given tuples
  #
  # @api private
  # @param tuples [Array<Hash>, Hash] the input tuple(s)
  # @return [Array<Hash>, Hash]
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#72
  def set_timestamps(tuples, *_arg1); end

  # @api private
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#56
  def timestamp_columns; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/plugins/command/timestamps.rb#81
  def build_timestamps; end
end

# source://rom-core//lib/rom/plugins/relation/registry_reader.rb#7
module ROM::Plugins::Relation; end

# Experimental plugin for configuring relations with an external
# instrumentation system like dry-monitor or ActiveSupport::Notifications
#
# @api public
#
# source://rom-core//lib/rom/plugins/relation/instrumentation.rb#10
module ROM::Plugins::Relation::Instrumentation
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  mixes_in_class_methods ::ROM::Plugins::Relation::Instrumentation::ClassInterface

  # Execute a block using instrumentation
  #
  # @api public
  #
  # source://rom-core//lib/rom/plugins/relation/instrumentation.rb#48
  def instrument(&block); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/plugins/relation/instrumentation.rb#55
  def notification_payload(_relation); end

  class << self
    # This hooks sets up a relation class with injectible notifications object
    #
    # @api private
    #
    # source://rom-core//lib/rom/plugins/relation/instrumentation.rb#16
    def included(klass); end
  end
end

# Instrumentation extension for relation classes
#
# @api private
#
# source://rom-core//lib/rom/plugins/relation/instrumentation.rb#30
module ROM::Plugins::Relation::Instrumentation::ClassInterface
  # Configure provided methods for instrumentation
  #
  # @api public
  # @param methods [Array<Symbol>] A list of method names
  #
  # source://rom-core//lib/rom/plugins/relation/instrumentation.rb#36
  def instrument(*methods); end
end

# Allows relations to access all other relations through registry
#
# For now this plugin is always enabled
#
# @api public
#
# source://rom-core//lib/rom/plugins/relation/registry_reader.rb#13
class ROM::Plugins::Relation::RegistryReader < ::Module
  # @api private
  # @return [RegistryReader] a new instance of RegistryReader
  #
  # source://rom-core//lib/rom/plugins/relation/registry_reader.rb#20
  def initialize(relations:); end

  # @api private
  #
  # source://rom-core//lib/rom/plugins/relation/registry_reader.rb#26
  def included(klass); end

  # @api private
  #
  # source://rom-core//lib/rom/plugins/relation/registry_reader.rb#17
  def relations; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/plugins/relation/registry_reader.rb#36
  def define_readers!; end
end

# @api public
#
# source://rom-core//lib/rom/plugins/relation/registry_reader.rb#14
ROM::Plugins::Relation::RegistryReader::EMPTY_REGISTRY = T.let(T.unsafe(nil), ROM::RelationRegistry)

# source://rom-core//lib/rom/plugins/schema/timestamps.rb#5
module ROM::Plugins::Schema; end

# A plugin for automatically adding timestamp fields
# to the schema definition
#
# @api public
# @example
#   schema do
#   use :timestamps
#   end
#
#   # using non-default names
#   schema do
#   use :timestamps, attributes: %i(created_on updated_on)
#   end
#
#   # using other types
#   schema do
#   use :timestamps, type: Types::Date
#   end
#
# source://rom-core//lib/rom/plugins/schema/timestamps.rb#25
module ROM::Plugins::Schema::Timestamps
  class << self
    # @api private
    #
    # source://rom-core//lib/rom/plugins/schema/timestamps.rb#29
    def apply(schema, type: T.unsafe(nil), attributes: T.unsafe(nil)); end
  end
end

# @api public
#
# source://rom-core//lib/rom/plugins/schema/timestamps.rb#26
ROM::Plugins::Schema::Timestamps::DEFAULT_TIMESTAMPS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rom-core//lib/rom/plugins/schema/timestamps.rb#43
module ROM::Plugins::Schema::Timestamps::DSL
  # Sets non-default timestamp attributes
  #
  # @api public
  # @example
  #   schema do
  #   use :timestamps
  #   timestamps :create_on, :updated_on
  #   end
  #
  # source://rom-core//lib/rom/plugins/schema/timestamps.rb#53
  def timestamps(*names); end
end

# Abstract registry defining common behaviour
#
# @api private
#
# source://rom-core//lib/rom/plugin_registry.rb#66
class ROM::PluginsContainer < ::ROM::Registry
  # @api private
  #
  # source://rom-core//lib/rom/plugin_registry.rb#85
  def plugin_type; end

  # Assign a plugin to this environment registry
  #
  # @api private
  # @param name [Symbol] The registered plugin name
  # @param mod [Module] The plugin to register
  # @param options [Hash] optional configuration data
  #
  # source://rom-core//lib/rom/plugin_registry.rb#80
  def register(name, mod, options); end
end

# Abstract processor class
#
# Every ROM processor should inherit from this class
#
# @api public
#
# source://rom-core//lib/rom/processor.rb#11
class ROM::Processor
  class << self
    # Required interface to be implemented by descendants
    #
    # @abstract
    # @api private
    # @raise [NotImplementedError]
    # @return [Processor]
    #
    # source://rom-core//lib/rom/processor.rb#26
    def build; end

    # Hook used to auto-register a processor class
    #
    # @api private
    #
    # source://rom-core//lib/rom/processor.rb#15
    def inherited(processor); end
  end
end

# Data mapping transformer builder using Transproc
#
# This builds a transproc function that is used to map a whole relation
#
# @private
# @see https://github.com/solnic/transproc too
#
# source://rom-core//lib/rom/processor/transproc.rb#16
class ROM::Processor::Transproc < ::ROM::Processor
  include ::Transproc::Composer

  # @api private
  # @return [Transproc] a new instance of Transproc
  #
  # source://rom-core//lib/rom/processor/transproc.rb#86
  def initialize(mapper, header); end

  # @api private
  # @return [Header] header from a mapper
  #
  # source://rom-core//lib/rom/processor/transproc.rb#57
  def header; end

  # @api private
  # @return [Mapper] mapper that this processor belongs to
  #
  # source://rom-core//lib/rom/processor/transproc.rb#52
  def mapper; end

  # @api private
  # @return [Hash] header's attribute mapping
  #
  # source://rom-core//lib/rom/processor/transproc.rb#67
  def mapping; end

  # @api private
  # @return [Class] model class from a mapper
  #
  # source://rom-core//lib/rom/processor/transproc.rb#62
  def model; end

  # @api private
  # @return [Proc] row-processing proc
  #
  # source://rom-core//lib/rom/processor/transproc.rb#72
  def row_proc; end

  # Coerce mapper header to a transproc data mapping function
  #
  # @api private
  # @return [Transproc::Function]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#99
  def to_transproc; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#345
  def combined_args(attribute); end

  # Build row_proc
  #
  # This transproc function is applied to each row in a dataset
  #
  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#361
  def initialize_row_proc; end

  # Return a new instance of the processor
  #
  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#405
  def new(*args); end

  # Process row_proc header keys
  #
  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#375
  def process_header_keys(ops); end

  # Build a row_proc from a given attribute
  #
  # This is used by embedded attribute visitors
  #
  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#398
  def row_proc_from(attribute); end

  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#410
  def t(*args); end

  # Visit an attribute from the header
  #
  # This forwards to a specialized visitor based on the attribute type
  #
  # @api private
  # @param attribute [Header::Attribute]
  # @param args [Array] Allows to send `preprocess: true`
  #
  # source://rom-core//lib/rom/processor/transproc.rb#119
  def visit(attribute, *args); end

  # Visit array attribute
  #
  # @api private
  # @param attribute [Header::Attribute::Array]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#185
  def visit_array(attribute); end

  # Visit plain attribute
  #
  # It will call block transformation if it's used
  #
  # If it's a typed attribute a coercion transformation is added
  #
  # @api private
  # @param attribute [Header::Attribute]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#133
  def visit_attribute(attribute); end

  # Visit combined attribute
  #
  # @api private
  #
  # source://rom-core//lib/rom/processor/transproc.rb#161
  def visit_combined(attribute); end

  # Visit excluded attribute
  #
  # @api private
  # @param attribute [Header::Attribute::Exclude]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#340
  def visit_exclude(attribute); end

  # Visit fold hash attribute
  #
  # :fold transformation is added to handle folding during preprocessing.
  #
  # @api private
  # @param attribute [Header::Attribute::Fold]
  # @param preprocess [Boolean] true if we are building a relation preprocessing
  #   function that is applied to the whole relation
  #
  # source://rom-core//lib/rom/processor/transproc.rb#293
  def visit_fold(attribute, preprocess = T.unsafe(nil)); end

  # Visit group hash attribute
  #
  # :group transformation is added to handle grouping during preprocessing.
  # Otherwise we simply use array visitor for the attribute.
  #
  # @api private
  # @param attribute [Header::Attribute::Group]
  # @param preprocess [Boolean] true if we are building a relation preprocessing
  #   function that is applied to the whole relation
  #
  # source://rom-core//lib/rom/processor/transproc.rb#235
  def visit_group(attribute, preprocess = T.unsafe(nil)); end

  # Visit hash attribute
  #
  # @api private
  # @param attribute [Header::Attribute::Hash]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#152
  def visit_hash(attribute); end

  # Visit unfold hash attribute
  #
  # :unfold transformation is added to handle unfolding during preprocessing.
  #
  # @api private
  # @param attribute [Header::Attribute::Unfold]
  # @param preprocess [Boolean] true if we are building a relation preprocessing
  #   function that is applied to the whole relation
  #
  # source://rom-core//lib/rom/processor/transproc.rb#315
  def visit_unfold(attribute, preprocess = T.unsafe(nil)); end

  # Visit ungroup attribute
  #
  # :ungroup transforation is added to handle ungrouping during preprocessing.
  # Otherwise we simply use array visitor for the attribute.
  #
  # @api private
  # @param attribute [Header::Attribute::Ungroup]
  # @param preprocess [Boolean] true if we are building a relation preprocessing
  #   function that is applied to the whole relation
  #
  # source://rom-core//lib/rom/processor/transproc.rb#265
  def visit_ungroup(attribute, preprocess = T.unsafe(nil)); end

  # Visit unwrap attribute
  #
  # :unwrap transformation is added to handle unwrapping
  #
  # @api private
  # @param attribute [Header::Attributes::Unwrap]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#215
  def visit_unwrap(attribute); end

  # Visit wrapped hash attribute
  #
  # :nest transformation is added to handle wrapping
  #
  # @api private
  # @param attribute [Header::Attribute::Wrap]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#198
  def visit_wrap(attribute); end

  # Yield row proc for a given attribute if any
  #
  # @api private
  # @param attribute [Header::Attribute]
  # @yield [row_proc]
  #
  # source://rom-core//lib/rom/processor/transproc.rb#388
  def with_row_proc(attribute); end

  class << self
    # Build a transproc function from the header
    #
    # @api private
    # @param header [ROM::Header]
    # @return [Transproc::Function]
    #
    # source://rom-core//lib/rom/processor/transproc.rb#81
    def build(mapper, header); end
  end
end

# source://rom-core//lib/rom/processor/transproc.rb#19
module ROM::Processor::Transproc::Functions
  extend ::Transproc::Registry

  class << self
    # source://rom-core//lib/rom/processor/transproc.rb#35
    def filter_empty(arr); end

    # source://rom-core//lib/rom/processor/transproc.rb#31
    def get(arr, idx); end

    # @raise [ROM::MapperMisconfiguredError]
    #
    # source://rom-core//lib/rom/processor/transproc.rb#39
    def inject_union_value(tuple, name, keys, coercer); end
  end
end

# source://rom-core//lib/rom/processor/transproc.rb#29
ROM::Processor::Transproc::Functions::INVALID_INJECT_UNION_VALUE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rom-core//lib/rom/registry.rb#9
class ROM::Registry
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Cache::Methods
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::Dry::Core::Cache

  # @api private
  # @raise [ArgumentError]
  #
  # source://rom-core//lib/rom/registry.rb#85
  def [](key); end

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#73
  def each; end

  # @api private
  # @raise [ArgumentError]
  #
  # source://rom-core//lib/rom/registry.rb#85
  def fetch(key); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/registry.rb#80
  def key?(name); end

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#65
  def map; end

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#55
  def merge(other); end

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#60
  def to_hash; end

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#96
  def type; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/registry.rb#108
  def method_missing(name, *_arg1); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/registry.rb#101
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/registry.rb#41
    def [](identifier); end

    # Create a registry without options
    #
    # @api private
    #
    # source://rom-core//lib/rom/registry.rb#36
    def build(elements = T.unsafe(nil)); end

    # @api private
    #
    # source://rom-core//lib/rom/registry.rb#50
    def element_not_found_error; end

    # @api private
    #
    # source://rom-core//lib/rom/registry.rb#25
    def new(*args, **kwargs); end
  end
end

# Base relation class
#
# Relation is a proxy for the dataset object provided by the gateway. It
# can forward methods to the dataset, which is why the "native" interface of
# the underlying gateway is available in the relation
#
# Individual adapters sets up their relation classes and provide different APIs
# depending on their persistence backend.
#
# @api public
#
# source://rom-core//lib/rom/relation/loaded.rb#4
class ROM::Relation
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::ROM::Relation::Commands
  include ::ROM::Memoizable
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Relation::Materializable
  include ::ROM::Pipeline::Operator
  include ::ROM::Pipeline
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::ROM::Relation::ClassInterface
  extend ::ROM::Memoizable::ClassInterface
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::AutoCurry

  # Return schema attribute
  #
  # @api public
  # @example accessing canonical attribute
  #   users[:id]
  #   # => #<ROM::SQL::Attribute[Integer] primary_key=true name=:id source=ROM::Relation::Name(users)>
  # @example accessing joined attribute
  #   tasks_with_users = tasks.join(users).select_append(tasks[:title])
  #   tasks_with_users[:title, :tasks]
  #   # => #<ROM::SQL::Attribute[String] primary_key=false name=:title source=ROM::Relation::Name(tasks)>
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/relation.rb#204
  def [](name); end

  # @api private
  # @return [Symbol] The wrapped relation's adapter identifier ie :sql or :http
  #
  # source://rom-core//lib/rom/relation.rb#560
  def adapter; end

  # Return a new relation with an aliased name
  #
  # @api public
  # @example
  #   users.as(:people)
  # @param aliaz [Symbol] Aliased name
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation.rb#553
  def as(aliaz); end

  # Return schema's association set (empty by default)
  #
  # @api public
  # @return [AssociationSet] Schema's association set (empty by default)
  #
  # source://rom-core//lib/rom/relation.rb#459
  def associations; end

  # @api private
  #
  # source://rom-core//lib/rom/relation.rb#473
  def attr_ast; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def auto_map?; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def auto_struct?; end

  # Loads a relation
  #
  # @api public
  # @return [Relation::Loaded]
  #
  # source://rom-core//lib/rom/relation.rb#351
  def call; end

  # Combine with other relations using configured associations
  #
  # @api public
  # @overload combine
  # @overload combine
  # @overload combine
  # @return [Relation]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#49
  def combine(*args); end

  # Composes with other relations
  #
  # @api public
  # @param others [Array<Relation>] The other relation(s) to compose with
  # @return [Relation::Graph]
  #
  # source://rom-core//lib/rom/relation.rb#262
  def combine_with(*others); end

  # Returns if this relation is curried
  #
  # @api private
  # @return [false]
  #
  # source://rom-core//lib/rom/relation.rb#369
  def curried?; end

  # Yields relation tuples
  #
  # Every tuple is processed through Relation#output_schema, it's a no-op by default
  #
  # @api public
  # @return [Enumerator] if block is not provided
  # @yield [Hash]
  #
  # source://rom-core//lib/rom/relation.rb#217
  def each; end

  # Return a graph node prepared by the given association
  #
  # @api public
  # @param assoc [Association] An association object
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation.rb#300
  def eager_load(assoc); end

  # Return a foreign key name for the provided relation name
  #
  # @api private
  # @param name [Name] The relation name object
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#49
  def foreign_key(*args); end

  # Return name of the source gateway of this relation
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/relation.rb#569
  def gateway; end

  # Returns if this relation is a graph
  #
  # @api private
  # @return [false]
  #
  # source://rom-core//lib/rom/relation.rb#378
  def graph?; end

  # Return a new relation that will map its tuples to instances of the provided class
  #
  # @api public
  # @example
  #   users.map_to(MyUserModel)
  # @param klass [Class] Your custom model class
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation.rb#539
  def map_to(klass, **opts); end

  # Maps relation with custom mappers available in the registry
  #
  # When `auto_map` is enabled, your mappers will be applied after performing
  # default auto-mapping. This means that you can compose complex relations
  # and have them auto-mapped, and use much simpler custom mappers to adjust
  # resulting data according to your requirements.
  #
  # @api public
  # @overload map_with
  # @overload map_with
  # @return [Relation::Composite] Mapped relation
  #
  # source://rom-core//lib/rom/relation.rb#525
  def map_with(*names, **opts); end

  # @api private
  #
  # source://rom-core//lib/rom/relation.rb#495
  def mapper; end

  # @api private
  #
  # source://rom-core//lib/rom/relation.rb#478
  def meta_ast; end

  # Return a new relation with provided dataset and additional options
  #
  # Use this method whenever you need to use dataset API to get a new dataset
  # and you want to return a relation back. Typically relation API should be
  # enough though. If you find yourself using this method, it might be worth
  # to consider reporting an issue that some dataset functionality is not available
  # through relation API.
  #
  # @api public
  # @example with a new dataset
  #   users.new(users.dataset.some_method)
  # @example with a new dataset and options
  #   users.new(users.dataset.some_method, other: 'options')
  # @param dataset [Object]
  # @param new_opts [Hash] Additional options
  #
  # source://rom-core//lib/rom/relation.rb#418
  def new(dataset, **new_opts); end

  # Create a graph node for a given association identifier
  #
  # @api public
  # @param name [Symbol, Relation::Name]
  # @return [Relation]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#49
  def node(*args); end

  # @api private
  #
  # source://rom-core//lib/rom/relation.rb#267
  def nodes(*args); end

  # Preload other relation via association
  #
  # This is used internally when relations are composed
  #
  # @api private
  # @return [Relation::Curried]
  #
  # source://rom-core//lib/rom/auto_curry.rb#48
  def preload_assoc(*args, **_arg1, &mblock); end

  # Returns true if a relation has schema defined
  #
  # @api private
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/relation.rb#396
  def schema?; end

  # Return all registered relation schemas
  #
  # This holds all schemas defined via `view` DSL
  #
  # @api public
  # @return [Hash<Symbol=>Schema>]
  #
  # source://rom-core//lib/rom/relation.rb#580
  def schemas; end

  # Return a new relation configured with the provided struct namespace
  #
  # @api public
  # @param ns [Module] Custom namespace module for auto-structs
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation.rb#608
  def struct_namespace(ns); end

  # Materializes a relation into an array
  #
  # @api public
  # @return [Array<Hash>]
  #
  # source://rom-core//lib/rom/relation.rb#360
  def to_a; end

  # Returns AST for the wrapped relation
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_ast; end

  # Returns a new instance with the same dataset but new options
  #
  # @api public
  # @example
  #   users.with(output_schema: -> tuple { .. })
  # @param opts [Hash] New options
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation.rb#443
  def with(opts); end

  # Wrap other relations using association names
  #
  # @api public
  # @example
  #   tasks.wrap(:owner)
  # @param names [Array<Symbol>] A list with association identifiers
  # @return [Wrap]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#49
  def wrap(*args); end

  # Return if this is a wrap relation
  #
  # @api private
  # @return [false]
  #
  # source://rom-core//lib/rom/relation.rb#387
  def wrap?; end

  # Wrap around other relations
  #
  # @api public
  # @param others [Array<Relation>] Other relations
  # @return [Relation::Wrap]
  #
  # source://rom-core//lib/rom/relation.rb#342
  def wrap_around(*others); end

  private

  # Hook used by `Pipeline` to get the class that should be used for composition
  #
  # @api private
  # @return [Class]
  #
  # source://rom-core//lib/rom/relation.rb#627
  def composite_class; end

  # Return configured "wrap" relation class used in Relation#wrap
  #
  # @api private
  # @return [Class]
  #
  # source://rom-core//lib/rom/relation.rb#636
  def wrap_class; end

  class << self
    # source://rom-core//lib/rom/auto_curry.rb#9
    def method_added(name); end
  end
end

# Global class-level API for relation classes
#
# @api public
#
# source://rom-core//lib/rom/relation/class_interface.rb#18
module ROM::Relation::ClassInterface
  extend ::ROM::Notifications::Listener

  # Return adapter-specific relation subclass
  #
  # @api public
  # @example
  #   ROM::Relation[:memory]
  #   # => ROM::Memory::Relation
  # @return [Class]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#47
  def [](adapter); end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#275
  def curried; end

  # Set or get custom dataset block
  #
  # This block will be evaluated when a relation is instantiated and registered
  # in a relation registry.
  #
  # @api public
  # @example
  #   class Users < ROM::Relation[:memory]
  #   dataset { sort_by(:id) }
  #   end
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#64
  def dataset(&block); end

  # Return default relation name used in schemas
  #
  # @api private
  # @return [Name]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#297
  def default_name; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#302
  def default_schema(klass = T.unsafe(nil)); end

  # Dynamically define a method that will forward to the dataset and wrap
  # response in the relation itself
  #
  # @api public
  # @example
  #   class SomeAdapterRelation < ROM::Relation
  #   forward :super_query
  #   end
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#235
  def forward(*methods); end

  # Build default mapper registry
  #
  # @api private
  # @return [MapperRegistry]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#261
  def mapper_registry(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#312
  def name; end

  # @api public
  # @raise [MissingSchemaError]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#135
  def relation_name; end

  # Specify canonical schema for a relation
  #
  # With a schema defined commands will set up a type-safe input handler
  # automatically
  #
  # @api public
  # @example
  #   class Users < ROM::Relation[:sql]
  #   schema do
  #   attribute :id, Types::Serial
  #   attribute :name, Types::String
  #   end
  #   end
  #
  #   # access schema from a finalized relation
  #   users.schema
  # @param dataset [Symbol] An optional dataset name
  # @param infer [Boolean] Whether to do an automatic schema inferring
  # @return [Schema]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#94
  def schema(dataset = T.unsafe(nil), as: T.unsafe(nil), infer: T.unsafe(nil), &block); end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#131
  def schema_proc; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#288
  def schemas; end

  # Assign a schema to a relation class
  #
  # @api private
  # @param schema [Schema]
  # @return [Schema]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#126
  def set_schema!(schema); end

  # Include a registered plugin in this relation class
  #
  # @api public
  # @option options
  # @param plugin [Symbol]
  # @param options [Hash]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#252
  def use(plugin, **options); end

  # Define a relation view with a specific schema
  #
  # This method should only be used in cases where a given adapter doesn't
  # support automatic schema projection at run-time.
  #
  # **It's not needed in rom-sql**
  #
  # @api public
  # @overload view
  # @overload view
  # @return [Symbol] view method name
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#190
  def view(*args, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#280
  def view_methods; end

  private

  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/class_interface.rb#318
  def invalid_relation_name?(relation); end
end

# @api public
#
# source://rom-core//lib/rom/relation/class_interface.rb#33
ROM::Relation::ClassInterface::DEFAULT_DATASET_PROC = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://rom-core//lib/rom/relation/class_interface.rb#34
ROM::Relation::ClassInterface::INVALID_RELATIONS_NAMES = T.let(T.unsafe(nil), Array)

# Represents a relation graphs which combines root relation
# with other relation nodes
#
# @api public
#
# source://rom-core//lib/rom/relation/combined.rb#12
class ROM::Relation::Combined < ::ROM::Relation::Graph
  include ::ROM::Relation::Commands

  # Materialize combined relation
  #
  # @api public
  # @return [Loaded]
  #
  # source://rom-core//lib/rom/relation/combined.rb#65
  def call(*args); end

  # Combine with other relations
  #
  # @api public
  # @return [Combined]
  # @see Relation#combine
  #
  # source://rom-core//lib/rom/relation/combined.rb#56
  def combine(*args); end

  # Combine this graph with more nodes
  #
  # @api public
  # @param others [Array<Relation>] A list of relations
  # @return [Graph]
  #
  # source://rom-core//lib/rom/relation/combined.rb#45
  def combine_with(*others); end

  # Return a `:create` command that can insert data from a nested hash.
  #
  # This is limited to `:create` commands only, because automatic restriction
  # for `:update` commands would be quite complex. It's possible that in the
  # future support for `:update` commands will be added though.
  #
  # Another limitation is that it can only work when you're composing
  # parent and its child(ren), which follows canonical hierarchy from your
  # database, so that parents are created first, then their PKs are set
  # as FKs in child tuples. It should be possible to make it work with
  # both directions (parent => child or child => parent), and it would
  # require converting input tuples based on how they depend on each other,
  # which we could do in the future.
  #
  # Expanding functionality of this method is planned for rom 5.0.
  #
  # @api public
  # @raise NotImplementedError when type is not `:create`
  # @see Relation#command
  #
  # source://rom-core//lib/rom/relation/combined.rb#143
  def command(type, *args); end

  # Return a new combined relation with adjusted node returned from a block
  #
  # @api public
  # @example with a node identifier
  #   combine(:tasks).node(:tasks) { |tasks| tasks.prioritized }
  # @example with a nested path
  #   combine(tasks: :tags).node(tasks: :tags) { |tags| tags.where(name: 'red') }
  # @param name [Symbol] The node relation name
  # @return [Relation]
  # @yieldparam relation [Relation] The relation node
  # @yieldreturn [Relation] The new relation node
  #
  # source://rom-core//lib/rom/relation/combined.rb#98
  def node(name, &block); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/combined.rb#154
  def decorate?(other); end

  class << self
    # Create a new relation combined with others
    #
    # @api public
    # @param relation [Relation]
    # @param nodes [Array<Relation>]
    # @return [Combined]
    #
    # source://rom-core//lib/rom/relation/combined.rb#23
    def new(relation, nodes); end
  end
end

# Extensions for relation classes which provide access to commands
#
# @api public
#
# source://rom-core//lib/rom/relation/commands.rb#8
module ROM::Relation::Commands
  # Return a command for the relation
  #
  # This method can either return an existing custom command identified
  # by `type` param, or generate a command dynamically based on relation
  # AST.
  #
  # @api public
  # @example build a simple :create command
  #   users.command(:create)
  # @example build a command which returns multiple results
  #   users.command(:create, result: many)
  # @example build a command which uses a specific plugin
  #   users.command(:create, use: :timestamps)
  # @example build a command which sends results through a custom mapper
  #   users.command(:create, mapper: :my_mapper_identifier)
  # @example return an existing custom command
  #   users.command(:my_custom_command_identifier)
  # @option opts
  # @option opts
  # @option opts
  # @param type [Symbol] The command type (:create, :update or :delete)
  # @param opts [Hash] Additional options
  # @return [ROM::Command]
  #
  # source://rom-core//lib/rom/relation/commands.rb#40
  def command(type, mapper: T.unsafe(nil), use: T.unsafe(nil), plugins_options: T.unsafe(nil), **opts); end
end

# Left-to-right relation composition used for data-pipelining
#
# @api public
#
# source://rom-core//lib/rom/relation/composite.rb#12
class ROM::Relation::Composite < ::ROM::Pipeline::Composite
  include ::ROM::Relation::Materializable

  # Call the pipeline by passing results from left to right
  #
  # Optional args are passed to the left object
  #
  # @api public
  # @return [Loaded]
  #
  # source://rom-core//lib/rom/relation/composite.rb#22
  def [](*args); end

  # Call the pipeline by passing results from left to right
  #
  # Optional args are passed to the left object
  #
  # @api public
  # @return [Loaded]
  #
  # source://rom-core//lib/rom/relation/composite.rb#22
  def call(*args); end

  # @api public
  # @see Relation#map_to
  #
  # source://rom-core//lib/rom/relation/composite.rb#37
  def map_to(klass); end

  private

  # @api private
  # @api private
  # @return [Boolean]
  # @see Pipeline::Proxy#decorate?
  #
  # source://rom-core//lib/rom/relation/composite.rb#48
  def decorate?(response); end
end

# Curried relation is a special relation proxy used by auto-curry mechanism.
#
# When a relation view method is called without all arguments, a curried proxy
# is returned that can be fully applied later on.
#
# Curried relations are typically used for relation composition
#
# @api public
#
# source://rom-core//lib/rom/relation/curried.rb#19
class ROM::Relation::Curried
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Relation::Materializable
  include ::ROM::Pipeline::Operator
  include ::ROM::Pipeline
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # Load relation if args match the arity
  #
  # @api public
  # @return [Loaded, Curried]
  #
  # source://rom-core//lib/rom/relation/curried.rb#49
  def [](*args); end

  # Load relation if args match the arity
  #
  # @api public
  # @return [Loaded, Curried]
  #
  # source://rom-core//lib/rom/relation/curried.rb#49
  def call(*args); end

  # Return if this lazy relation is curried
  #
  # @api private
  # @return [true]
  #
  # source://rom-core//lib/rom/relation/curried.rb#86
  def curried?; end

  # Relations are coercible to an array but a curried relation cannot be coerced
  # When something tries to do this, an exception will be raised
  #
  # @api public
  # @raise ArgumentError
  #
  # source://rom-core//lib/rom/relation/curried.rb#72
  def to_a; end

  # Relations are coercible to an array but a curried relation cannot be coerced
  # When something tries to do this, an exception will be raised
  #
  # @api public
  # @raise ArgumentError
  #
  # source://rom-core//lib/rom/relation/curried.rb#72
  def to_ary; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/relation/curried.rb#98
  def __new__(relation, **new_opts); end

  # @api private
  #
  # source://rom-core//lib/rom/relation/curried.rb#103
  def composite_class; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/curried.rb#108
  def method_missing(meth, *args, **_arg2, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/curried.rb#91
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# Abstract relation graph class
#
# @api public
#
# source://rom-core//lib/rom/relation/graph.rb#16
class ROM::Relation::Graph
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::ROM::Memoizable
  include ::Dry::Core::Equalizer::Methods
  include ::ROM::Relation::Materializable
  include ::ROM::Pipeline::Operator
  include ::ROM::Pipeline
  include ::ROM::Pipeline::Proxy
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook
  extend ::ROM::Memoizable::ClassInterface

  # source://rom-changeset/5.3.0/lib/rom/changeset/extensions/relation.rb#20
  def changeset(*_arg0); end

  # Return if this is a graph relation
  #
  # @api private
  # @return [true]
  #
  # source://rom-core//lib/rom/relation/graph.rb#54
  def graph?; end

  # for compatibility with the pipeline
  #
  # @return [Relation] The root relation
  def left; end

  # Map graph tuples to custom objects
  #
  # @api public
  # @return [Graph]
  # @see Relation#map_to
  #
  # source://rom-core//lib/rom/relation/graph.rb#76
  def map_to(klass); end

  # Map graph tuples via custom mappers
  #
  # @api public
  # @return [Relation::Composite]
  # @see Relation#map_with
  #
  # source://rom-core//lib/rom/relation/graph.rb#65
  def map_with(*names, **opts); end

  # @api private
  # @see Relation#mapper
  #
  # source://rom-core//lib/rom/relation/graph.rb#83
  def mapper; end

  # @return [Array<Relation>] An array with relation nodes
  def right; end

  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_ast; end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  # Rebuild a graph with new nodes
  #
  # @api public
  # @param nodes [Array<Relation>]
  # @return [Graph]
  #
  # source://rom-core//lib/rom/relation/graph.rb#45
  def with_nodes(nodes); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/relation/graph.rb#100
  def composite_class; end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/graph.rb#95
  def decorate?(other); end
end

# Materializes a relation and exposes interface to access the data.
#
# This relation type is returned when a lazy relation is called
#
# @api public
#
# source://rom-core//lib/rom/relation/loaded.rb#10
class ROM::Relation::Loaded
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Loaded] a new instance of Loaded
  #
  # source://rom-core//lib/rom/relation/loaded.rb#36
  def initialize(source, collection = T.unsafe(nil)); end

  # Materialized relation
  #
  # @api private
  # @return [Object]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#33
  def collection; end

  # Yield relation tuples
  #
  # @api public
  # @yield [Hash]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#46
  def each; end

  # Return if loaded relation is empty
  #
  # @api public
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#122
  def empty?; end

  # Return a loaded relation with a new collection
  #
  # @api public
  #
  # source://rom-core//lib/rom/relation/loaded.rb#129
  def new(collection); end

  # Returns a single tuple from the relation if there is one.
  #
  # @api public
  # @raise [ROM::TupleCountMismatchError] if the relation contains more than
  #   one tuple
  #
  # source://rom-core//lib/rom/relation/loaded.rb#58
  def one; end

  # Like [one], but additionally raises an error if the relation is empty.
  #
  # @api public
  # @raise [ROM::TupleCountMismatchError] if the relation does not contain
  #   exactly one tuple
  #
  # source://rom-core//lib/rom/relation/loaded.rb#75
  def one!; end

  # Return a list of values under provided key
  #
  # @api public
  # @example
  #   all_users = rom.relations[:users].call
  #   all_users.pluck(:name)
  #   # ["Jane", "Joe"]
  # @param key [Symbol] The key name
  # @raise KeyError when provided key doesn't exist in any of the tuples
  # @return [Array]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#96
  def pluck(key); end

  # Pluck primary key values
  #
  # This method *may not work* with adapters that don't provide relations
  # that have primary key configured
  #
  # @api public
  # @example
  #   users = rom.relations[:users].call
  #   users.primary_keys
  #   # [1, 2, 3]
  # @return [Array]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#113
  def primary_keys; end

  # Source relation
  #
  # @api private
  # @return [Relation]
  #
  # source://rom-core//lib/rom/relation/loaded.rb#26
  def source; end

  # Coerce loaded relation to an array
  #
  # @api public
  # @return [Array]
  def to_ary(*_arg0); end
end

# Interface for objects that can be materialized into a loaded relation
#
# @api public
#
# source://rom-core//lib/rom/relation/materializable.rb#8
module ROM::Relation::Materializable
  # Yield relation tuples
  #
  # @api public
  # @yield [Hash, Object]
  #
  # source://rom-core//lib/rom/relation/materializable.rb#24
  def each; end

  # Return first tuple from a relation coerced to an array
  #
  # @api public
  # @return [Object]
  #
  # source://rom-core//lib/rom/relation/materializable.rb#57
  def first; end

  # Delegate to loaded relation and return one object
  #
  # @api public
  # @return [Object]
  # @see Loaded#one
  #
  # source://rom-core//lib/rom/relation/materializable.rb#37
  def one; end

  # Delegate to loaded relation and return one object
  #
  # @api public
  # @return [Object]
  # @see Loaded#one
  #
  # source://rom-core//lib/rom/relation/materializable.rb#48
  def one!; end

  # Coerce the relation to an array
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/relation/materializable.rb#14
  def to_a; end

  # Coerce the relation to an array
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/relation/materializable.rb#14
  def to_ary; end
end

# Default no-op output schema which is called in `Relation#each`
#
# @api public
#
# source://rom-core//lib/rom/relation.rb#40
ROM::Relation::NOOP_OUTPUT_SCHEMA = T.let(T.unsafe(nil), Proc)

# Relation name container
#
# This is a simple struct with two fields.
# It handles both relation registration name (i.e. Symbol) and dataset name.
# The reason we need it is a simplification of passing around these two objects.
# It is quite common to have a dataset named differently from a relation
# built on top if you are dealing with a legacy DB and often you need both
# to support things such as associations (rom-sql as an example).
#
# @api private
#
# source://rom-core//lib/rom/relation/name.rb#17
class ROM::Relation::Name
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Name] a new instance of Name
  #
  # source://rom-core//lib/rom/relation/name.rb#61
  def initialize(relation, dataset = T.unsafe(nil), aliaz = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/name.rb#74
  def aliased?; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/name.rb#56
  def aliaz; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/name.rb#69
  def as(aliaz); end

  # Underlying dataset name
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/relation/name.rb#54
  def dataset; end

  # Return inspected relation
  #
  # @api private
  # @return [String]
  #
  # source://rom-core//lib/rom/relation/name.rb#107
  def inspect; end

  # @api private
  #
  # source://rom-core//lib/rom/relation/name.rb#58
  def key; end

  # Relation registration name
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/relation/name.rb#47
  def relation; end

  # Return relation name
  #
  # @api private
  # @return [String]
  #
  # source://rom-core//lib/rom/relation/name.rb#83
  def to_s; end

  # Alias for registration key implicitly called by ROM::Registry
  #
  # @api private
  # @return [Symbol]
  #
  # source://rom-core//lib/rom/relation/name.rb#98
  def to_sym; end

  class << self
    # Coerce an object to a Name instance
    #
    # @api private
    # @return [ROM::Relation::Name]
    #
    # source://rom-core//lib/rom/relation/name.rb#25
    def [](*args); end

    # @api private
    #
    # source://rom-core//lib/rom/relation/name.rb#38
    def cache; end
  end
end

# ViewDSL is exposed in `Relation.view` method
#
# This is used to establish pre-defined relation views with explicit schemas.
# Such views can be used to compose relations together, even from multiple
# adapters. In advanced adapters like rom-sql using view DSL is not required though,
# as relation schemas are dynamic and they always represent current tuple structure.
#
# @api public
#
# source://rom-core//lib/rom/relation/view_dsl.rb#13
class ROM::Relation::ViewDSL
  # @api private
  # @return [ViewDSL] a new instance of ViewDSL
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#27
  def initialize(name, schema, &block); end

  # Return procs captured by the DSL
  #
  # @api private
  # @return [Array]
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#62
  def call; end

  # @api public
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#16
  def name; end

  # @api public
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#24
  def new_schema; end

  # Define a relation block for a relation view
  #
  # @api public
  # @return [Proc]
  # @see Relation::ClassInterface.view
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#53
  def relation(&block); end

  # @api public
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#20
  def relation_block; end

  # Define a schema for a relation view
  #
  # @api public
  # @return [Proc]
  # @see Relation::ClassInterface.view
  #
  # source://rom-core//lib/rom/relation/view_dsl.rb#42
  def schema(&block); end
end

# Relation wrapping other relations
#
# @api public
#
# source://rom-core//lib/rom/relation/wrap.rb#11
class ROM::Relation::Wrap < ::ROM::Relation::Graph
  # Materialize a wrap
  #
  # @api public
  # @return [Loaded]
  # @see Relation#call
  #
  # source://rom-core//lib/rom/relation/wrap.rb#30
  def call(*args); end

  # Return an adapter-specific relation representing a wrap
  #
  # @abstract
  # @api private
  # @raise [NotImplementedError]
  #
  # source://rom-core//lib/rom/relation/wrap.rb#43
  def relation; end

  # Wrap more relations
  #
  # @api public
  # @return [Wrap]
  # @see Relation#wrap
  #
  # source://rom-core//lib/rom/relation/wrap.rb#19
  def wrap(*args); end

  # Return if this is a wrap relation
  #
  # @api private
  # @return [true]
  #
  # source://rom-core//lib/rom/relation/wrap.rb#52
  def wrap?; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/relation/wrap.rb#59
  def decorate?(other); end
end

# source://rom-core//lib/rom/constants.rb#21
class ROM::RelationAlreadyDefinedError < ::StandardError; end

# @api private
#
# source://rom-core//lib/rom/relation_registry.rb#7
class ROM::RelationRegistry < ::ROM::Registry
  # @api private
  # @return [RelationRegistry] a new instance of RelationRegistry
  # @yield [_self, elements]
  # @yieldparam _self [ROM::RelationRegistry] the object that the method was called on
  #
  # source://rom-core//lib/rom/relation_registry.rb#9
  def initialize(elements = T.unsafe(nil), **options); end
end

class ROM::Repository
  extend ::Dry::Core::Constants
  extend ::Dry::Initializer

  # source://rom-repository/5.3.0/lib/rom/repository.rb#107
  def initialize(*_arg0, **_arg1); end

  # source://rom-repository/5.3.0/lib/rom/repository.rb#155
  def inspect; end

  # source://rom-repository/5.3.0/lib/rom/repository.rb#102
  def relations; end

  # source://rom-repository/5.3.0/lib/rom/repository.rb#167
  def session; end

  # source://rom-repository/5.3.0/lib/rom/repository.rb#146
  def transaction(*args, &block); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end
end

# Relation schema
#
# Schemas hold detailed information about relation tuples, including their
# primitive types (String, Integer, Hash, etc. or custom classes), as well as
# various meta information like primary/foreign key and literally any other
# information that a given database adapter may need.
#
# Adapters can extend this class and it can be used in adapter-specific relations.
# In example rom-sql extends schema with Association DSL and many additional
# SQL-specific APIs in schema types.
#
# Schemas are used for projecting canonical relations into other relations and
# every relation object maintains its schema. This means that we always have
# all information about relation tuples, even when a relation was projected and
# diverged from its canonical form.
#
# Furthermore schema attributes know their source relations, which makes it
# possible to merge schemas from multiple relations and maintain information
# about the source relations. In example when two relations are joined, their
# schemas are merged, and we know which attributes belong to which relation.
#
# @api public
#
# source://rom-core//lib/rom/schema/associations_dsl.rb#8
class ROM::Schema
  include ::ROM::Memoizable
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable
  extend ::ROM::Memoizable::ClassInterface
  extend ::ROM::Notifications::Listener
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  # @return [Schema] a new instance of Schema
  # @yield [_self]
  # @yieldparam _self [ROM::Schema] the object that the method was called on
  #
  # source://rom-core//lib/rom/schema.rb#163
  def initialize(*_arg0, **_arg1); end

  # Merge with another schema
  #
  # @api public
  # @param other [Schema] Other schema
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#323
  def +(other); end

  # Return attribute
  #
  # @api public
  # @param key [Symbol] The attribute name
  # @param src [Symbol, Relation::Name] The source relation (for merged schemas)
  # @raise KeyError
  #
  # source://rom-core//lib/rom/schema.rb#222
  def [](key, src = T.unsafe(nil)); end

  # Append more attributes to the schema
  #
  # This returns a new schema instance
  #
  # @api public
  # @param new_attributes [Array<Attribute>]
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#337
  def append(*new_attributes); end

  # Abstract method for creating a new relation based on schema definition
  #
  # This can be used by views to generate a new relation automatically.
  # In example a schema can project a relation, join any additional relations
  # if it includes attributes from other relations etc.
  #
  # Default implementation is a no-op and it simply returns back untouched relation
  #
  # @api public
  # @param relation [Relation]
  # @return [Relation]
  #
  # source://rom-core//lib/rom/schema.rb#183
  def call(relation); end

  # Return if a schema is canonical
  #
  # @api public
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/schema.rb#370
  def canonical?; end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def count_index; end

  # Iterate over schema's attributes
  #
  # @api public
  # @yield [Attribute]
  #
  # source://rom-core//lib/rom/schema.rb#192
  def each(&block); end

  # Check if schema has any attributes
  #
  # @api public
  # @return [TrueClass, FalseClass]
  #
  # source://rom-core//lib/rom/schema.rb#201
  def empty?; end

  # Exclude provided attributes from a schema
  #
  # @api public
  # @param names [*Array] Attribute names
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#253
  def exclude(*names); end

  # Finalize a schema
  #
  # @api private
  # @return [self]
  #
  # source://rom-core//lib/rom/schema.rb#379
  def finalize!(**_opts); end

  # Finalize associations defined in a schema
  #
  # @api private
  # @param relations [RelationRegistry]
  # @return [self]
  #
  # source://rom-core//lib/rom/schema.rb#410
  def finalize_associations!(relations:); end

  # This hook is called when relation is being build during container finalization
  #
  # When block is provided it'll be called just before freezing the instance
  # so that additional ivars can be set
  #
  # @api private
  # @return [self]
  #
  # source://rom-core//lib/rom/schema.rb#393
  def finalize_attributes!(gateway: T.unsafe(nil), relations: T.unsafe(nil)); end

  # Return FK attribute for a given relation name
  #
  # @api public
  # @return [Attribute]
  #
  # source://rom-core//lib/rom/schema.rb#303
  def foreign_key(relation); end

  # Return if a schema includes an attribute with the given name
  #
  # @api public
  # @param name [Symbol] The name of the attribute
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/schema.rb#361
  def key?(name); end

  # Merge with another schema
  #
  # @api public
  # @param other [Schema] Other schema
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#323
  def merge(other); end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def name_index; end

  # Project a schema with renamed attributes using provided prefix
  #
  # @api public
  # @param prefix [Symbol] The name of the prefix
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#280
  def prefix(prefix); end

  # Return primary key attributes
  #
  # @api public
  # @return [Array<Attribute>]
  #
  # source://rom-core//lib/rom/schema.rb#312
  def primary_key; end

  # Project a schema to include only specified attributes
  #
  # @api public
  # @param names [*Array<Symbol, Attribute>] Attribute names
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#242
  def project(*names); end

  # Project a schema with renamed attributes
  #
  # @api public
  # @param mapping [Hash] The attribute mappings
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#264
  def rename(mapping); end

  # @api private
  #
  # source://rom-core//lib/rom/schema.rb#452
  def set!(key, value); end

  # @api private
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def source_index; end

  # @return [Array] Array with schema attributes
  def to_ary; end

  # Return AST for the schema
  #
  # @api public
  # @return [Array]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_ast; end

  # Coerce schema into a <AttributeName=>Attribute> Hash
  #
  # @api public
  # @return [Hash]
  #
  # source://rom-core//lib/rom/schema.rb#210
  def to_h; end

  # Return coercion function using attribute types
  #
  # This is used for `input_schema` in relations, typically commands use it
  # for processing input
  #
  # @api private
  # @return [Dry::Types::Hash]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_input_hash; end

  # Return coercion function using attribute read types
  #
  # This is used for `output_schema` in relations
  #
  # @api private
  # @return [Dry::Types::Hash]
  #
  # source://rom-core//lib/rom/support/memoizable.rb#53
  def to_output_hash; end

  # Return a new schema with uniq attributes
  #
  # @api public
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#346
  def uniq(&block); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  # Return new schema with all attributes marked as prefixed and wrapped
  #
  # This is useful when relations are joined and the right side should be marked
  # as wrapped
  #
  # @api public
  # @param prefix [Symbol] The prefix used for aliasing wrapped attributes
  # @return [Schema]
  #
  # source://rom-core//lib/rom/schema.rb#294
  def wrap(prefix = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/schema.rb#483
  def initialize_primary_key_names; end

  # @api private
  #
  # source://rom-core//lib/rom/schema.rb#478
  def new(attributes); end

  class << self
    # @api private
    #
    # source://rom-core//lib/rom/schema.rb#156
    def attributes(attributes, attr_class); end

    # Builds a representation of the information needed to create an
    # attribute.
    #
    # This representation is consumed by `Schema.define` in order to create
    # the actual attributes.
    #
    # @api private
    # @return [Hash] A hash with `:type` and `:options` keys.
    #
    # source://rom-core//lib/rom/schema.rb#148
    def build_attribute_info(type, **options); end

    # Define a relation schema from plain rom types and optional options
    #
    # Resulting schema will decorate plain rom types with adapter-specific types
    # By default `Attribute` will be used
    #
    # @api public
    # @param name [Relation::Name, Symbol] The schema name, typically ROM::Relation::Name
    # @return [Schema]
    #
    # source://rom-core//lib/rom/schema.rb#130
    def define(name, attributes: T.unsafe(nil), attr_class: T.unsafe(nil), **options); end
  end
end

# Additional schema DSL for definition SQL associations
#
# This DSL is exposed in `associations do .. end` blocks in schema defintions.
#
# @api public
#
# source://rom-core//lib/rom/schema/associations_dsl.rb#14
class ROM::Schema::AssociationsDSL < ::BasicObject
  # @api private
  # @return [AssociationsDSL] a new instance of AssociationsDSL
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#24
  def initialize(source, &block); end

  # Shortcut for many_to_one which sets alias automatically
  #
  # @api public
  # @example with an alias (relation identifier is inferred via pluralization)
  #   belongs_to :user
  # @example with an explicit alias
  #   belongs_to :users, as: :author
  # @return [Associations::ManyToOne]
  # @see #many_to_one
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#154
  def belongs_to(target, **options); end

  # Return an association set for a schema
  #
  # @api private
  # @return [AssociationSet]
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#180
  def call; end

  # Establish a one-to-many association
  #
  # @api public
  # @example using relation identifier
  #   has_many :tasks
  # @example setting custom foreign key name
  #   has_many :tasks, foreign_key: :assignee_id
  # @example with a :through option
  #   # this establishes many-to-many association
  #   has_many :tasks, through: :users_tasks
  # @example using a custom view which overrides default one
  #   has_many :posts, view: :published, override: true
  # @example using aliased association with a custom view
  #   has_many :posts, as: :published_posts, view: :published
  # @example using custom target relation and an alias
  #   has_many :user_posts, relation: :posts, as: :published, view: :published
  # @example using custom target relation
  #   has_many :user_posts, relation: :posts
  # @param target [Symbol] The target relation identifier
  # @param options [Hash] A hash with additional options
  # @return [Associations::OneToMany]
  # @see #many_to_many
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#62
  def has_many(target, **options); end

  # Shortcut for one_to_one which sets alias automatically
  #
  # @api public
  # @example with an alias (relation identifier is inferred via pluralization)
  #   has_one :address
  # @example with an explicit alias and a custom view
  #   has_one :posts, as: :priority_post, view: :prioritized
  # @return [Associations::OneToOne]
  # @see #one_to_one
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#171
  def has_one(target, **options); end

  # Establish a many-to-many association
  #
  # @api public
  # @example using relation identifier
  #   many_to_many :tasks, through: :users_tasks
  # @param target [Symbol] The target relation identifier
  # @param options [Hash] A hash with additional options
  # @return [Associations::ManyToMany]
  # @see #one_to_many
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#120
  def many_to_many(target, **options); end

  # Establish a many-to-one association
  #
  # @api public
  # @example using relation identifier
  #   many_to_one :users, as: :author
  # @param target [Symbol] The target relation identifier
  # @param options [Hash] A hash with additional options
  # @return [Associations::ManyToOne]
  # @see #one_to_many
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#137
  def many_to_one(target, **options); end

  # Establish a one-to-many association
  #
  # @api public
  # @example using relation identifier
  #   has_many :tasks
  # @example setting custom foreign key name
  #   has_many :tasks, foreign_key: :assignee_id
  # @example with a :through option
  #   # this establishes many-to-many association
  #   has_many :tasks, through: :users_tasks
  # @example using a custom view which overrides default one
  #   has_many :posts, view: :published, override: true
  # @example using aliased association with a custom view
  #   has_many :posts, as: :published_posts, view: :published
  # @example using custom target relation and an alias
  #   has_many :user_posts, relation: :posts, as: :published, view: :published
  # @example using custom target relation
  #   has_many :user_posts, relation: :posts
  # @param target [Symbol] The target relation identifier
  # @param options [Hash] A hash with additional options
  # @return [Associations::OneToMany]
  # @see #many_to_many
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#62
  def one_to_many(target, **options); end

  # Establish a one-to-one association
  #
  # @api public
  # @example using relation identifier
  #   one_to_one :addresses, as: :address
  # @example with an intermediate join relation
  #   one_to_one :tasks, as: :priority_task, through: :assignments
  # @param target [Symbol] The target relation identifier
  # @param options [Hash] A hash with additional options
  # @return [Associations::OneToOne]
  # @see #belongs_to
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#87
  def one_to_one(target, **options); end

  # Establish a one-to-one association with a :through option
  #
  # @api public
  # @example
  #   one_to_one_through :users, as: :author, through: :users_posts
  # @return [Associations::OneToOneThrough]
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#103
  def one_to_one_through(target, **options); end

  # @api public
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#21
  def registry; end

  # @api public
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#17
  def source; end

  private

  # @api private
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#187
  def add(association); end

  # @api private
  #
  # source://rom-core//lib/rom/schema/associations_dsl.rb#201
  def dataset_name(name); end
end

# @api public
#
# source://rom-core//lib/rom/schema.rb#63
ROM::Schema::DEFAULT_INFERRER = T.let(T.unsafe(nil), ROM::Schema::Inferrer)

# Schema DSL exposed as `schema { .. }` in relation classes
#
# @api public
#
# source://rom-core//lib/rom/schema/dsl.rb#12
class ROM::Schema::DSL < ::BasicObject
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  # @return [DSL] a new instance of DSL
  #
  # source://rom-core//lib/rom/schema/dsl.rb#58
  def initialize(*_arg0, **_arg1, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/schema/dsl.rb#176
  def app_plugin(plugin, options = T.unsafe(nil)); end

  # Define associations for a relation
  #
  # @api public
  # @example
  #   class Users < ROM::Relation[:sql]
  #   schema(infer: true) do
  #   associations do
  #   has_many :tasks
  #   has_many :posts
  #   has_many :posts, as: :priority_posts, view: :prioritized
  #   belongs_to :account
  #   end
  #   end
  #   end
  #
  #   class Posts < ROM::Relation[:sql]
  #   schema(infer: true) do
  #   associations do
  #   belongs_to :users, as: :author
  #   end
  #   end
  #
  #   view(:prioritized) do
  #   where { priority <= 3 }
  #   end
  #   end
  # @return [AssociationDSL]
  #
  # source://rom-core//lib/rom/schema/dsl.rb#115
  def associations(&block); end

  # @api public
  #
  # source://rom-core//lib/rom/schema/dsl.rb#55
  def associations_dsl; end

  # Defines a relation attribute with its type and options.
  #
  # When only options are given, type is left as nil. It makes
  # sense when it is used alongside an schema inferrer, which will
  # populate the type.
  #
  # @api public
  # @see Relation.schema
  #
  # source://rom-core//lib/rom/schema/dsl.rb#77
  def attribute(name, type_or_options, options = T.unsafe(nil)); end

  # @api public
  #
  # source://rom-core//lib/rom/schema/dsl.rb#43
  def attributes; end

  # Builds a representation of the information needed to create an
  # attribute. It returns a hash with `:type` and `:options` keys.
  #
  # @api private
  # @return [Hash]
  # @see [Schema.build_attribute_info]
  #
  # source://rom-core//lib/rom/schema/dsl.rb#127
  def build_attribute_info(name, type_or_options, options = T.unsafe(nil)); end

  # Builds a type instance from base type and meta options
  #
  # @api private
  # @return [Dry::Types::Type] Type instance
  #
  # source://rom-core//lib/rom/schema/dsl.rb#143
  def build_type(type, options = T.unsafe(nil)); end

  # @api private
  #
  # source://rom-core//lib/rom/schema/dsl.rb#182
  def call(&block); end

  # @api public
  #
  # source://rom-core//lib/rom/schema/dsl.rb#51
  def definition; end

  def extend(*_arg0); end
  def method(_arg0); end

  # @api private
  #
  # source://rom-core//lib/rom/schema/dsl.rb#194
  def plugin_options(plugin); end

  # @api public
  #
  # source://rom-core//lib/rom/schema/dsl.rb#47
  def plugins; end

  # Specify which key(s) should be the primary key
  #
  # @api public
  #
  # source://rom-core//lib/rom/schema/dsl.rb#156
  def primary_key(*names); end

  # Enables for the schema
  #
  # @api public
  # @param plugin_name [Symbol] Plugin name
  # @param options [Hash] Plugin options
  #
  # source://rom-core//lib/rom/schema/dsl.rb#170
  def use(plugin_name, options = T.unsafe(nil)); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # Return schema opts
  #
  # @api private
  # @return [Hash]
  #
  # source://rom-core//lib/rom/schema/dsl.rb#205
  def opts; end
end

# @api public
#
# source://rom-core//lib/rom/schema/dsl.rb#13
ROM::Schema::DSL::KERNEL_METHODS = T.let(T.unsafe(nil), Array)

# @api public
#
# source://rom-core//lib/rom/schema.rb#61
ROM::Schema::EMPTY_ASSOCIATION_SET = T.let(T.unsafe(nil), ROM::AssociationSet)

# @api public
#
# source://rom-core//lib/rom/schema.rb#74
ROM::Schema::HASH_SCHEMA = T.let(T.unsafe(nil), Dry::Types::Hash::Constructor)

# @api private
#
# source://rom-core//lib/rom/schema/inferrer.rb#6
class ROM::Schema::Inferrer
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  #
  # source://rom-core//lib/rom/schema/inferrer.rb#59
  def call(schema, gateway); end

  # @api private
  # @raise [MissingAttributesError]
  #
  # source://rom-core//lib/rom/schema/inferrer.rb#74
  def check_all_attributes_defined(schema, all_known, not_inferred); end

  # @return [Boolean]
  def enabled?; end

  # @api private
  #
  # source://rom-core//lib/rom/schema/inferrer.rb#81
  def merge_attributes(defined, inferred); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end
end

# @api private
#
# source://rom-core//lib/rom/schema/inferrer.rb#36
ROM::Schema::Inferrer::DEFAULT_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rom-core//lib/rom/schema/inferrer.rb#27
class ROM::Schema::Inferrer::MissingAttributesError < ::StandardError
  # source://rom-core//lib/rom/schema/inferrer.rb#28
  def initialize(name, attributes); end
end

# @api private
#
# source://rom-core//lib/rom/schema_plugin.rb#7
class ROM::SchemaPlugin < ::ROM::Plugin
  # Extends a DSL instance with a module provided by the plugin
  #
  # @api private
  # @param dsl [ROM::Schema::DSL]
  #
  # source://rom-core//lib/rom/schema_plugin.rb#13
  def extend_dsl(dsl); end
end

# Setup objects collect component classes during setup/finalization process
#
# @api public
#
# source://rom-core//lib/rom/setup.rb#9
class ROM::Setup
  # @api private
  # @return [Setup] a new instance of Setup
  #
  # source://rom-core//lib/rom/setup.rb#32
  def initialize(notifications); end

  # Enable auto-registration for a given setup object
  #
  # @api public
  # @option options
  # @param directory [String, Pathname] The root path to components
  # @param options [Hash]
  # @return [Setup]
  #
  # source://rom-core//lib/rom/setup.rb#49
  def auto_registration(directory, **options); end

  # @api private
  # @return [Array] registered command subclasses
  #
  # source://rom-core//lib/rom/setup.rb#23
  def command_classes; end

  # @api private
  # @return [Array] registered mapper subclasses
  #
  # source://rom-core//lib/rom/setup.rb#18
  def mapper_classes; end

  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#29
  def notifications; end

  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#26
  def plugins; end

  # Command sub-classes are being registered with this method during setup
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#74
  def register_command(*klasses); end

  # Mapper sub-classes are being registered with this method during setup
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#67
  def register_mapper(*klasses); end

  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#79
  def register_plugin(plugin); end

  # Relation sub-classes are being registered with this method during setup
  #
  # @api private
  #
  # source://rom-core//lib/rom/setup.rb#60
  def register_relation(*klasses); end

  # @api private
  # @return [Array] registered relation subclasses
  #
  # source://rom-core//lib/rom/setup.rb#13
  def relation_classes; end
end

# Simple data-struct class
#
# ROM structs are plain data structures loaded by repositories.
# They implement Hash protocol which means that they can be used
# in places where Hash-like objects are supported.
#
# Repositories define subclasses of ROM::Struct automatically, they are
# defined in the ROM::Struct namespace by default, but you set it up
# to use your namespace/module as well.
#
# Structs are based on dry-struct gem, they include `schema` with detailed information
# about attribute types returned from relations, thus can be introspected to build
# additional functionality when desired.
#
# There is a caveat you should know about when working with structs. Struct classes
# have names but at the same time they're anonymous, i.e. you can't get the User struct class
# with ROM::Struct::User. ROM will create as many struct classes for User as needed,
# they all will have the same name and ROM::Struct::User will be the common parent class for
# them. Combined with the ability to provide your own namespace for structs this enables to
# pre-define the parent class.
#
# @api public
# @example accessing relation struct model
#   rom = ROM.container(:sql, 'sqlite::memory') do |conf|
#   conf.default.create_table(:users) do
#   primary_key :id
#   column :name, String
#   end
#   end
#
#   class UserRepo < ROM::Repository[:users]
#   end
#
#   user_repo = UserRepo.new(rom)
#
#   # get auto-generated User struct
#   model = user_repo.users.mapper.model
#   # => ROM::Struct::User
#
#   # see struct's schema attributes
#
#   # model.schema.key(:id)
#   # => #<Dry::Types[id: Nominal<Integer meta={primary_key: true, source: :users}>]>
#
#   model.schema[:name]
#   # => #<Dry::Types[name: Sum<Nominal<NilClass> | Nominal<String> meta={source: :users}>]>
# @example passing a namespace with an existing parent class
#   module Entities
#   class User < ROM::Struct
#   def upcased_name
#   name.upcase
#   end
#   end
#   end
#
#   class UserRepo < ROM::Repository[:users]
#   struct_namespace Entities
#   end
#
#   user_repo = UserRepo.new(rom)
#   user = user_repo.users.by_pk(1).one!
#   user.name # => "Jane"
#   user.upcased_name # => "JANE"
# @see http://dry-rb.org/gems/dry-struct dry-struct
# @see http://dry-rb.org/gems/dry-types dry-types
#
# source://rom-core//lib/rom/struct.rb#72
class ROM::Struct < ::Dry::Struct
  extend ::Dry::Core::DescendantsTracker

  # Return attribute value
  #
  # @api public
  # @param name [Symbol] The attribute name
  #
  # source://rom-core//lib/rom/struct.rb#89
  def fetch(name); end

  private

  # @api public
  #
  # source://rom-core//lib/rom/struct.rb#100
  def method_missing(*_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://rom-core//lib/rom/struct.rb#94
  def respond_to_missing?(*_arg0); end
end

# @api public
#
# source://rom-core//lib/rom/struct.rb#73
class ROM::Struct::MissingAttribute < ::NameError
  # source://rom-core//lib/rom/struct.rb#74
  def initialize(&block); end

  # source://rom-core//lib/rom/struct.rb#79
  def message; end
end

# @api private
#
# source://rom-core//lib/rom/struct_compiler.rb#14
class ROM::StructCompiler < ::Dry::Types::Compiler
  include ::Dry::Initializer::Mixin::Root
  include ::ROM::Initializer::InstanceMethods
  extend ::ROM::Initializer
  extend ::Dry::Initializer
  extend ::ROM::Initializer::DefineWithHook

  # @api private
  # @return [StructCompiler] a new instance of StructCompiler
  #
  # source://rom-core//lib/rom/struct_compiler.rb#21
  def initialize(*_arg0, **_arg1); end

  # Build a struct class based on relation header ast
  #
  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#30
  def [](*args); end

  # Build a struct class based on relation header ast
  #
  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#30
  def call(*args); end

  # source://rom-core//lib/rom/initializer.rb#37
  def with(**new_options); end

  private

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#98
  def build_class(name, parent, ns, &block); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#105
  def class_name(name); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#71
  def visit_attribute(node); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#85
  def visit_constrained(node); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#78
  def visit_constructor(node); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#92
  def visit_enum(node); end

  # @api private
  #
  # source://rom-core//lib/rom/struct_compiler.rb#49
  def visit_relation(node); end
end

# @api private
#
# source://rom-core//lib/rom/transaction.rb#5
class ROM::Transaction
  # Unconditionally roll back the current transaction
  #
  # @api public
  # @raise [Rollback]
  #
  # source://rom-core//lib/rom/transaction.rb#19
  def rollback!; end

  # @api private
  #
  # source://rom-core//lib/rom/transaction.rb#10
  def run(_opts = T.unsafe(nil)); end
end

# @api private
#
# source://rom-core//lib/rom/transaction.rb#24
ROM::Transaction::NoOp = T.let(T.unsafe(nil), ROM::Transaction)

# @api private
#
# source://rom-core//lib/rom/transaction.rb#7
class ROM::Transaction::Rollback < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#28
class ROM::TupleCountMismatchError < ::ROM::CommandError; end

# Default namespace with built-in attribute types
#
#
# @api public
#
# source://rom-core//lib/rom/types.rb#12
module ROM::Types
  extend ::Dry::Types::BuilderMethods
  extend ::Dry::Core::Deprecations::Interface

  mixes_in_class_methods ::ROM::Types::Methods
  mixes_in_class_methods ::Dry::Types::BuilderMethods

  class << self
    # @api private
    # @private
    #
    # source://rom-core//lib/rom/types.rb#16
    def included(other); end
  end
end

# Type extensions
#
# @api public
#
# source://rom-core//lib/rom/types.rb#24
module ROM::Types::Methods
  # Shortcut for defining a foreign key attribute type
  #
  # @api public
  # @param relation [Symbol] The name of the target relation
  # @param type [Object] The type of an attribute
  # @return [Dry::Types::Nominal]
  #
  # source://rom-core//lib/rom/types.rb#33
  def ForeignKey(relation, type = T.unsafe(nil)); end
end

# source://rom-core//lib/rom/constants.rb#29
class ROM::UnknownPluginError < ::StandardError; end

# source://rom-core//lib/rom/constants.rb#30
class ROM::UnsupportedRelationError < ::StandardError; end

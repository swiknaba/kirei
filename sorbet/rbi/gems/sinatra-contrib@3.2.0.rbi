# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sinatra-contrib` gem.
# Please instead update this file by running `bin/tapioca gem sinatra-contrib`.

# source://sinatra-contrib//lib/sinatra/namespace.rb#6
module Sinatra
  class << self
    # source://sinatra/3.2.0/lib/sinatra/base.rb#2107
    def helpers(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2095
    def new(base = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2102
    def register(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2112
    def use(*args, &block); end
  end
end

class Sinatra::Application < ::Sinatra::Base
  extend ::Sinatra::Namespace
  extend ::Sinatra::Namespace::SharedMethods
  extend ::Sinatra::Namespace::BaseMethods
end

# = Sinatra::Namespace
#
# <tt>Sinatra::Namespace</tt> is an extension that adds namespaces to an
# application.  This namespaces will allow you to share a path prefix for the
# routes within the namespace, and define filters, conditions and error
# handlers exclusively for them.  Besides that, you can also register helpers
# and extensions that will be used only within the namespace.
#
# == Usage
#
# Once you have loaded the extension (see below), you can use the +namespace+
# method to define namespaces in your application.
#
# You can define a namespace by a path prefix:
#
#     namespace '/blog' do
#       get { haml :blog }
#       get '/:entry_permalink' do
#         @entry = Entry.find_by_permalink!(params[:entry_permalink])
#         haml :entry
#       end
#
#       # More blog routes...
#     end
#
# by a condition:
#
#     namespace :host_name => 'localhost' do
#       get('/admin/dashboard') { haml :dashboard }
#       get('/admin/login')     { haml :login }
#
#       # More admin routes...
#     end
#
# or both:
#
#     namespace '/admin', :host_name => 'localhost' do
#       get('/dashboard')  { haml :dashboard }
#       get('/login')      { haml :login }
#       post('/login')     { login_user }
#
#       # More admin routes...
#     end
#
# Regex is also accepted:
#
#     namespace /\/posts\/([^\/&?]+)\// do
#       get { haml :blog }
#
#       # More blog routes...
#     end
#
# When you define a filter or an error handler, or register an extension or a
# set of helpers within a namespace, they only affect the routes defined in
# it.  For instance, lets define a before filter to prevent the access of
# unauthorized users to the admin section of the application:
#
#     namespace '/admin' do
#       helpers AdminHelpers
#       before  { authenticate unless request.path_info == '/admin/login' }
#
#       get '/dashboard' do
#         # Only authenticated users can access here...
#         haml :dashboard
#       end
#
#       # More admin routes...
#     end
#
#     get '/' do
#       # Any user can access here...
#       haml :index
#     end
#
# Well, they actually also affect the nested namespaces:
#
#     namespace '/admin' do
#       helpers AdminHelpers
#       before  { authenticate unless request.path_info == '/admin/login' }
#
#       namespace '/users' do
#         get do
#           # Only authenticated users can access here...
#           @users = User.all
#           haml :users
#         end
#
#         # More user admin routes...
#       end
#
#       # More admin routes...
#     end
#
# Redirecting within the namespace can be done using redirect_to:
#
#     namespace '/admin' do
#       get '/foo'  do
#         redirect_to '/bar' # Redirects to /admin/bar
#       end
#
#       get '/foo' do
#         redirect '/bar' # Redirects to /bar
#       end
#     end
#
# === Classic Application Setup
#
# To be able to use namespaces in a classic application all you need to do is
# require the extension:
#
#     require "sinatra"
#     require "sinatra/namespace"
#
#     namespace '/users' do
#     end
#
# === Modular Application Setup
#
# To be able to use namespaces in a modular application all you need to do is
# require the extension, and then, register it:
#
#     require "sinatra/base"
#     require "sinatra/namespace"
#
#     class MyApp < Sinatra::Base
#       register Sinatra::Namespace
#
#       namespace '/users' do
#       end
#     end
#
# === Within an extension
#
# To be able to use namespaces within an extension, you need to first create
# an extension. This includes defining the `registered(app)` method in the
# module.
#
#     require 'sinatra/base' # For creating Sinatra extensions
#     require 'sinatra/namespace' # To create namespaces
#
#     module Zomg # Keep everything under "Zomg" namespace for sanity
#       module Routes # Define a new "Routes" module
#
#         def self.registered(app)
#           # First, register the Namespace extension
#           app.register Sinatra::Namespace
#
#           # This defines an `/api` namespace on the application
#           app.namespace '/api' do
#             get '/users' do
#               # do something with `GET "/api/users"`
#             end
#           end
#
#         end
#       end
#
#       # Lastly, register the extension to use in our app
#       Sinatra.register Routes
#     end
#
# In order to use this extension, is the same as any other Sinatra extension:
#
#     module Zomg
#       # Define our app class, we use modular app for this example
#       class App < Sinatra::Base
#         # this gives us all the namespaces we defined earlier
#         register Routes
#
#         get '/' do
#           "Welcome to my application!"
#         end
#       end
#     end
#
#     Zomg::App.run! # Don't forget to start your app ;)
#
# Phew! That was a mouthful.
#
# I hope that helps you use `Sinatra::Namespace` in every way imaginable!
#
# source://sinatra-contrib//lib/sinatra/namespace.rb#188
module Sinatra::Namespace
  class << self
    # @private
    #
    # source://sinatra-contrib//lib/sinatra/namespace.rb#368
    def extended(base); end

    # source://sinatra-contrib//lib/sinatra/namespace.rb#189
    def new(base, pattern, conditions = T.unsafe(nil), &block); end
  end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#364
module Sinatra::Namespace::BaseMethods
  include ::Sinatra::Namespace::SharedMethods
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#207
module Sinatra::Namespace::InstanceMethods
  # source://sinatra-contrib//lib/sinatra/namespace.rb#216
  def redirect_to(uri, *args); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#208
  def settings; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#212
  def template_cache; end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#227
module Sinatra::Namespace::NamespacedMethods
  include ::Sinatra::Namespace::SharedMethods

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def after(*a, &b); end

  # Returns the value of attribute base.
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#229
  def base; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def before(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def delete(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#303
  def disable(*opts); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#299
  def enable(*opts); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#273
  def error(*codes, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#265
  def errors; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def get(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def head(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#243
  def helpers(*extensions, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#257
  def invoke_hook(name, *args); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#314
  def layout(name = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#269
  def namespace_errors; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#261
  def not_found(&block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def options(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def patch(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#318
  def pattern; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def post(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def put(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#248
  def register(*extensions, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#285
  def respond_to(*args); end

  # @raise [ArgumentError]
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#291
  def set(key, value = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#307
  def template(name, &block); end

  # Returns the value of attribute templates.
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#229
  def templates; end

  private

  # source://sinatra-contrib//lib/sinatra/namespace.rb#324
  def app; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#328
  def compile(pattern, conditions, default_pattern = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#355
  def method_missing(method, *args, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#347
  def prefixed(method, pattern = T.unsafe(nil), conditions = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#340
  def prefixed_path(a, b); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#359
  def respond_to?(method, include_private = T.unsafe(nil)); end

  class << self
    # source://sinatra-contrib//lib/sinatra/namespace.rb#237
    def prefixed(*names); end
  end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#231
Sinatra::Namespace::NamespacedMethods::ALLOWED_ENGINES = T.let(T.unsafe(nil), Array)

# source://sinatra-contrib//lib/sinatra/namespace.rb#221
module Sinatra::Namespace::SharedMethods
  # source://sinatra-contrib//lib/sinatra/namespace.rb#222
  def namespace(pattern, conditions = T.unsafe(nil), &block); end
end

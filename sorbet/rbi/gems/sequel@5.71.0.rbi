# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sequel` gem.
# Please instead update this file by running `bin/tapioca gem sequel`.

# The round_timestamps extension will automatically round timestamp
# values to the database's supported level of precision before literalizing
# them.
#
# For example, if the database supports millisecond precision, and you give
# it a Time value with microsecond precision, it will round it appropriately:
#
#   Time.at(1405341161.917999982833862)
#   # default: 2014-07-14 14:32:41.917999
#   # with extension: 2014-07-14 14:32:41.918000
#
# The round_timestamps extension correctly deals with databases that support
# millisecond or second precision.  In addition to handling Time values, it
# also handles DateTime values and Sequel::SQLTime values (for the TIME type).
#
# To round timestamps for a single dataset:
#
#   ds = ds.extension(:round_timestamps)
#
# To round timestamps for all datasets on a single database:
#
#   DB.extension(:round_timestamps)
#
# Related module: Sequel::Dataset::RoundTimestamps
#
# source://sequel//lib/sequel/core.rb#27
module Sequel
  include ::Sequel::SQL::Constants
  extend ::Sequel::SequelMethods
  extend ::Sequel::SQL::Builders
  extend ::Sequel::SQL::OperatorBuilders

  class << self
    # source://sequel//lib/sequel/model/base.rb#139
    def Model(source); end

    # Allow nicer syntax for creating Sequel expressions:
    #
    #   Sequel[1]     # => Sequel::SQL::NumericExpression: 1
    #   Sequel["a"]   # => Sequel::SQL::StringExpression: 'a'
    #   Sequel[:a]    # => Sequel::SQL::Identifier: "a"
    #   Sequel[a: 1]  # => Sequel::SQL::BooleanExpression: ("a" = 1)
    #
    # source://sequel//lib/sequel/sql.rb#469
    def [](arg = T.unsafe(nil), &block); end

    # source://sequel//lib/sequel/core.rb#419
    def ado(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def amalgalite(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def ibmdb(*args, &block); end

    # Yield the Inflections module if a block is given, and return
    # the Inflections module.
    #
    # @yield [Inflections]
    #
    # source://sequel//lib/sequel/model/inflections.rb#6
    def inflections; end

    # source://sequel//lib/sequel/core.rb#419
    def jdbc(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def mock(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def mysql(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def mysql2(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def odbc(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def oracle(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def postgres(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def sqlanywhere(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def sqlite(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def tinytds(*args, &block); end

    # source://sequel//lib/sequel/core.rb#419
    def trilogy(*args, &block); end

    # The version of Sequel you are using, as a string (e.g. "2.11.0")
    #
    # source://sequel//lib/sequel/version.rb#22
    def version; end
  end
end

# Hash of adapters that have been used. The key is the adapter scheme
# symbol, and the value is the Database subclass.
#
# source://sequel//lib/sequel/database.rb#6
Sequel::ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

# The +ASTTransformer+ class is designed to handle the abstract syntax trees
# that Sequel uses internally and produce modified copies of them.  By itself
# it only produces a straight copy.  It's designed to be subclassed and have
# subclasses returned modified copies of the specific nodes that need to
# be modified.
#
# source://sequel//lib/sequel/ast_transformer.rb#9
class Sequel::ASTTransformer
  # Return +obj+ or a potentially transformed version of it.
  #
  # source://sequel//lib/sequel/ast_transformer.rb#11
  def transform(obj); end

  private

  # Recursive version that handles all of Sequel's internal object types
  # and produces copies of them.
  #
  # source://sequel//lib/sequel/ast_transformer.rb#19
  def v(o); end
end

# source://sequel//lib/sequel/exceptions.rb#24
class Sequel::AdapterNotFound < ::Sequel::Error; end

# The <tt>Sequel::BasicObject</tt> class is just like the
# default +BasicObject+ class, except that missing constants are resolved in
# +Object+.  This allows the virtual row support to work with classes
# without prefixing them with ::, such as:
#
#   DB[:bonds].where{maturity_date > Time.now}
#
# source://sequel//lib/sequel/sql.rb#10
class Sequel::BasicObject < ::BasicObject
  class << self
    # Lookup missing constants in <tt>::Object</tt>
    #
    # source://sequel//lib/sequel/sql.rb#12
    def const_missing(name); end
  end
end

# source://sequel//lib/sequel/exceptions.rb#55
class Sequel::CheckConstraintViolation < ::Sequel::ConstraintViolation; end

# The base connection pool class, which all other connection pools are based
# on.  This class is not instantiated directly, but subclasses should at
# the very least implement the following API:
#
# initialize(Database, Hash) :: Initialize using the passed Sequel::Database
#                               object and options hash.
# hold(Symbol, &block) :: Yield a connection object (obtained from calling
#                         the block passed to +initialize+) to the current block. For sharded
#                         connection pools, the Symbol passed is the shard/server to use.
# disconnect(Symbol) :: Disconnect the connection object.  For sharded
#                       connection pools, the Symbol passed is the shard/server to use.
# servers :: An array of shard/server symbols for all shards/servers that this
#            connection pool recognizes.
# size :: an integer representing the total number of connections in the pool,
#         or for the given shard/server if sharding is supported.
# max_size :: an integer representing the maximum size of the connection pool,
#             or the maximum size per shard/server if sharding is supported.
#
# For sharded connection pools, the sharded API adds the following methods:
#
# add_servers(Array of Symbols) :: start recognizing all shards/servers specified
#                                  by the array of symbols.
# remove_servers(Array of Symbols) :: no longer recognize all shards/servers
#                                     specified by the array of symbols.
#
# source://sequel//lib/sequel/connection_pool.rb#27
class Sequel::ConnectionPool
  extend ::Sequel::ConnectionPool::ClassMethods

  # Instantiates a connection pool with the given Database and options.
  #
  # @return [ConnectionPool] a new instance of ConnectionPool
  #
  # source://sequel//lib/sequel/connection_pool.rb#111
  def initialize(db, opts = T.unsafe(nil)); end

  # The after_connect proc used for this pool.  This is called with each new
  # connection made, and is usually used to set custom per-connection settings.
  # Deprecated.
  #
  # source://sequel//lib/sequel/connection_pool.rb#88
  def after_connect; end

  # Override the after_connect proc for the connection pool. Deprecated.
  # Disables support for shard-specific :after_connect and :connect_sqls if used.
  #
  # source://sequel//lib/sequel/connection_pool.rb#92
  def after_connect=(v); end

  # An array of sql strings to execute on each new connection. Deprecated.
  #
  # source://sequel//lib/sequel/connection_pool.rb#98
  def connect_sqls; end

  # Override the connect_sqls for the connection pool. Deprecated.
  # Disables support for shard-specific :after_connect and :connect_sqls if used.
  #
  # source://sequel//lib/sequel/connection_pool.rb#102
  def connect_sqls=(v); end

  # The Sequel::Database object tied to this connection pool.
  #
  # source://sequel//lib/sequel/connection_pool.rb#108
  def db; end

  # The Sequel::Database object tied to this connection pool.
  #
  # source://sequel//lib/sequel/connection_pool.rb#108
  def db=(_arg0); end

  # An array of symbols for all shards/servers, which is a single <tt>:default</tt> by default.
  #
  # source://sequel//lib/sequel/connection_pool.rb#120
  def servers; end

  private

  # Remove the connection from the pool.  For threaded connections, this should be
  # called without the mutex, because the disconnection may block.
  #
  # source://sequel//lib/sequel/connection_pool.rb#128
  def disconnect_connection(conn); end

  # Whether the given exception is a disconnect exception.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/connection_pool.rb#133
  def disconnect_error?(exception); end

  # Return a new connection by calling the connection proc with the given server name,
  # and checking for connection errors.
  #
  # source://sequel//lib/sequel/connection_pool.rb#139
  def make_new(server); end
end

# Class methods used to return an appropriate pool subclass, separated
# into a module for easier overridding by extensions.
#
# source://sequel//lib/sequel/connection_pool.rb#42
module Sequel::ConnectionPool::ClassMethods
  # Return a pool subclass instance based on the given options.  If a <tt>:pool_class</tt>
  # option is provided is provided, use that pool class, otherwise
  # use a new instance of an appropriate pool subclass based on the
  # +SEQUEL_DEFAULT_CONNECTION_POOL+ environment variable if set, or
  # the <tt>:single_threaded</tt> and <tt>:servers</tt> options, otherwise.
  #
  # source://sequel//lib/sequel/connection_pool.rb#48
  def get_pool(db, opts = T.unsafe(nil)); end

  private

  # Return a connection pool class based on the given options.
  #
  # source://sequel//lib/sequel/connection_pool.rb#55
  def connection_pool_class(opts); end
end

# source://sequel//lib/sequel/connection_pool.rb#28
Sequel::ConnectionPool::OPTS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/connection_pool.rb#29
Sequel::ConnectionPool::POOL_CLASS_MAP = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/exceptions.rb#50
class Sequel::ConstraintViolation < ::Sequel::DatabaseError; end

# Array of all databases to which Sequel has connected.  If you are
# developing an application that can connect to an arbitrary number of
# databases, delete the database objects from this (or use the :keep_reference
# Database option or a block when connecting) or they will not get
# garbage collected.
#
# source://sequel//lib/sequel/database.rb#18
Sequel::DATABASES = T.let(T.unsafe(nil), Array)

# Proc that is instance_execed to create the default inflections for both the
# model inflector and the inflector extension.
#
# source://sequel//lib/sequel/model/default_inflections.rb#6
Sequel::DEFAULT_INFLECTIONS_PROC = T.let(T.unsafe(nil), Proc)

# A Database object represents a virtual connection to a database.
# The Database class is meant to be subclassed by database adapters in order
# to provide the functionality needed for executing queries.
#
# source://sequel//lib/sequel/database.rb#23
class Sequel::Database
  # Constructs a new instance of a database connection with the specified
  # options hash.
  #
  # Accepts the following options:
  # :after_connect :: A callable object called after each new connection is made, with the
  #                   connection object (and server argument if the callable accepts 2 arguments),
  #                   useful for customizations that you want to apply to all connections.
  # :before_preconnect :: Callable that runs after extensions from :preconnect_extensions are loaded,
  #                       but before any connections are created.
  # :cache_schema :: Whether schema should be cached for this Database instance
  # :check_string_typecast_bytesize :: Whether to check the bytesize of strings before typecasting.
  # :connect_sqls :: An array of sql strings to execute on each new connection, after :after_connect runs.
  # :default_string_column_size :: The default size of string columns, 255 by default.
  # :extensions :: Extensions to load into this Database instance.  Can be a symbol, array of symbols,
  #                or string with extensions separated by columns.  These extensions are loaded after
  #                connections are made by the :preconnect option.
  # :keep_reference :: Whether to keep a reference to this instance in Sequel::DATABASES, true by default.
  # :logger :: A specific logger to use.
  # :loggers :: An array of loggers to use.
  # :log_connection_info :: Whether connection information should be logged when logging queries.
  # :log_warn_duration :: The number of elapsed seconds after which queries should be logged at warn level.
  # :name :: A name to use for the Database object, displayed in PoolTimeout.
  # :preconnect :: Automatically create the maximum number of connections, so that they don't
  #                need to be created as needed.  This is useful when connecting takes a long time
  #                and you want to avoid possible latency during runtime.
  #                Set to :concurrently to create the connections in separate threads. Otherwise
  #                they'll be created sequentially.
  # :preconnect_extensions :: Similar to the :extensions option, but loads the extensions before the
  #                           connections are made by the :preconnect option.
  # :quote_identifiers :: Whether to quote identifiers.
  # :servers :: A hash specifying a server/shard specific options, keyed by shard symbol.
  # :single_threaded :: Whether to use a single-threaded connection pool.
  # :sql_log_level :: Method to use to log SQL to a logger, :info by default.
  #
  # For sharded connection pools, :after_connect and :connect_sqls can be specified per-shard.
  #
  # All options given are also passed to the connection pool.  Additional options respected by
  # the connection pool are :max_connections, :pool_timeout, :servers, and :servers_hash.  See the
  # connection pool documentation for details.
  #
  # @return [Database] a new instance of Database
  #
  # source://sequel//lib/sequel/database/misc.rb#138
  def initialize(opts = T.unsafe(nil)); end

  # Runs the supplied SQL statement string on the database server.
  # Returns self so it can be safely chained:
  #
  #   DB << "UPDATE albums SET artist_id = NULL" << "DROP TABLE artists"
  #
  # source://sequel//lib/sequel/database/query.rb#25
  def <<(sql); end

  # Returns a dataset for the database. If the first argument is a string,
  # the method acts as an alias for Database#fetch, returning a dataset for
  # arbitrary SQL, with or without placeholders:
  #
  #   DB['SELECT * FROM items'].all
  #   DB['SELECT * FROM items WHERE name = ?', my_name].all
  #
  # Otherwise, acts as an alias for Database#from, setting the primary
  # table for the dataset:
  #
  #   DB[:items].sql #=> "SELECT * FROM items"
  #
  # source://sequel//lib/sequel/database/dataset.rb#21
  def [](*args); end

  # Returns the scheme symbol for this instance's class, which reflects which
  # adapter is being used.  In some cases, this can be the same as the
  # +database_type+ (for native adapters), in others (i.e. adapters with
  # subadapters), it will be different.
  #
  #   Sequel.connect('jdbc:postgres://...').adapter_scheme
  #   # => :jdbc
  #
  # source://sequel//lib/sequel/database/connecting.rb#161
  def adapter_scheme; end

  # Adds a column to the specified table. This method expects a column name,
  # a datatype and optionally a hash with additional constraints and options:
  #
  #   DB.add_column :items, :name, String, unique: true, null: false
  #   DB.add_column :items, :category, String, default: 'ruby'
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#25
  def add_column(table, *args); end

  # Adds an index to a table for the given columns:
  #
  #   DB.add_index :posts, :title
  #   DB.add_index :posts, [:author, :title], unique: true
  #
  # Options:
  #
  # :ignore_errors :: Ignore any DatabaseErrors that are raised
  # :name :: Name to use for index instead of default
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#40
  def add_index(table, columns, options = T.unsafe(nil)); end

  # Dynamically add new servers or modify server options at runtime. Also adds new
  # servers to the connection pool. Only usable when using a sharded connection pool.
  #
  # servers argument should be a hash with server name symbol keys and hash or
  # proc values.  If a servers key is already in use, it's value is overridden
  # with the value provided.
  #
  #   DB.add_servers(f: {host: "hash_host_f"})
  #
  # source://sequel//lib/sequel/database/connecting.rb#173
  def add_servers(servers); end

  # If a transaction is not currently in process, yield to the block immediately.
  # Otherwise, add the block to the list of blocks to call after the currently
  # in progress transaction commits (and only if it commits).
  # Options:
  # :savepoint :: If currently inside a savepoint, only run this hook on transaction
  #               commit if all enclosing savepoints have been released.
  # :server :: The server/shard to use.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/transactions.rb#31
  def after_commit(opts = T.unsafe(nil), &block); end

  # If a transaction is not currently in progress, ignore the block.
  # Otherwise, add the block to the list of the blocks to call after the currently
  # in progress transaction rolls back (and only if it rolls back).
  # Options:
  # :savepoint :: If currently inside a savepoint, run this hook immediately when
  #               any enclosing savepoint is rolled back, which may be before the transaction
  #               commits or rollsback.
  # :server :: The server/shard to use.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/transactions.rb#55
  def after_rollback(opts = T.unsafe(nil), &block); end

  # Alters the given table with the specified block. Example:
  #
  #   DB.alter_table :items do
  #     add_column :category, String, default: 'ruby'
  #     drop_column :category
  #     rename_column :cntr, :counter
  #     set_column_type :value, Float
  #     set_column_default :value, 4.2
  #     add_index [:group, :category]
  #     drop_index [:group, :category]
  #   end
  #
  # Note that +add_column+ accepts all the options available for column
  # definitions using <tt>create_table</tt>, and +add_index+ accepts all the options
  # available for index definition.
  #
  # See <tt>Schema::AlterTableGenerator</tt> and the {Migrations guide}[rdoc-ref:doc/migration.rdoc].
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#67
  def alter_table(name, &block); end

  # Return a new Schema::AlterTableGenerator instance with the receiver as
  # the database and the given block.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#76
  def alter_table_generator(&block); end

  # Whether the schema should be cached for this database.  True by default
  # for performance, can be set to false to always issue a database query to
  # get the schema.
  #
  # source://sequel//lib/sequel/database/query.rb#19
  def cache_schema; end

  # Whether the schema should be cached for this database.  True by default
  # for performance, can be set to false to always issue a database query to
  # get the schema.
  #
  # source://sequel//lib/sequel/database/query.rb#19
  def cache_schema=(_arg0); end

  # Call the prepared statement with the given name with the given hash
  # of arguments.
  #
  #   DB[:items].where(id: 1).prepare(:first, :sa)
  #   DB.call(:sa) # SELECT * FROM items WHERE id = 1
  #
  # source://sequel//lib/sequel/database/query.rb#35
  def call(ps_name, hash = T.unsafe(nil), &block); end

  # Cast the given type to a literal type
  #
  #   DB.cast_type_literal(Float) # double precision
  #   DB.cast_type_literal(:foo)  # foo
  #
  # source://sequel//lib/sequel/database/misc.rb#222
  def cast_type_literal(type); end

  # Whether to check the bytesize of strings before typecasting (to avoid typecasting strings that
  # would be too long for the given type), true by default. Strings that are too long will raise
  # a typecasting error.
  #
  # source://sequel//lib/sequel/database/misc.rb#97
  def check_string_typecast_bytesize; end

  # Whether to check the bytesize of strings before typecasting (to avoid typecasting strings that
  # would be too long for the given type), true by default. Strings that are too long will raise
  # a typecasting error.
  #
  # source://sequel//lib/sequel/database/misc.rb#97
  def check_string_typecast_bytesize=(_arg0); end

  # Create a join table using a hash of foreign keys to referenced
  # table names.  Example:
  #
  #   create_join_table(cat_id: :cats, dog_id: :dogs)
  #   # CREATE TABLE cats_dogs (
  #   #  cat_id integer NOT NULL REFERENCES cats,
  #   #  dog_id integer NOT NULL REFERENCES dogs,
  #   #  PRIMARY KEY (cat_id, dog_id)
  #   # )
  #   # CREATE INDEX cats_dogs_dog_id_cat_id_index ON cats_dogs(dog_id, cat_id)
  #
  # The primary key and index are used so that almost all operations
  # on the table can benefit from one of the two indexes, and the primary
  # key ensures that entries in the table are unique, which is the typical
  # desire for a join table.
  #
  # The default table name this will create is the sorted version of the two
  # hash values, joined by an underscore.  So the following two method calls
  # create the same table:
  #
  #   create_join_table(cat_id: :cats, dog_id: :dogs) # cats_dogs
  #   create_join_table(dog_id: :dogs, cat_id: :cats) # cats_dogs
  #
  # You can provide column options by making the values in the hash
  # be option hashes, so long as the option hashes have a :table
  # entry giving the table referenced:
  #
  #   create_join_table(cat_id: {table: :cats, type: :Bignum}, dog_id: :dogs)
  #
  # You can provide a second argument which is a table options hash:
  #
  #   create_join_table({cat_id: :cats, dog_id: :dogs}, temp: true)
  #
  # Some table options are handled specially:
  #
  # :index_options :: The options to pass to the index
  # :name :: The name of the table to create
  # :no_index :: Set to true not to create the second index.
  # :no_primary_key :: Set to true to not create the primary key.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#119
  def create_join_table(hash, options = T.unsafe(nil)); end

  # Forcibly create a join table, attempting to drop it if it already exists, then creating it.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#137
  def create_join_table!(hash, options = T.unsafe(nil)); end

  # Creates the join table unless it already exists.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#143
  def create_join_table?(hash, options = T.unsafe(nil)); end

  # Creates a view, replacing a view with the same name if one already exists.
  #
  #   DB.create_or_replace_view(:some_items, "SELECT * FROM items WHERE price < 100")
  #   DB.create_or_replace_view(:some_items, DB[:items].where(category: 'ruby'))
  #
  # For databases where replacing a view is not natively supported, support
  # is emulated by dropping a view with the same name before creating the view.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#248
  def create_or_replace_view(name, source, options = T.unsafe(nil)); end

  # Creates a table with the columns given in the provided block:
  #
  #   DB.create_table :posts do
  #     primary_key :id
  #     column :title, String
  #     String :content
  #     index :title
  #   end
  #
  # General options:
  # :as :: Create the table using the value, which should be either a
  #        dataset or a literal SQL string.  If this option is used,
  #        a block should not be given to the method.
  # :ignore_index_errors :: Ignore any errors when creating indexes.
  # :temp :: Create the table as a temporary table.
  #
  # MySQL specific options:
  # :charset :: The character set to use for the table.
  # :collate :: The collation to use for the table.
  # :engine :: The table engine to use for the table.
  #
  # PostgreSQL specific options:
  # :on_commit :: Either :preserve_rows (default), :drop or :delete_rows. Should
  #               only be specified when creating a temporary table.
  # :foreign :: Create a foreign table.  The value should be the name of the
  #             foreign server that was specified in CREATE SERVER.
  # :inherits :: Inherit from a different table.  An array can be
  #              specified to inherit from multiple tables.
  # :unlogged :: Create the table as an unlogged table.
  # :options :: The OPTIONS clause to use for foreign tables.  Should be a hash
  #             where keys are option names and values are option values.  Note
  #             that option names are unquoted, so you should not use untrusted
  #             keys.
  # :tablespace :: The tablespace to use for the table.
  #
  # SQLite specific options:
  # :strict :: Create a STRICT table, which checks that the values for the columns
  #            are the correct type (similar to all other SQL databases). Note that
  #            when using this option, all column types used should be one of the
  #            following: +int+, +integer+, +real+, +text+, +blob+, and +any+.
  #            The +any+ type is treated like a SQLite column in a non-strict table,
  #            allowing any type of data to be stored. This option is supported on
  #            SQLite 3.37.0+.
  #
  # See <tt>Schema::CreateTableGenerator</tt> and the {"Schema Modification" guide}[rdoc-ref:doc/schema_modification.rdoc].
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#196
  def create_table(name, options = T.unsafe(nil), &block); end

  # Forcibly create a table, attempting to drop it if it already exists, then creating it.
  #
  #   DB.create_table!(:a){Integer :a}
  #   # SELECT NULL FROM a LIMIT 1 -- check existence
  #   # DROP TABLE a -- drop table if already exists
  #   # CREATE TABLE a (a integer)
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#215
  def create_table!(name, options = T.unsafe(nil), &block); end

  # Creates the table unless the table already exists.
  #
  #   DB.create_table?(:a){Integer :a}
  #   # SELECT NULL FROM a LIMIT 1 -- check existence
  #   # CREATE TABLE a (a integer) -- if it doesn't already exist
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#225
  def create_table?(name, options = T.unsafe(nil), &block); end

  # Return a new Schema::CreateTableGenerator instance with the receiver as
  # the database and the given block.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#237
  def create_table_generator(&block); end

  # Creates a view based on a dataset or an SQL string:
  #
  #   DB.create_view(:cheap_items, "SELECT * FROM items WHERE price < 100")
  #   # CREATE VIEW cheap_items AS
  #   # SELECT * FROM items WHERE price < 100
  #
  #   DB.create_view(:ruby_items, DB[:items].where(category: 'ruby'))
  #   # CREATE VIEW ruby_items AS
  #   # SELECT * FROM items WHERE (category = 'ruby')
  #
  #   DB.create_view(:checked_items, DB[:items].where(:foo), check: true)
  #   # CREATE VIEW checked_items AS
  #   # SELECT * FROM items WHERE foo
  #   # WITH CHECK OPTION
  #
  #   DB.create_view(:bar_items, DB[:items].select(:foo), columns: [:bar])
  #   # CREATE VIEW bar_items (bar) AS
  #   # SELECT foo FROM items
  #
  # Options:
  # :columns :: The column names to use for the view.  If not given,
  #             automatically determined based on the input dataset.
  # :check :: Adds a WITH CHECK OPTION clause, so that attempting to modify
  #           rows in the underlying table that would not be returned by the
  #           view is not allowed.  This can be set to :local to use WITH
  #           LOCAL CHECK OPTION.
  #
  # PostgreSQL/SQLite specific option:
  # :temp :: Create a temporary view, automatically dropped on disconnect.
  #
  # PostgreSQL specific options:
  # :materialized :: Creates a materialized view, similar to a regular view,
  #                  but backed by a physical table.
  # :recursive :: Creates a recursive view.  As columns must be specified for
  #               recursive views, you can also set them as the value of this
  #               option.  Since a recursive view requires a union that isn't
  #               in a subquery, if you are providing a Dataset as the source
  #               argument, if should probably call the union method with the
  #               all: true and from_self: false options.
  # :security_invoker :: Set the security_invoker property on the view, making
  #                      the access to the view use the current user's permissions,
  #                      instead of the view owner's permissions.
  # :tablespace :: The tablespace to use for materialized views.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#302
  def create_view(name, source, options = T.unsafe(nil)); end

  # The database type for this database object, the same as the adapter scheme
  # by default.  Should be overridden in adapters (especially shared adapters)
  # to be the correct type, so that even if two separate Database objects are
  # using different adapters you can tell that they are using the same database
  # type.  Even better, you can tell that two Database objects that are using
  # the same adapter are connecting to different database types.
  #
  #   Sequel.connect('jdbc:postgres://...').database_type
  #   # => :postgres
  #
  # source://sequel//lib/sequel/database/connecting.rb#192
  def database_type; end

  # Returns a blank dataset for this database.
  #
  #   DB.dataset # SELECT *
  #   DB.dataset.from(:items) # SELECT * FROM items
  #
  # source://sequel//lib/sequel/database/dataset.rb#29
  def dataset; end

  # The class to use for creating datasets.  Should respond to
  # new with the Database argument as the first argument, and
  # an optional options hash.
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#13
  def dataset_class; end

  # If the database has any dataset modules associated with it,
  # use a subclass of the given class that includes the modules
  # as the dataset class.
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#18
  def dataset_class=(c); end

  # The specific default size of string columns for this Sequel::Database, usually 255 by default.
  #
  # source://sequel//lib/sequel/database/misc.rb#92
  def default_string_column_size; end

  # The specific default size of string columns for this Sequel::Database, usually 255 by default.
  #
  # source://sequel//lib/sequel/database/misc.rb#92
  def default_string_column_size=(_arg0); end

  # Disconnects all available connections from the connection pool.  Any
  # connections currently in use will not be disconnected. Options:
  # :server :: Should be a symbol specifing the server to disconnect from,
  #             or an array of symbols to specify multiple servers.
  #
  # Example:
  #
  #   DB.disconnect # All servers
  #   DB.disconnect(server: :server1) # Single server
  #   DB.disconnect(server: [:server1, :server2]) # Multiple servers
  #
  # source://sequel//lib/sequel/database/connecting.rb#206
  def disconnect(opts = T.unsafe(nil)); end

  # Should only be called by the connection pool code to disconnect a connection.
  # By default, calls the close method on the connection object, since most
  # adapters use that, but should be overwritten on other adapters.
  #
  # source://sequel//lib/sequel/database/connecting.rb#213
  def disconnect_connection(conn); end

  # Removes a column from the specified table:
  #
  #   DB.drop_column :items, :category
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#313
  def drop_column(table, *args); end

  # Removes an index for the given table and column(s):
  #
  #   DB.drop_index :posts, :title
  #   DB.drop_index :posts, [:author, :title]
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#323
  def drop_index(table, columns, options = T.unsafe(nil)); end

  # Drop the join table that would have been created with the
  # same arguments to create_join_table:
  #
  #   drop_join_table(cat_id: :cats, dog_id: :dogs)
  #   # DROP TABLE cats_dogs
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#332
  def drop_join_table(hash, options = T.unsafe(nil)); end

  # Drops one or more tables corresponding to the given names:
  #
  #   DB.drop_table(:posts) # DROP TABLE posts
  #   DB.drop_table(:posts, :comments)
  #   DB.drop_table(:posts, :comments, cascade: true)
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#341
  def drop_table(*names); end

  # Drops the table if it already exists.  If it doesn't exist,
  # does nothing.
  #
  #   DB.drop_table?(:a)
  #   # SELECT NULL FROM a LIMIT 1 -- check existence
  #   # DROP TABLE a -- if it already exists
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#356
  def drop_table?(*names); end

  # Drops one or more views corresponding to the given names:
  #
  #   DB.drop_view(:cheap_items)
  #   DB.drop_view(:cheap_items, :pricey_items)
  #   DB.drop_view(:cheap_items, :pricey_items, cascade: true)
  #   DB.drop_view(:cheap_items, :pricey_items, if_exists: true)
  #
  # Options:
  # :cascade :: Also drop objects depending on this view.
  # :if_exists :: Do not raise an error if the view does not exist.
  #
  # PostgreSQL specific options:
  # :materialized :: Drop a materialized view.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#384
  def drop_view(*names); end

  # Method that should be used when submitting any DDL (Data Definition
  # Language) SQL, such as +create_table+.  By default, calls +execute_dui+.
  # This method should not be called directly by user code.
  #
  # source://sequel//lib/sequel/database/query.rb#42
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end

  # Method that should be used when issuing a DELETE or UPDATE
  # statement.  By default, calls execute.
  # This method should not be called directly by user code.
  #
  # source://sequel//lib/sequel/database/query.rb#49
  def execute_dui(sql, opts = T.unsafe(nil), &block); end

  # Method that should be used when issuing a INSERT
  # statement.  By default, calls execute_dui.
  # This method should not be called directly by user code.
  #
  # source://sequel//lib/sequel/database/query.rb#56
  def execute_insert(sql, opts = T.unsafe(nil), &block); end

  # Equivalent to extending all datasets produced by the database with a
  # module.  What it actually does is use a subclass of the current dataset_class
  # as the new dataset_class, and include the module in the subclass.
  # Instead of a module, you can provide a block that is used to create an
  # anonymous module.
  #
  # This allows you to override any of the dataset methods even if they are
  # defined directly on the dataset class that this Database object uses.
  #
  # If a block is given, a Dataset::DatasetModule instance is created, allowing
  # for the easy creation of named dataset methods that will do caching.
  #
  # Examples:
  #
  #   # Introspect columns for all of DB's datasets
  #   DB.extend_datasets(Sequel::ColumnsIntrospection)
  #
  #   # Trace all SELECT queries by printing the SQL and the full backtrace
  #   DB.extend_datasets do
  #     def fetch_rows(sql)
  #       puts sql
  #       puts caller
  #       super
  #     end
  #   end
  #
  #   # Add some named dataset methods
  #   DB.extend_datasets do
  #     order :by_id, :id
  #     select :with_id_and_name, :id, :name
  #     where :active, :active
  #   end
  #
  #   DB[:table].active.with_id_and_name.by_id
  #   # SELECT id, name FROM table WHERE active ORDER BY id
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#62
  def extend_datasets(mod = T.unsafe(nil), &block); end

  # Load an extension into the receiver.  In addition to requiring the extension file, this
  # also modifies the database to work with the extension (usually extending it with a
  # module defined in the extension file).  If no related extension file exists or the
  # extension does not have specific support for Database objects, an Error will be raised.
  # Returns self.
  #
  # source://sequel//lib/sequel/database/misc.rb#231
  def extension(*exts); end

  # Returns a dataset instance for the given SQL string:
  #
  #   ds = DB.fetch('SELECT * FROM items')
  #
  # You can then call methods on the dataset to retrieve results:
  #
  #   ds.all
  #   # SELECT * FROM items
  #   # => [{:column=>value, ...}, ...]
  #
  # If a block is given, it is passed to #each on the resulting dataset to
  # iterate over the records returned by the query:
  #
  #   DB.fetch('SELECT * FROM items'){|r| p r}
  #   # {:column=>value, ...}
  #   # ...
  #
  # +fetch+ can also perform parameterized queries for protection against SQL
  # injection:
  #
  #   ds = DB.fetch('SELECT * FROM items WHERE name = ?', "my name")
  #   ds.all
  #   # SELECT * FROM items WHERE name = 'my name'
  #
  # See caveats listed in Dataset#with_sql regarding datasets using custom
  # SQL and the methods that can be called on them.
  #
  # source://sequel//lib/sequel/database/dataset.rb#59
  def fetch(sql, *args, &block); end

  # Freeze internal data structures for the Database instance.
  #
  # source://sequel//lib/sequel/database/misc.rb#196
  def freeze; end

  # Returns a new dataset with the +from+ method invoked. If a block is given,
  # it acts as a virtual row block
  #
  #   DB.from(:items) # SELECT * FROM items
  #   DB.from{schema[:table]} # SELECT * FROM schema.table
  #
  # source://sequel//lib/sequel/database/dataset.rb#70
  def from(*args, &block); end

  # Convert the given timestamp from the application's timezone,
  # to the databases's timezone or the default database timezone if
  # the database does not have a timezone.
  #
  # source://sequel//lib/sequel/database/misc.rb#248
  def from_application_timestamp(v); end

  # Returns a single value from the database, see Dataset#get.
  #
  #   DB.get(1) # SELECT 1
  #   # => 1
  #   DB.get{server_version.function} # SELECT server_version()
  #
  # source://sequel//lib/sequel/database/query.rb#65
  def get(*args, &block); end

  # Whether the database uses a global namespace for the index, true by default.  If
  # false, the indexes are going to be namespaced per table.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#13
  def global_index_namespace?; end

  # Return true if already in a transaction given the options,
  # false otherwise.  Respects the :server option for selecting
  # a shard.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/transactions.rb#113
  def in_transaction?(opts = T.unsafe(nil)); end

  # Returns a string representation of the database object including the
  # class name and connection URI and options used when connecting (if any).
  #
  # source://sequel//lib/sequel/database/misc.rb#254
  def inspect; end

  # Proxy the literal call to the dataset.
  #
  #   DB.literal(1)   # 1
  #   DB.literal(:a)  # a
  #   DB.literal('a') # 'a'
  #
  # source://sequel//lib/sequel/database/misc.rb#268
  def literal(v); end

  # Return the literalized version of the symbol if cached, or
  # nil if it is not cached.
  #
  # source://sequel//lib/sequel/database/misc.rb#274
  def literal_symbol(sym); end

  # Set the cached value of the literal symbol.
  #
  # source://sequel//lib/sequel/database/misc.rb#279
  def literal_symbol_set(sym, lit); end

  # Whether to include information about the connection in use when logging queries.
  #
  # source://sequel//lib/sequel/database/logging.rb#18
  def log_connection_info; end

  # Whether to include information about the connection in use when logging queries.
  #
  # source://sequel//lib/sequel/database/logging.rb#18
  def log_connection_info=(_arg0); end

  # Yield to the block, logging any errors at error level to all loggers,
  # and all other queries with the duration at warn or info level.
  #
  # source://sequel//lib/sequel/database/logging.rb#37
  def log_connection_yield(sql, conn, args = T.unsafe(nil)); end

  # Log a message at error level, with information about the exception.
  #
  # source://sequel//lib/sequel/database/logging.rb#26
  def log_exception(exception, message); end

  # Log a message at level info to all loggers.
  #
  # source://sequel//lib/sequel/database/logging.rb#31
  def log_info(message, args = T.unsafe(nil)); end

  # Numeric specifying the duration beyond which queries are logged at warn
  # level instead of info level.
  #
  # source://sequel//lib/sequel/database/logging.rb#12
  def log_warn_duration; end

  # Numeric specifying the duration beyond which queries are logged at warn
  # level instead of info level.
  #
  # source://sequel//lib/sequel/database/logging.rb#12
  def log_warn_duration=(_arg0); end

  # Remove any existing loggers and just use the given logger:
  #
  #   DB.logger = Logger.new($stdout)
  #
  # source://sequel//lib/sequel/database/logging.rb#55
  def logger=(logger); end

  # Array of SQL loggers to use for this database.
  #
  # source://sequel//lib/sequel/database/logging.rb#15
  def loggers; end

  # Array of SQL loggers to use for this database.
  #
  # source://sequel//lib/sequel/database/logging.rb#15
  def loggers=(_arg0); end

  # Connect to the given server/shard. Handles database-generic post-connection
  # setup not handled by #connect, using the :after_connect and :connect_sqls
  # options.
  #
  # source://sequel//lib/sequel/database/connecting.rb#247
  def new_connection(server); end

  # The options hash for this database
  #
  # source://sequel//lib/sequel/database/misc.rb#86
  def opts; end

  # The connection pool for this Database instance.  All Database instances have
  # their own connection pools.
  #
  # source://sequel//lib/sequel/database/connecting.rb#152
  def pool; end

  # Synchronize access to the prepared statements cache.
  #
  # source://sequel//lib/sequel/database/misc.rb#284
  def prepared_statement(name); end

  # The prepared statement object hash for this database, keyed by name symbol
  #
  # source://sequel//lib/sequel/database/query.rb#14
  def prepared_statements; end

  # Proxy the quote_identifier method to the dataset,
  # useful for quoting unqualified identifiers for use
  # outside of datasets.
  #
  # source://sequel//lib/sequel/database/misc.rb#291
  def quote_identifier(v); end

  # Dynamically remove existing servers from the connection pool. Only usable
  # when using a sharded connection pool
  #
  # servers should be symbols or arrays of symbols.  If a nonexistent server
  # is specified, it is ignored.  If no servers have been specified for
  # this database, no changes are made. If you attempt to remove the :default server,
  # an error will be raised.
  #
  #   DB.remove_servers(:f1, :f2)
  #
  # source://sequel//lib/sequel/database/connecting.rb#226
  def remove_servers(*servers); end

  # Renames a column in the specified table. This method expects the current
  # column name and the new column name:
  #
  #   DB.rename_column :items, :cntr, :counter
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#410
  def rename_column(table, *args); end

  # Renames a table:
  #
  #   DB.tables #=> [:items]
  #   DB.rename_table :items, :old_items
  #   DB.tables #=> [:old_items]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#398
  def rename_table(name, new_name); end

  # Returns a proc that you can call to check if the transaction
  # has been rolled back.  The proc will return nil if the
  # transaction is still in progress, true if the transaction was
  # rolled back, and false if it was committed.  Raises an
  # Error if called outside a transaction.  Respects the :server
  # option for selecting a shard.
  #
  # source://sequel//lib/sequel/database/transactions.rb#123
  def rollback_checker(opts = T.unsafe(nil)); end

  # When exiting the transaction block through methods other than an exception
  # (e.g. normal exit, non-local return, or throw), set the current transaction
  # to rollback instead of committing.  This is designed for use in cases where
  # you want to preform a non-local return but also want to rollback instead of
  # committing.
  # Options:
  # :cancel :: Cancel the current rollback_on_exit setting, so exiting will commit instead
  #            of rolling back.
  # :savepoint :: Rollback only the current savepoint if inside a savepoint.
  #               Can also be an positive integer value to rollback that number of enclosing savepoints,
  #               up to and including the transaction itself.
  #               If the database does not support savepoints, this option is ignored and the entire
  #               transaction is affected.
  # :server :: The server/shard the transaction is being executed on.
  #
  # source://sequel//lib/sequel/database/transactions.rb#83
  def rollback_on_exit(opts = T.unsafe(nil)); end

  # Runs the supplied SQL statement string on the database server. Returns nil.
  # Options:
  # :server :: The server to run the SQL on.
  #
  #   DB.run("SET some_server_variable = 42")
  #
  # source://sequel//lib/sequel/database/query.rb#74
  def run(sql, opts = T.unsafe(nil)); end

  # Returns the schema for the given table as an array with all members being arrays of length 2,
  # the first member being the column name, and the second member being a hash of column information.
  # The table argument can also be a dataset, as long as it only has one table.
  # Available options are:
  #
  # :reload :: Ignore any cached results, and get fresh information from the database.
  # :schema :: An explicit schema to use.  It may also be implicitly provided
  #            via the table name.
  #
  # If schema parsing is supported by the database, the column information hash should contain at least the
  # following entries:
  #
  # :allow_null :: Whether NULL is an allowed value for the column.
  # :db_type :: The database type for the column, as a database specific string.
  # :default :: The database default for the column, as a database specific string, or nil if there is
  #             no default value.
  # :primary_key :: Whether the columns is a primary key column.  If this column is not present,
  #                 it means that primary key information is unavailable, not that the column
  #                 is not a primary key.
  # :ruby_default :: The database default for the column, as a ruby object.  In many cases, complex
  #                  database defaults cannot be parsed into ruby objects, in which case nil will be
  #                  used as the value.
  # :type :: A symbol specifying the type, such as :integer or :string.
  #
  # Example:
  #
  #   DB.schema(:artists)
  #   # [[:id,
  #   #   {:type=>:integer,
  #   #    :primary_key=>true,
  #   #    :default=>"nextval('artist_id_seq'::regclass)",
  #   #    :ruby_default=>nil,
  #   #    :db_type=>"integer",
  #   #    :allow_null=>false}],
  #   #  [:name,
  #   #   {:type=>:string,
  #   #    :primary_key=>false,
  #   #    :default=>nil,
  #   #    :ruby_default=>nil,
  #   #    :db_type=>"text",
  #   #    :allow_null=>false}]]
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/query.rb#121
  def schema(table, opts = T.unsafe(nil)); end

  # Return ruby class or array of classes for the given type symbol.
  #
  # source://sequel//lib/sequel/database/misc.rb#296
  def schema_type_class(type); end

  # Returns a new dataset with the select method invoked.
  #
  #   DB.select(1) # SELECT 1
  #   DB.select{server_version.function} # SELECT server_version()
  #   DB.select(:id).from(:items) # SELECT id FROM items
  #
  # source://sequel//lib/sequel/database/dataset.rb#85
  def select(*args, &block); end

  # Default serial primary key options, used by the table creation code.
  #
  # source://sequel//lib/sequel/database/misc.rb#301
  def serial_primary_key_options; end

  # An array of servers/shards for this Database object.
  #
  #   DB.servers # Unsharded: => [:default]
  #   DB.servers # Sharded:   => [:default, :server1, :server2]
  #
  # source://sequel//lib/sequel/database/connecting.rb#240
  def servers; end

  # Sets the default value for the given column in the given table:
  #
  #   DB.set_column_default :items, :category, 'perl!'
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#419
  def set_column_default(table, *args); end

  # Set the data type for the given column in the given table:
  #
  #   DB.set_column_type :items, :price, :float
  #
  # See <tt>alter_table</tt>.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#428
  def set_column_type(table, *args); end

  # Cache the prepared statement object at the given name.
  #
  # source://sequel//lib/sequel/database/misc.rb#306
  def set_prepared_statement(name, ps); end

  # Whether this database instance uses multiple servers, either for sharding
  # or for primary/replica configurations.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/misc.rb#312
  def sharded?; end

  # Returns true if the database is using a single-threaded connection pool.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/connecting.rb#269
  def single_threaded?; end

  # Log level at which to log SQL queries.  This is actually the method
  # sent to the logger, so it should be the method name symbol. The default
  # is :info, it can be set to :debug to log at DEBUG level.
  #
  # source://sequel//lib/sequel/database/logging.rb#23
  def sql_log_level; end

  # Log level at which to log SQL queries.  This is actually the method
  # sent to the logger, so it should be the method name symbol. The default
  # is :info, it can be set to :debug to log at DEBUG level.
  #
  # source://sequel//lib/sequel/database/logging.rb#23
  def sql_log_level=(_arg0); end

  # Whether the database supports CREATE TABLE IF NOT EXISTS syntax,
  # false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#19
  def supports_create_table_if_not_exists?; end

  # Whether the database supports deferrable constraints, false
  # by default as few databases do.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#25
  def supports_deferrable_constraints?; end

  # Whether the database supports deferrable foreign key constraints,
  # false by default as few databases do.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#31
  def supports_deferrable_foreign_key_constraints?; end

  # Whether the database supports DROP TABLE IF EXISTS syntax,
  # false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#37
  def supports_drop_table_if_exists?; end

  # Whether the database supports Database#foreign_key_list for
  # parsing foreign keys.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#43
  def supports_foreign_key_parsing?; end

  # Whether the database supports Database#indexes for parsing indexes.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#48
  def supports_index_parsing?; end

  # Whether the database supports partial indexes (indexes on a subset of a table),
  # false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#54
  def supports_partial_indexes?; end

  # Whether the database and adapter support prepared transactions
  # (two-phase commit), false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#60
  def supports_prepared_transactions?; end

  # Whether the database and adapter support savepoints, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#65
  def supports_savepoints?; end

  # Whether the database and adapter support savepoints inside prepared transactions
  # (two-phase commit), false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#71
  def supports_savepoints_in_prepared_transactions?; end

  # Whether the database supports schema parsing via Database#schema.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#76
  def supports_schema_parsing?; end

  # Whether the database supports Database#tables for getting list of tables.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#81
  def supports_table_listing?; end

  # Whether the database and adapter support transaction isolation levels, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#91
  def supports_transaction_isolation_levels?; end

  # Whether DDL statements work correctly in transactions, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#96
  def supports_transactional_ddl?; end

  # Whether the database supports Database#views for getting list of views.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#86
  def supports_view_listing?; end

  # Whether CREATE VIEW ... WITH CHECK OPTION is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#101
  def supports_views_with_check_option?; end

  # Whether CREATE VIEW ... WITH LOCAL CHECK OPTION is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#106
  def supports_views_with_local_check_option?; end

  # Acquires a database connection, yielding it to the passed block. This is
  # useful if you want to make sure the same connection is used for all
  # database queries in the block.  It is also useful if you want to gain
  # direct access to the underlying connection object if you need to do
  # something Sequel does not natively support.
  #
  # If a server option is given, acquires a connection for that specific
  # server, instead of the :default server.
  #
  #   DB.synchronize do |conn|
  #     # ...
  #   end
  #
  # source://sequel//lib/sequel/database/connecting.rb#292
  def synchronize(server = T.unsafe(nil), &block); end

  # Returns true if a table with the given name exists.  This requires a query
  # to the database.
  #
  #   DB.table_exists?(:foo) # => false
  #   # SELECT NULL FROM foo LIMIT 1
  #
  # Note that since this does a SELECT from the table, it can give false negatives
  # if you don't have permission to SELECT from the table.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/query.rb#202
  def table_exists?(name); end

  # Attempts to acquire a database connection.  Returns true if successful.
  # Will probably raise an Error if unsuccessful.  If a server argument
  # is given, attempts to acquire a database connection to the given
  # server/shard.
  #
  # source://sequel//lib/sequel/database/connecting.rb#301
  def test_connection(server = T.unsafe(nil)); end

  # The timezone to use for this database, defaulting to <tt>Sequel.database_timezone</tt>.
  #
  # source://sequel//lib/sequel/database/misc.rb#317
  def timezone; end

  # Set the timezone to use for this database, overridding <tt>Sequel.database_timezone</tt>.
  #
  # source://sequel//lib/sequel/database/misc.rb#89
  def timezone=(_arg0); end

  # Convert the given timestamp to the application's timezone,
  # from the databases's timezone or the default database timezone if
  # the database does not have a timezone.
  #
  # source://sequel//lib/sequel/database/misc.rb#324
  def to_application_timestamp(v); end

  # Starts a database transaction.  When a database transaction is used,
  # either all statements are successful or none of the statements are
  # successful.  Note that MySQL MyISAM tables do not support transactions.
  #
  # The following general options are respected:
  #
  # :auto_savepoint :: Automatically use a savepoint for Database#transaction calls
  #                    inside this transaction block.
  # :isolation :: The transaction isolation level to use for this transaction,
  #               should be :uncommitted, :committed, :repeatable, or :serializable,
  #               used if given and the database/adapter supports customizable
  #               transaction isolation levels.
  # :num_retries :: The number of times to retry if the :retry_on option is used.
  #                 The default is 5 times.  Can be set to nil to retry indefinitely,
  #                 but that is not recommended.
  # :before_retry :: Proc to execute before retrying if the :retry_on option is used.
  #                  Called with two arguments: the number of retry attempts (counting
  #                  the current one) and the error the last attempt failed with.
  # :prepare :: A string to use as the transaction identifier for a
  #             prepared transaction (two-phase commit), if the database/adapter
  #             supports prepared transactions.
  # :retry_on :: An exception class or array of exception classes for which to
  #              automatically retry the transaction.  Can only be set if not inside
  #              an existing transaction.
  #              Note that this should not be used unless the entire transaction
  #              block is idempotent, as otherwise it can cause non-idempotent
  #              behavior to execute multiple times.
  # :rollback :: Can be set to :reraise to reraise any Sequel::Rollback exceptions
  #              raised, or :always to always rollback even if no exceptions occur
  #              (useful for testing).
  # :server :: The server to use for the transaction. Set to :default, :read_only, or
  #            whatever symbol you used in the connect string when naming your servers.
  # :savepoint :: Whether to create a new savepoint for this transaction,
  #               only respected if the database/adapter supports savepoints.  By
  #               default Sequel will reuse an existing transaction, so if you want to
  #               use a savepoint you must use this option.  If the surrounding transaction
  #               uses :auto_savepoint, you can set this to false to not use a savepoint.
  #               If the value given for this option is :only, it will only create a
  #               savepoint if it is inside a transaction.
  #
  # PostgreSQL specific options:
  #
  # :deferrable :: (9.1+) If present, set to DEFERRABLE if true or NOT DEFERRABLE if false.
  # :read_only :: If present, set to READ ONLY if true or READ WRITE if false.
  # :synchronous :: if non-nil, set synchronous_commit
  #                 appropriately.  Valid values true, :on, false, :off, :local (9.1+),
  #                 and :remote_write (9.2+).
  #
  # source://sequel//lib/sequel/database/transactions.rb#177
  def transaction(opts = T.unsafe(nil), &block); end

  # The default transaction isolation level for this database,
  # used for all future transactions.  For MSSQL, this should be set
  # to something if you ever plan to use the :isolation option to
  # Database#transaction, as on MSSQL if affects all future transactions
  # on the same connection.
  #
  # source://sequel//lib/sequel/database/transactions.rb#22
  def transaction_isolation_level; end

  # The default transaction isolation level for this database,
  # used for all future transactions.  For MSSQL, this should be set
  # to something if you ever plan to use the :isolation option to
  # Database#transaction, as on MSSQL if affects all future transactions
  # on the same connection.
  #
  # source://sequel//lib/sequel/database/transactions.rb#22
  def transaction_isolation_level=(_arg0); end

  # Typecast the value to the given column_type. Calls
  # typecast_value_#{column_type} if the method exists,
  # otherwise returns the value.
  # This method should raise Sequel::InvalidValue if assigned value
  # is invalid.
  #
  # source://sequel//lib/sequel/database/misc.rb#333
  def typecast_value(column_type, value); end

  # Returns the URI use to connect to the database.  If a URI
  # was not used when connecting, returns nil.
  #
  # source://sequel//lib/sequel/database/misc.rb#346
  def uri; end

  # Explicit alias of uri for easier subclassing.
  #
  # source://sequel//lib/sequel/database/misc.rb#351
  def url; end

  # Check whether the given connection is currently valid, by
  # running a query against it.  If the query fails, the
  # connection should probably be removed from the connection
  # pool.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/connecting.rb#310
  def valid_connection?(conn); end

  private

  # Uncached version of metadata_dataset, designed for overriding.
  #
  # source://sequel//lib/sequel/database/query.rb#362
  def _metadata_dataset; end

  # Should raise an error if the table doesn't not exist,
  # and not raise an error if the table does exist.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/query.rb#216
  def _table_exists?(ds); end

  # Synchronize access to the current transactions, returning the hash
  # of options for the current transaction (if any)
  #
  # source://sequel//lib/sequel/database/transactions.rb#289
  def _trans(conn); end

  # Internal generic transaction method.  Any exception raised by the given
  # block will cause the transaction to be rolled back.  If the exception is
  # not a Sequel::Rollback, the error will be reraised. If no exception occurs
  # inside the block, the transaction is commited.
  #
  # source://sequel//lib/sequel/database/transactions.rb#244
  def _transaction(conn, opts = T.unsafe(nil)); end

  # :nocov:
  def _typecast_value_string_to_decimal(*_arg0); end

  # Per adapter initialization method, empty by default.
  #
  # source://sequel//lib/sequel/database/misc.rb#358
  def adapter_initialize; end

  # Set the given callable as a hook to be called. Type should be either
  # :after_commit or :after_rollback.
  #
  # source://sequel//lib/sequel/database/transactions.rb#316
  def add_savepoint_hook(conn, type, block); end

  # Add the current thread to the list of active transactions
  #
  # source://sequel//lib/sequel/database/transactions.rb#294
  def add_transaction(conn, opts); end

  # Set the given callable as a hook to be called. Type should be either
  # :after_commit or :after_rollback.
  #
  # source://sequel//lib/sequel/database/transactions.rb#323
  def add_transaction_hook(conn, type, block); end

  # Whether the given connection is already inside a transaction
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/transactions.rb#329
  def already_in_transaction?(conn, opts); end

  # source://sequel//lib/sequel/database/schema_methods.rb#468
  def alter_table_add_column_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#492
  def alter_table_add_constraint_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#472
  def alter_table_drop_column_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#496
  def alter_table_drop_constraint_sql(table, op); end

  # The class used for alter_table generators.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#453
  def alter_table_generator_class; end

  # SQL fragment for given alter table operation.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#458
  def alter_table_op_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#476
  def alter_table_rename_column_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#484
  def alter_table_set_column_default_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#488
  def alter_table_set_column_null_sql(table, op); end

  # source://sequel//lib/sequel/database/schema_methods.rb#480
  def alter_table_set_column_type_sql(table, op); end

  # The SQL to execute to modify the table.  op
  # should be one of the operations returned by the AlterTableGenerator.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#506
  def alter_table_sql(table, op); end

  # Array of SQL statements used to modify the table,
  # corresponding to changes specified by the operations.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#521
  def alter_table_sql_list(table, operations); end

  # Apply the changes in the given alter table ops to the table given by name.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#435
  def apply_alter_table(name, ops); end

  # Apply the operations in the given generator to the table given by name.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#440
  def apply_alter_table_generator(name, generator); end

  # The SQL string specify the autoincrement property, generally used by
  # primary keys.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#551
  def auto_increment_sql; end

  # Start a new database transaction on the given connection
  #
  # source://sequel//lib/sequel/database/transactions.rb#350
  def begin_new_transaction(conn, opts); end

  # Issue query to begin a new savepoint.
  #
  # source://sequel//lib/sequel/database/transactions.rb#340
  def begin_savepoint(conn, opts); end

  # SQL to start a new savepoint
  #
  # source://sequel//lib/sequel/database/transactions.rb#345
  def begin_savepoint_sql(depth); end

  # Start a new database transaction or a new savepoint on the given connection.
  #
  # source://sequel//lib/sequel/database/transactions.rb#356
  def begin_transaction(conn, opts = T.unsafe(nil)); end

  # SQL to BEGIN a transaction.
  #
  # source://sequel//lib/sequel/database/transactions.rb#365
  def begin_transaction_sql; end

  # Returns true when the object is considered blank.
  # The only objects that are blank are nil, false,
  # strings with all whitespace, and ones that respond
  # true to empty?
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/misc.rb#365
  def blank_object?(obj); end

  # Whether the database supports adding primary key constraints on NULLable columns,
  # automatically making them NOT NULL.  If false, the columns must be set NOT NULL
  # before the primary key constraint is added.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#115
  def can_add_primary_key_constraint_on_nullable_columns?; end

  # Add auto increment SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#569
  def column_definition_auto_increment_sql(sql, column); end

  # Add collate SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#574
  def column_definition_collate_sql(sql, column); end

  # Add default SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#581
  def column_definition_default_sql(sql, column); end

  # Add null/not null SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#586
  def column_definition_null_sql(sql, column); end

  # The order of the column definition, as an array of symbols.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#556
  def column_definition_order; end

  # Add primary key SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#601
  def column_definition_primary_key_sql(sql, column); end

  # Add foreign key reference SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#612
  def column_definition_references_sql(sql, column); end

  # SQL fragment containing the column creation SQL for the given column.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#561
  def column_definition_sql(column); end

  # Add unique constraint SQL fragment to column creation SQL.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#622
  def column_definition_unique_sql(sql, column); end

  # SQL for all given columns, used inside a CREATE TABLE block.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#633
  def column_list_sql(generator); end

  # SQL fragment for column foreign key references (column constraints)
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#638
  def column_references_column_constraint_sql(column); end

  # SQL fragment for column foreign key references
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#643
  def column_references_sql(column); end

  # SQL fragment for table foreign key references (table constraints)
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#654
  def column_references_table_constraint_sql(constraint); end

  # Look at the db_type and guess the minimum and maximum decimal values for
  # the column.
  #
  # source://sequel//lib/sequel/database/query.rb#323
  def column_schema_decimal_min_max_values(column); end

  # Whether the type should be treated as a string type when parsing the
  # column schema default value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/query.rb#222
  def column_schema_default_string_type?(type); end

  # Transform the given normalized default string into a ruby object for the
  # given type.
  #
  # source://sequel//lib/sequel/database/query.rb#228
  def column_schema_default_to_ruby_value(default, type); end

  # Look at the db_type and guess the minimum and maximum integer values for
  # the column.
  #
  # source://sequel//lib/sequel/database/query.rb#297
  def column_schema_integer_min_max_values(column); end

  # Look at the db_type and guess the maximum length of the column.
  # This assumes types such as varchar(255).
  #
  # source://sequel//lib/sequel/database/query.rb#348
  def column_schema_max_length(db_type); end

  # Normalize the default value string for the given type
  # and return the normalized value.
  #
  # source://sequel//lib/sequel/database/query.rb#258
  def column_schema_normalize_default(default, type); end

  # Whether the tinyint type (if supported by the database) is unsigned by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/query.rb#342
  def column_schema_tinyint_type_is_unsigned?; end

  # Convert the given default, which should be a database specific string, into
  # a ruby object.
  #
  # source://sequel//lib/sequel/database/query.rb#269
  def column_schema_to_ruby_default(default, type); end

  # Whether the given alter table operation is combinable.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#659
  def combinable_alter_table_op?(op); end

  # Whether to commit the current transaction. Thread.current.status is
  # checked because Thread#kill skips rescue blocks (so exception would be
  # nil), but the transaction should still be rolled back. On Ruby 1.9 (but
  # not 2.0+), the thread status will still be "run", so Thread#kill
  # will erroneously commit the transaction, and there isn't a workaround.
  #
  # source://sequel//lib/sequel/database/transactions.rb#374
  def commit_or_rollback_transaction(exception, conn, opts); end

  # SQL to commit a savepoint
  #
  # source://sequel//lib/sequel/database/transactions.rb#389
  def commit_savepoint_sql(depth); end

  # Commit the active transaction on the connection
  #
  # source://sequel//lib/sequel/database/transactions.rb#394
  def commit_transaction(conn, opts = T.unsafe(nil)); end

  # SQL to COMMIT a transaction.
  #
  # source://sequel//lib/sequel/database/transactions.rb#404
  def commit_transaction_sql; end

  # Method called on the connection object to execute SQL on the database,
  # used by the transaction code.
  #
  # source://sequel//lib/sequel/database/transactions.rb#410
  def connection_execute_method; end

  # String including information about the connection, for use when logging
  # connection info.
  #
  # source://sequel//lib/sequel/database/logging.rb#69
  def connection_info(conn); end

  # The default options for the connection pool.
  #
  # source://sequel//lib/sequel/database/connecting.rb#324
  def connection_pool_default_options; end

  # SQL fragment specifying the deferrable constraint attributes.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#688
  def constraint_deferrable_sql_append(sql, defer); end

  # SQL fragment specifying a constraint on a table.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#664
  def constraint_definition_sql(constraint); end

  # Run SQL statement to create the table with the given name from the given
  # SELECT sql statement.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#758
  def create_table_as(name, sql, options); end

  # SQL statement for creating a table from the result of a SELECT statement.
  # +sql+ should be a string representing a SELECT query.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#765
  def create_table_as_sql(name, sql, options); end

  # Execute the create table statements using the generator.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#701
  def create_table_from_generator(name, generator, options); end

  # The class used for create_table generators.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#706
  def create_table_generator_class; end

  # Execute the create index statements using the generator.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#711
  def create_table_indexes_from_generator(name, generator, options); end

  # SQL fragment for initial part of CREATE TABLE statement
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#770
  def create_table_prefix_sql(name, options); end

  # SQL statement for creating a table with the given name, columns, and options
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#724
  def create_table_sql(name, generator, options); end

  # SQL fragment for initial part of CREATE VIEW statement
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#775
  def create_view_prefix_sql(name, options); end

  # SQL statement for creating a view.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#780
  def create_view_sql(name, source, options); end

  # Append the column list to the SQL, if a column list is given.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#791
  def create_view_sql_append_columns(sql, columns); end

  # Return the Sequel::DatabaseError subclass to wrap the given
  # exception in.
  #
  # source://sequel//lib/sequel/database/misc.rb#388
  def database_error_class(exception, opts); end

  # Which transaction errors to translate, blank by default.
  #
  # source://sequel//lib/sequel/database/transactions.rb#415
  def database_error_classes; end

  # An enumerable yielding pairs of regexps and exception classes, used
  # to match against underlying driver exception messages in
  # order to raise a more specific Sequel::DatabaseError subclass.
  #
  # source://sequel//lib/sequel/database/misc.rb#382
  def database_error_regexps; end

  # Return the SQLState for the given exception, if one can be determined
  #
  # source://sequel//lib/sequel/database/misc.rb#393
  def database_exception_sqlstate(exception, opts); end

  # Return a specific Sequel::DatabaseError exception class if
  # one is appropriate for the underlying exception,
  # or nil if there is no specific exception class.
  #
  # source://sequel//lib/sequel/database/misc.rb#400
  def database_specific_error_class(exception, opts); end

  # Given the SQLState, return the appropriate DatabaseError subclass.
  #
  # source://sequel//lib/sequel/database/misc.rb#422
  def database_specific_error_class_from_sqlstate(sqlstate); end

  # The default dataset class to use for the database
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#78
  def dataset_class_default; end

  # Default index name for the table and columns, may be too long
  # for certain databases.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#802
  def default_index_name(table_name, columns); end

  # Return true if exception represents a disconnect error, false otherwise.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/misc.rb#438
  def disconnect_error?(exception, opts); end

  # The SQL to drop an index for the table.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#815
  def drop_index_sql(table, op); end

  # SQL DDL statement to drop the table with the given name.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#820
  def drop_table_sql(name, options); end

  # SQL DDL statement to drop a view with the given name.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#825
  def drop_view_sql(name, options); end

  # Proxy the filter_expr call to the dataset, used for creating constraints.
  # Support passing Proc arguments as blocks, as well as treating plain strings
  # as literal strings, so that previous migrations that used this API do not break.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#832
  def filter_expr(arg = T.unsafe(nil), &block); end

  # Whether this dataset considers unquoted identifiers as uppercase. True
  # by default as that is the SQL standard
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#121
  def folds_unquoted_identifiers_to_uppercase?; end

  # Get foreign key name for given table and columns.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#808
  def foreign_key_name(table_name, columns); end

  # Whether the connection is currently inside a savepoint.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/transactions.rb#420
  def in_savepoint?(conn); end

  # SQL statement for creating an index for the table with the given name
  # and index specifications.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#850
  def index_definition_sql(table_name, index); end

  # Array of SQL statements, one for each index specification,
  # for the given table.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#859
  def index_sql_list(table_name, indexes); end

  # Load extensions during initialization from the given key in opts.
  #
  # source://sequel//lib/sequel/database/misc.rb#443
  def initialize_load_extensions(key); end

  # Return a Method object for the dataset's output_identifier_method.
  # Used in metadata parsing to make sure the returned information is in the
  # correct format.
  #
  # source://sequel//lib/sequel/database/query.rb#357
  def input_identifier_meth(ds = T.unsafe(nil)); end

  # Extract the join table name from the arguments given to create_join_table.
  # Also does argument validation for the create_join_table method.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#865
  def join_table_name(hash, options); end

  # Extract an individual join table name, which should either be a string
  # or symbol, or a hash containing one of those as the value for :table.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#878
  def join_table_name_extract(entry); end

  # Log the given SQL and then execute it on the connection, used by
  # the transaction code.
  #
  # source://sequel//lib/sequel/database/logging.rb#75
  def log_connection_execute(conn, sql); end

  # Log message with message prefixed by duration at info level, or
  # warn level if duration is greater than log_warn_duration.
  #
  # source://sequel//lib/sequel/database/logging.rb#81
  def log_duration(duration, message); end

  # Log message at level (which should be :error, :warn, or :info)
  # to all loggers.
  #
  # source://sequel//lib/sequel/database/logging.rb#87
  def log_each(level, message); end

  # Return a dataset that uses the default identifier input and output methods
  # for this database.  Used when parsing metadata so that column symbols are
  # returned as expected.
  #
  # source://sequel//lib/sequel/database/query.rb#369
  def metadata_dataset; end

  # SQL fragment to use for ON DELETE, based on the given action.
  # The following actions are recognized:
  #
  # :cascade :: Delete rows referencing this row.
  # :no_action :: Raise an error if other rows reference this
  #               row, allow deferring of the integrity check.
  #               This is the default.
  # :restrict :: Raise an error if other rows reference this row,
  #              but do not allow deferring the integrity check.
  # :set_default :: Set columns referencing this row to their default value.
  # :set_null :: Set columns referencing this row to NULL.
  #
  # Any other object given is just converted to a string, with "_" converted to " " and upcased.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#902
  def on_delete_clause(action); end

  # Alias of #on_delete_clause, since the two usually behave the same.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#907
  def on_update_clause(action); end

  # Return a Method object for the dataset's output_identifier_method.
  # Used in metadata parsing to make sure the returned information is in the
  # correct format.
  #
  # source://sequel//lib/sequel/database/query.rb#376
  def output_identifier_meth(ds = T.unsafe(nil)); end

  # Add fragment for primary key specification, separated for easier overridding.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#912
  def primary_key_constraint_sql_fragment(_); end

  # Whether to quote identifiers by default for this database, true by default.
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#89
  def quote_identifiers_default; end

  # Proxy the quote_schema_table method to the dataset
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#917
  def quote_schema_table(table); end

  # Convert the given exception to an appropriate Sequel::DatabaseError
  # subclass, keeping message and backtrace.
  #
  # source://sequel//lib/sequel/database/misc.rb#460
  def raise_error(exception, opts = T.unsafe(nil)); end

  # Remove the cached schema for the given schema name
  #
  # source://sequel//lib/sequel/database/query.rb#381
  def remove_cached_schema(table); end

  # Remove the current thread from the list of active transactions
  #
  # source://sequel//lib/sequel/database/transactions.rb#440
  def remove_transaction(conn, committed); end

  # SQL statement for renaming a table.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#922
  def rename_table_sql(name, new_name); end

  # Reset the default dataset used by most Database methods that create datasets.
  #
  # source://sequel//lib/sequel/database/dataset_defaults.rb#83
  def reset_default_dataset; end

  # Whether to rollback the transaction when exiting the transaction.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/transactions.rb#483
  def rollback_on_transaction_exit?(conn, opts); end

  # SQL to rollback to a savepoint
  #
  # source://sequel//lib/sequel/database/transactions.rb#478
  def rollback_savepoint_sql(depth); end

  # Rollback the active transaction on the connection
  #
  # source://sequel//lib/sequel/database/transactions.rb#494
  def rollback_transaction(conn, opts = T.unsafe(nil)); end

  # SQL to ROLLBACK a transaction.
  #
  # source://sequel//lib/sequel/database/transactions.rb#504
  def rollback_transaction_sql; end

  # Retrieve the savepoint hooks that should be run for the given
  # connection and commit status.  This expacts that you are
  # already inside a savepoint when calling.
  #
  # source://sequel//lib/sequel/database/transactions.rb#427
  def savepoint_hooks(conn, committed); end

  # Current savepoint level.
  #
  # source://sequel//lib/sequel/database/transactions.rb#521
  def savepoint_level(conn); end

  # Split the schema information from the table
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#927
  def schema_and_table(table_name); end

  # Return true if the given column schema represents an autoincrementing primary key.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#932
  def schema_autoincrementing_primary_key?(schema); end

  # Match the database's column type to a ruby type via a
  # regular expression, and return the ruby type as a symbol
  # such as :integer or :string.
  #
  # source://sequel//lib/sequel/database/query.rb#391
  def schema_column_type(db_type); end

  # Post process the schema values.
  #
  # source://sequel//lib/sequel/database/query.rb#417
  def schema_post_process(cols); end

  # The dataset to use for proxying certain schema methods.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#937
  def schema_utility_dataset; end

  # Return the options for the given server by merging the generic
  # options for all server with the specific options for the given
  # server specified in the :servers option.
  #
  # source://sequel//lib/sequel/database/connecting.rb#331
  def server_opts(server); end

  # Set the transaction isolation level on the given connection
  #
  # source://sequel//lib/sequel/database/transactions.rb#509
  def set_transaction_isolation(conn, opts); end

  # SQL to set the transaction isolation level
  #
  # source://sequel//lib/sequel/database/transactions.rb#516
  def set_transaction_isolation_sql(level); end

  # Determine if logging should be skipped. Defaults to true if no loggers
  # have been specified.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/logging.rb#63
  def skip_logging?; end

  # Split the schema information from the table
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#942
  def split_qualifiers(table_name); end

  # Whether the database supports combining multiple alter table
  # operations into a single query, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#127
  def supports_combining_alter_table_ops?; end

  # Whether the database supports CREATE OR REPLACE VIEW.  If not, support
  # will be emulated by dropping the view first. false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#133
  def supports_create_or_replace_view?; end

  # Whether the database supports named column constraints. True
  # by default.  Those that don't support named column constraints
  # have to have column constraints converted to table constraints
  # if the column constraints have names.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/features.rb#141
  def supports_named_column_constraints?; end

  # Swallow database errors, unless they are connect/disconnect errors.
  #
  # source://sequel//lib/sequel/database/misc.rb#469
  def swallow_database_error; end

  # SQL fragment for temporary table
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#947
  def temporary_table_sql; end

  # Raise a database error unless the exception is an Rollback.
  #
  # source://sequel//lib/sequel/database/transactions.rb#526
  def transaction_error(e, opts = T.unsafe(nil)); end

  # Finish a subtransaction.  If savepoints are supported, pops the current
  # tansaction off the savepoint stack.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/transactions.rb#536
  def transaction_finished?(conn); end

  # Retrieve the transaction hooks that should be run for the given
  # connection and commit status.
  #
  # source://sequel//lib/sequel/database/transactions.rb#433
  def transaction_hooks(conn, committed); end

  # Derive the transaction hash from the options passed to the transaction.
  # Meant to be overridden.
  #
  # source://sequel//lib/sequel/database/transactions.rb#335
  def transaction_options(conn, opts); end

  # SQL fragment specifying the type of a given column.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#952
  def type_literal(column); end

  # SQL fragment specifying the full type of a column,
  # consider the type with possible modifiers.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#965
  def type_literal_generic(column); end

  # Alias for type_literal_generic_numeric, to make overriding in a subclass easier.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#976
  def type_literal_generic_bigdecimal(column); end

  # Sequel uses the bigint type by default for :Bignum symbol.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#981
  def type_literal_generic_bignum_symbol(column); end

  # Sequel uses the date type by default for Dates.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#986
  def type_literal_generic_date(column); end

  # Sequel uses the timestamp type by default for DateTimes.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#991
  def type_literal_generic_datetime(column); end

  # Alias for type_literal_generic_trueclass, to make overriding in a subclass easier.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#996
  def type_literal_generic_falseclass(column); end

  # Sequel uses the blob type by default for Files.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1001
  def type_literal_generic_file(column); end

  # Alias for type_literal_generic_integer, to make overriding in a subclass easier.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1006
  def type_literal_generic_fixnum(column); end

  # Sequel uses the double precision type by default for Floats.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1011
  def type_literal_generic_float(column); end

  # Sequel uses the integer type by default for integers
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1016
  def type_literal_generic_integer(column); end

  # Sequel uses the numeric type by default for Numerics and BigDecimals.
  # If a size is given, it is used, otherwise, it will default to whatever
  # the database default is for an unsized value.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1023
  def type_literal_generic_numeric(column); end

  # Use time by default for Time values if :only_time option is used.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1052
  def type_literal_generic_only_time(column); end

  # Sequel uses the varchar type by default for Strings.  If a
  # size isn't present, Sequel assumes a size of 255.  If the
  # :fixed option is used, Sequel uses the char type.  If the
  # :text option is used, Sequel uses the :text type.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1031
  def type_literal_generic_string(column); end

  # Sequel uses the timestamp type by default for Time values.
  # If the :only_time option is used, the time type is used.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1043
  def type_literal_generic_time(column); end

  # Sequel uses the boolean type by default for TrueClass and FalseClass.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1057
  def type_literal_generic_trueclass(column); end

  # SQL fragment for the given type of a column if the column is not one of the
  # generic types specified with a ruby class.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1063
  def type_literal_specific(column); end

  # Check the bytesize of the string value, if value is a string.
  #
  # source://sequel//lib/sequel/database/misc.rb#491
  def typecast_check_length(value, max_size); end

  # Check the bytesize of a string before conversion. There is no point
  # trying to typecast strings that would be way too long.
  #
  # source://sequel//lib/sequel/database/misc.rb#483
  def typecast_check_string_length(string, max_size); end

  # Typecast the value to an SQL::Blob
  #
  # source://sequel//lib/sequel/database/misc.rb#497
  def typecast_value_blob(value); end

  # Typecast the value to true, false, or nil
  #
  # source://sequel//lib/sequel/database/misc.rb#502
  def typecast_value_boolean(value); end

  # Typecast the value to a Date
  #
  # source://sequel//lib/sequel/database/misc.rb#512
  def typecast_value_date(value); end

  # Typecast the value to a DateTime or Time depending on Sequel.datetime_class
  #
  # source://sequel//lib/sequel/database/misc.rb#528
  def typecast_value_datetime(value); end

  # Typecast the value to a BigDecimal
  #
  # source://sequel//lib/sequel/database/misc.rb#565
  def typecast_value_decimal(value); end

  # Typecast the value to a Float
  #
  # source://sequel//lib/sequel/database/misc.rb#579
  def typecast_value_float(value); end

  # Typecast the value to an Integer
  #
  # source://sequel//lib/sequel/database/misc.rb#584
  def typecast_value_integer(value); end

  # Typecast the value to a String
  #
  # source://sequel//lib/sequel/database/misc.rb#599
  def typecast_value_string(value); end

  # Typecast the value to a Time
  #
  # source://sequel//lib/sequel/database/misc.rb#609
  def typecast_value_time(value); end

  # Add fragment for unique specification, separated for easier overridding.
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1072
  def unique_constraint_sql_fragment(_); end

  # Whether clob should be used for String text: true columns.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_methods.rb#1077
  def uses_clob_for_text?; end

  # The SQL query to issue to check if a connection is valid.
  #
  # source://sequel//lib/sequel/database/connecting.rb#351
  def valid_connection_sql; end

  # Don't advertise support for WITH CHECK OPTION by default.
  #
  # source://sequel//lib/sequel/database/features.rb#146
  def view_with_check_option_support; end

  class << self
    # The Database subclass for the given adapter scheme.
    # Raises Sequel::AdapterNotFound if the adapter
    # could not be loaded.
    #
    # source://sequel//lib/sequel/database/connecting.rb#16
    def adapter_class(scheme); end

    # Returns the scheme symbol for the Database class.
    #
    # source://sequel//lib/sequel/database/connecting.rb#21
    def adapter_scheme; end

    # Register a hook that will be run when a new Database is instantiated. It is
    # called with the new database handle.
    #
    # @raise [Error]
    #
    # source://sequel//lib/sequel/database/misc.rb#34
    def after_initialize(&block); end

    # Connects to a database.  See Sequel.connect.
    #
    # source://sequel//lib/sequel/database/connecting.rb#26
    def connect(conn_string, opts = T.unsafe(nil)); end

    # Apply an extension to all Database objects created in the future.
    #
    # source://sequel//lib/sequel/database/misc.rb#46
    def extension(*extensions); end

    # Load the adapter from the file system.  Raises Sequel::AdapterNotFound
    # if the adapter cannot be loaded, or if the adapter isn't registered
    # correctly after being loaded. Options:
    # :map :: The Hash in which to look for an already loaded adapter (defaults to ADAPTER_MAP).
    # :subdir :: The subdirectory of sequel/adapters to look in, only to be used for loading
    #            subadapters.
    #
    # source://sequel//lib/sequel/database/connecting.rb#76
    def load_adapter(scheme, opts = T.unsafe(nil)); end

    # Register an extension callback for Database objects.  ext should be the
    # extension name symbol, and mod should either be a Module that the
    # database is extended with, or a callable object called with the database
    # object.  If mod is not provided, a block can be provided and is treated
    # as the mod object.
    #
    # source://sequel//lib/sequel/database/misc.rb#55
    def register_extension(ext, mod = T.unsafe(nil), &block); end

    # Run the after_initialize hook for the given +instance+.
    #
    # source://sequel//lib/sequel/database/misc.rb#68
    def run_after_initialize(instance); end

    # Sets the given module as the shared adapter module for the given scheme.
    # Used to register shared adapters for use by the mock adapter. Example:
    #
    #   # in file sequel/adapters/shared/mydb.rb
    #   module Sequel::MyDB
    #     Sequel::Database.set_shared_adapter_scheme :mydb, self
    #
    #     def self.mock_adapter_setup(db)
    #       # ...
    #     end
    #
    #     module DatabaseMethods
    #       # ...
    #     end
    #
    #     module DatasetMethods
    #       # ...
    #     end
    #   end
    #
    # would allow the mock adapter to return a Database instance that supports
    # the MyDB syntax via:
    #
    #   Sequel.connect('mock://mydb')
    #
    # source://sequel//lib/sequel/database/connecting.rb#146
    def set_shared_adapter_scheme(scheme, mod); end

    private

    # Sets the adapter scheme for the Database class. Call this method in
    # descendants of Database to allow connection using a URL. For example the
    # following:
    #
    #   class Sequel::MyDB::Database < Sequel::Database
    #     set_adapter_scheme :mydb
    #     ...
    #   end
    #
    # would allow connection using:
    #
    #   Sequel.connect('mydb://user:password@dbserver/mydb')
    #
    # source://sequel//lib/sequel/database/connecting.rb#116
    def set_adapter_scheme(scheme); end

    # Converts a uri to an options hash. These options are then passed
    # to a newly created database object.
    #
    # source://sequel//lib/sequel/database/misc.rb#74
    def uri_to_options(uri); end
  end
end

# Array of supported database adapters
#
# source://sequel//lib/sequel/database/connecting.rb#11
Sequel::Database::ADAPTERS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/misc.rb#419
Sequel::Database::CHECK_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

# The order of column modifiers to use when defining a column.
#
# source://sequel//lib/sequel/database/schema_methods.rb#11
Sequel::Database::COLUMN_DEFINITION_ORDER = T.let(T.unsafe(nil), Array)

# ---------------------
# :section: 1 - Methods that execute queries and/or return results
# This methods generally execute SQL code on the database server.
# ---------------------
#
# source://sequel//lib/sequel/database/query.rb#10
Sequel::Database::COLUMN_SCHEMA_DATETIME_TYPES = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#11
Sequel::Database::COLUMN_SCHEMA_STRING_TYPES = T.let(T.unsafe(nil), Array)

# The alter table operations that are combinable.
#
# source://sequel//lib/sequel/database/schema_methods.rb#14
Sequel::Database::COMBINABLE_ALTER_TABLE_OPS = T.let(T.unsafe(nil), Array)

# Empty exception regexp to class map, used by default if Sequel doesn't
# have specific support for the database in use.
#
# source://sequel//lib/sequel/database/misc.rb#21
Sequel::Database::DEFAULT_DATABASE_ERROR_REGEXPS = T.let(T.unsafe(nil), Hash)

# The general default size for string columns for all Sequel::Database
# instances.
#
# source://sequel//lib/sequel/database/misc.rb#17
Sequel::Database::DEFAULT_STRING_COLUMN_SIZE = T.let(T.unsafe(nil), Integer)

# Hash of extension name symbols to callable objects to load the extension
# into the Database object (usually by extending it with a module defined
# in the extension).
#
# source://sequel//lib/sequel/database/misc.rb#13
Sequel::Database::EXTENSIONS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/database/misc.rb#417
Sequel::Database::FOREIGN_KEY_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#284
Sequel::Database::INTEGER1_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#285
Sequel::Database::INTEGER2_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#286
Sequel::Database::INTEGER3_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#287
Sequel::Database::INTEGER4_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#288
Sequel::Database::INTEGER8_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/misc.rb#416
Sequel::Database::NOT_NULL_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database.rb#24
Sequel::Database::OPTS = T.let(T.unsafe(nil), Hash)

# Mapping of schema type symbols to class or arrays of classes for that
# symbol.
#
# source://sequel//lib/sequel/database/misc.rb#25
Sequel::Database::SCHEMA_TYPE_CLASSES = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/database/misc.rb#420
Sequel::Database::SERIALIZATION_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

# ---------------------
# :section: 8 - Methods related to database transactions
# Database transactions make multiple queries atomic, so
# that either all of the queries take effect or none of
# them do.
# ---------------------
#
# source://sequel//lib/sequel/database/transactions.rb#12
Sequel::Database::TRANSACTION_ISOLATION_LEVELS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/database/misc.rb#418
Sequel::Database::UNIQUE_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#289
Sequel::Database::UNSIGNED_INTEGER1_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#290
Sequel::Database::UNSIGNED_INTEGER2_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#291
Sequel::Database::UNSIGNED_INTEGER3_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#292
Sequel::Database::UNSIGNED_INTEGER4_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/database/query.rb#293
Sequel::Database::UNSIGNED_INTEGER8_MIN_MAX = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/exceptions.rb#37
class Sequel::DatabaseConnectionError < ::Sequel::DatabaseError; end

# source://sequel//lib/sequel/exceptions.rb#45
class Sequel::DatabaseDisconnectError < ::Sequel::DatabaseError; end

# source://sequel//lib/sequel/exceptions.rb#31
class Sequel::DatabaseError < ::Sequel::Error; end

# source://sequel//lib/sequel/exceptions.rb#82
class Sequel::DatabaseLockTimeout < ::Sequel::DatabaseError; end

# A dataset represents an SQL query. Datasets
# can be used to select, insert, update and delete records.
#
# Query results are always retrieved on demand, so a dataset can be kept
# around and reused indefinitely (datasets never cache results):
#
#   my_posts = DB[:posts].where(author: 'david') # no records are retrieved
#   my_posts.all # records are retrieved
#   my_posts.all # records are retrieved again
#
# Datasets are frozen and use a functional style where modification methods
# return modified copies of the the dataset.  This allows you to reuse
# datasets:
#
#   posts = DB[:posts]
#   davids_posts = posts.where(author: 'david')
#   old_posts = posts.where{stamp < Date.today - 7}
#   davids_old_posts = davids_posts.where{stamp < Date.today - 7}
#
# Datasets are Enumerable objects, so they can be manipulated using many
# of the Enumerable methods, such as +map+ and +inject+.  Note that there are some methods
# that Dataset defines that override methods defined in Enumerable and result in different
# behavior, such as +select+ and +group_by+.
#
# For more information, see the {"Dataset Basics" guide}[rdoc-ref:doc/dataset_basics.rdoc].
#
# source://sequel//lib/sequel/dataset.rb#29
class Sequel::Dataset
  include ::Enumerable
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::StringMethods

  # Constructs a new Dataset instance with an associated database and
  # options. Datasets are usually constructed by invoking the Database#[] method:
  #
  #   DB[:posts]
  #
  # Sequel::Dataset is an abstract class that is not useful by itself. Each
  # database adapter provides a subclass of Sequel::Dataset, and has
  # the Database#dataset method return an instance of that subclass.
  #
  # @return [Dataset] a new instance of Dataset
  #
  # source://sequel//lib/sequel/dataset/misc.rb#25
  def initialize(db); end

  # Inserts the given argument into the database.  Returns self so it
  # can be used safely when chaining:
  #
  #   DB[:items] << {id: 0, name: 'Zero'} << DB[:old_items].select(:id, name)
  #
  # source://sequel//lib/sequel/dataset/actions.rb#28
  def <<(arg); end

  # Define a hash value such that datasets with the same class, DB, and opts
  # will be considered equal.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#34
  def ==(o); end

  # Returns the first record matching the conditions. Examples:
  #
  #   DB[:table][id: 1] # SELECT * FROM table WHERE (id = 1) LIMIT 1
  #   # => {:id=>1}
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#37
  def [](*conditions); end

  # Adds the given graph aliases to the list of graph aliases to use,
  # unlike +set_graph_aliases+, which replaces the list (the equivalent
  # of +select_append+ when graphing).  See +set_graph_aliases+.
  #
  #   DB[:table].add_graph_aliases(some_alias: [:table, :column])
  #   # SELECT ..., table.column AS some_alias
  #
  # source://sequel//lib/sequel/dataset/graph.rb#18
  def add_graph_aliases(graph_aliases); end

  # Append literalization of aliased expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#273
  def aliased_expression_sql_append(sql, ae); end

  # Returns an array with all records in the dataset. If a block is given,
  # the array is iterated over after all items have been loaded.
  #
  #   DB[:table].all # SELECT * FROM table
  #   # => [{:id=>1, ...}, {:id=>2, ...}, ...]
  #
  #   # Iterate over all rows in the table
  #   DB[:table].all{|row| p row}
  #
  # source://sequel//lib/sequel/dataset/actions.rb#50
  def all(&block); end

  # Append literalization of array to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#279
  def array_sql_append(sql, a); end

  # Returns a hash with one column used as key and another used as value.
  # If rows have duplicate values for the key column, the latter row(s)
  # will overwrite the value of the previous row(s). If the value_column
  # is not given or nil, uses the entire hash as the value.
  #
  #   DB[:table].as_hash(:id, :name) # SELECT * FROM table
  #   # {1=>'Jim', 2=>'Bob', ...}
  #
  #   DB[:table].as_hash(:id) # SELECT * FROM table
  #   # {1=>{:id=>1, :name=>'Jim'}, 2=>{:id=>2, :name=>'Bob'}, ...}
  #
  # You can also provide an array of column names for either the key_column,
  # the value column, or both:
  #
  #   DB[:table].as_hash([:id, :foo], [:name, :bar]) # SELECT * FROM table
  #   # {[1, 3]=>['Jim', 'bo'], [2, 4]=>['Bob', 'be'], ...}
  #
  #   DB[:table].as_hash([:id, :name]) # SELECT * FROM table
  #   # {[1, 'Jim']=>{:id=>1, :name=>'Jim'}, [2, 'Bob']=>{:id=>2, :name=>'Bob'}, ...}
  #
  # Options:
  # :all :: Use all instead of each to retrieve the objects
  # :hash :: The object into which the values will be placed.  If this is not
  #          given, an empty hash is used.  This can be used to use a hash with
  #          a default value or default proc.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#843
  def as_hash(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Returns the average value for the given column/expression.
  # Uses a virtual row block if no argument is given.
  #
  #   DB[:table].avg(:number) # SELECT avg(number) FROM table LIMIT 1
  #   # => 3
  #   DB[:table].avg{function(column)} # SELECT avg(function(column)) FROM table LIMIT 1
  #   # => 1
  #
  # source://sequel//lib/sequel/dataset/actions.rb#61
  def avg(arg = T.unsafe(nil), &block); end

  # Set the bind variables to use for the call.  If bind variables have
  # already been set for this dataset, they are updated with the contents
  # of bind_vars.
  #
  #   DB[:table].where(id: :$id).bind(id: 1).call(:first)
  #   # SELECT * FROM table WHERE id = ? LIMIT 1 -- (1)
  #   # => {:id=>1}
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#332
  def bind(bind_vars = T.unsafe(nil)); end

  # Append literalization of boolean constant to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#290
  def boolean_constant_sql_append(sql, constant); end

  # For the given type (:select, :first, :insert, :insert_select, :update, :delete, or :single_value),
  # run the sql with the bind variables specified in the hash.  +values+ is a hash passed to
  # insert or update (if one of those types is used), which may contain placeholders.
  #
  #   DB[:table].where(id: :$id).call(:first, id: 1)
  #   # SELECT * FROM table WHERE id = ? LIMIT 1 -- (1)
  #   # => {:id=>1}
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#353
  def call(type, bind_variables = T.unsafe(nil), *values, &block); end

  # Append literalization of case expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#299
  def case_expression_sql_append(sql, ce); end

  # Append literalization of cast expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#319
  def cast_sql_append(sql, expr, type); end

  # :nocov:
  #
  # source://sequel//lib/sequel/dataset/query.rb#90
  def clone(opts = T.unsafe(nil)); end

  # Append literalization of column all selection to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#327
  def column_all_sql_append(sql, ca); end

  # Returns the columns in the result set in order as an array of symbols.
  # If the columns are currently cached, returns the cached value. Otherwise,
  # a SELECT query is performed to retrieve a single row in order to get the columns.
  #
  # If you are looking for all columns for a single table and maybe some information about
  # each column (e.g. database type), see <tt>Database#schema</tt>.
  #
  #   DB[:table].columns
  #   # => [:id, :name]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#75
  def columns; end

  # Ignore any cached column information and perform a query to retrieve
  # a row in order to get the columns.
  #
  #   DB[:table].columns!
  #   # => [:id, :name]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#84
  def columns!; end

  # Append literalization of complex expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#332
  def complex_expression_sql_append(sql, op, args); end

  # Append literalization of constant to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#441
  def constant_sql_append(sql, constant); end

  # Returns the number of records in the dataset. If an argument is provided,
  # it is used as the argument to count.  If a block is provided, it is
  # treated as a virtual row, and the result is used as the argument to
  # count.
  #
  #   DB[:table].count # SELECT count(*) AS count FROM table LIMIT 1
  #   # => 3
  #   DB[:table].count(:column) # SELECT count(column) AS count FROM table LIMIT 1
  #   # => 2
  #   DB[:table].count{foo(column)} # SELECT count(foo(column)) AS count FROM table LIMIT 1
  #   # => 1
  #
  # source://sequel//lib/sequel/dataset/actions.rb#108
  def count(arg = T.unsafe(nil), &block); end

  # source://sequel//lib/sequel/dataset/query.rb#629
  def cross_join(table, opts = T.unsafe(nil)); end

  # An object representing the current date or time, should be an instance
  # of Sequel.datetime_class.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#40
  def current_datetime; end

  # The database related to this dataset.  This is the Database instance that
  # will execute all of this dataset's queries.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#12
  def db; end

  # Append literalization of delayed evaluation to SQL string,
  # causing the delayed evaluation proc to be evaluated.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#447
  def delayed_evaluation_sql_append(sql, delay); end

  # Deletes the records in the dataset, returning the number of records deleted.
  #
  #   DB[:table].delete # DELETE * FROM table
  #   # => 3
  #
  # Some databases support using multiple tables in a DELETE query. This requires
  # multiple FROM tables (JOINs can also be used). As multiple FROM tables use
  # an implicit CROSS JOIN, you should make sure your WHERE condition uses the
  # appropriate filters for the FROM tables:
  #
  #  DB.from(:a, :b).join(:c, :d=>Sequel[:b][:e]).where{{a[:f]=>b[:g], a[:id]=>c[:h]}}.
  #    delete
  #  # DELETE FROM a
  #  # USING b
  #  # INNER JOIN c ON (c.d = b.e)
  #  # WHERE ((a.f = b.g) AND (a.id = c.h))
  #
  # source://sequel//lib/sequel/dataset/actions.rb#142
  def delete(&block); end

  # source://sequel//lib/sequel/dataset/sql.rb#238
  def delete_sql; end

  # Returns a copy of the dataset with the SQL DISTINCT clause. The DISTINCT
  # clause is used to remove duplicate rows from the output.  If arguments
  # are provided, uses a DISTINCT ON clause, in which case it will only be
  # distinct on those columns, instead of all returned columns. If a block
  # is given, it is treated as a virtual row block, similar to +where+.
  # Raises an error if arguments are given and DISTINCT ON is not supported.
  #
  #  DB[:items].distinct # SQL: SELECT DISTINCT * FROM items
  #  DB[:items].order(:id).distinct(:id) # SQL: SELECT DISTINCT ON (id) * FROM items ORDER BY id
  #  DB[:items].order(:id).distinct{func(:id)} # SQL: SELECT DISTINCT ON (func(id)) * FROM items ORDER BY id
  #
  # There is support for emulating the DISTINCT ON support in MySQL, but it
  # does not support the ORDER of the dataset, and also doesn't work in many
  # cases if the ONLY_FULL_GROUP_BY sql_mode is used, which is the default on
  # MySQL 5.7.5+.
  #
  # source://sequel//lib/sequel/dataset/query.rb#129
  def distinct(*args, &block); end

  # Return self, as datasets are always frozen.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#50
  def dup; end

  # Iterates over the records in the dataset as they are yielded from the
  # database adapter, and returns self.
  #
  #   DB[:table].each{|row| p row} # SELECT * FROM table
  #
  # Note that this method is not safe to use on many adapters if you are
  # running additional queries inside the provided block.  If you are
  # running queries inside the block, you should use +all+ instead of +each+
  # for the outer queries, or use a separate thread or shard inside +each+.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#160
  def each; end

  # Yield a dataset for each server in the connection pool that is tied to that server.
  # Intended for use in sharded environments where all servers need to be modified
  # with the same data:
  #
  #   DB[:configs].where(key: 'setting').each_server{|ds| ds.update(value: 'new_value')}
  #
  # source://sequel//lib/sequel/dataset/misc.rb#59
  def each_server; end

  # Returns true if no records exist in the dataset, false otherwise
  #
  #   DB[:table].empty? # SELECT 1 AS one FROM table LIMIT 1
  #   # => false
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#175
  def empty?; end

  # Alias for ==
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/misc.rb#45
  def eql?(o); end

  # Returns the string with the LIKE metacharacters (% and _) escaped.
  # Useful for when the LIKE term is a user-provided string where metacharacters should not
  # be recognized. Example:
  #
  #   ds.escape_like("foo\\%_") # 'foo\\\%\_'
  #
  # source://sequel//lib/sequel/dataset/misc.rb#68
  def escape_like(string); end

  # Adds an EXCEPT clause using a second dataset object.
  # An EXCEPT compound dataset returns all rows in the current dataset
  # that are not in the given dataset.
  # Raises an +InvalidOperation+ if the operation is not supported.
  # Options:
  # :alias :: Use the given value as the from_self alias
  # :all :: Set to true to use EXCEPT ALL instead of EXCEPT, so duplicate rows can occur
  # :from_self :: Set to false to not wrap the returned dataset in a from_self, use with care.
  #
  #   DB[:items].except(DB[:other_items])
  #   # SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS t1
  #
  #   DB[:items].except(DB[:other_items], all: true, from_self: false)
  #   # SELECT * FROM items EXCEPT ALL SELECT * FROM other_items
  #
  #   DB[:items].except(DB[:other_items], alias: :i)
  #   # SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS i
  #
  # @raise [InvalidOperation]
  #
  # source://sequel//lib/sequel/dataset/query.rb#156
  def except(dataset, opts = T.unsafe(nil)); end

  # Performs the inverse of Dataset#where.  Note that if you have multiple filter
  # conditions, this is not the same as a negation of all conditions.
  #
  #   DB[:items].exclude(category: 'software')
  #   # SELECT * FROM items WHERE (category != 'software')
  #
  #   DB[:items].exclude(category: 'software', id: 3)
  #   # SELECT * FROM items WHERE ((category != 'software') OR (id != 3))
  #
  # Also note that SQL uses 3-valued boolean logic (+true+, +false+, +NULL+), so
  # the inverse of a true condition is a false condition, and will still
  # not match rows that were NULL originally.  If you take the earlier
  # example:
  #
  #   DB[:items].exclude(category: 'software')
  #   # SELECT * FROM items WHERE (category != 'software')
  #
  # Note that this does not match rows where +category+ is +NULL+.  This
  # is because +NULL+ is an unknown value, and you do not know whether
  # or not the +NULL+ category is +software+.  You can explicitly
  # specify how to handle +NULL+ values if you want:
  #
  #   DB[:items].exclude(Sequel.~(category: nil) & {category: 'software'})
  #   # SELECT * FROM items WHERE ((category IS NULL) OR (category != 'software'))
  #
  # source://sequel//lib/sequel/dataset/query.rb#186
  def exclude(*cond, &block); end

  # Inverts the given conditions and adds them to the HAVING clause.
  #
  #   DB[:items].select_group(:name).exclude_having{count(name) < 2}
  #   # SELECT name FROM items GROUP BY name HAVING (count(name) >= 2)
  #
  # See documentation for exclude for how inversion is handled in regards
  # to SQL 3-valued boolean logic.
  #
  # source://sequel//lib/sequel/dataset/query.rb#197
  def exclude_having(*cond, &block); end

  # Returns an EXISTS clause for the dataset as an SQL::PlaceholderLiteralString.
  #
  #   DB.select(1).where(DB[:items].exists)
  #   # SELECT 1 WHERE (EXISTS (SELECT * FROM items))
  #
  # source://sequel//lib/sequel/dataset/sql.rb#14
  def exists; end

  # :nocov:
  #
  # source://sequel//lib/sequel/dataset/query.rb#205
  def extension(*exts); end

  # Alias for where.
  #
  # source://sequel//lib/sequel/dataset/query.rb#225
  def filter(*cond, &block); end

  # Returns the first matching record if no arguments are given.
  # If a integer argument is given, it is interpreted as a limit, and then returns all
  # matching records up to that limit.  If any other type of
  # argument(s) is passed, it is treated as a filter and the
  # first matching record is returned.  If a block is given, it is used
  # to filter the dataset before returning anything.
  #
  # If there are no records in the dataset, returns nil (or an empty
  # array if an integer argument is given).
  #
  # Examples:
  #
  #   DB[:table].first # SELECT * FROM table LIMIT 1
  #   # => {:id=>7}
  #
  #   DB[:table].first(2) # SELECT * FROM table LIMIT 2
  #   # => [{:id=>6}, {:id=>4}]
  #
  #   DB[:table].first(id: 2) # SELECT * FROM table WHERE (id = 2) LIMIT 1
  #   # => {:id=>2}
  #
  #   DB[:table].first(Sequel.lit("id = 3")) # SELECT * FROM table WHERE (id = 3) LIMIT 1
  #   # => {:id=>3}
  #
  #   DB[:table].first(Sequel.lit("id = ?", 4)) # SELECT * FROM table WHERE (id = 4) LIMIT 1
  #   # => {:id=>4}
  #
  #   DB[:table].first{id > 2} # SELECT * FROM table WHERE (id > 2) LIMIT 1
  #   # => {:id=>5}
  #
  #   DB[:table].first(Sequel.lit("id > ?", 4)){id < 6} # SELECT * FROM table WHERE ((id > 4) AND (id < 6)) LIMIT 1
  #   # => {:id=>5}
  #
  #   DB[:table].first(2){id < 2} # SELECT * FROM table WHERE (id < 2) LIMIT 2
  #   # => [{:id=>1}]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#216
  def first(*args, &block); end

  # Calls first.  If first returns nil (signaling that no
  # row matches), raise a Sequel::NoMatchingRow exception.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#263
  def first!(*args, &block); end

  # Alias of +first_source_alias+
  #
  # source://sequel//lib/sequel/dataset/misc.rb#91
  def first_source; end

  # The first source (primary table) for this dataset.  If the dataset doesn't
  # have a table, raises an +Error+.  If the table is aliased, returns the aliased name.
  #
  #   DB[:table].first_source_alias
  #   # => :table
  #
  #   DB[Sequel[:table].as(:t)].first_source_alias
  #   # => :t
  #
  # source://sequel//lib/sequel/dataset/misc.rb#103
  def first_source_alias; end

  # The first source (primary table) for this dataset.  If the dataset doesn't
  # have a table, raises an error.  If the table is aliased, returns the original
  # table, not the alias
  #
  #   DB[:table].first_source_table
  #   # => :table
  #
  #   DB[Sequel[:table].as(:t)].first_source_table
  #   # => :table
  #
  # source://sequel//lib/sequel/dataset/misc.rb#128
  def first_source_table; end

  # Returns a cloned dataset with a :update lock style.
  #
  #   DB[:table].for_update # SELECT * FROM table FOR UPDATE
  #
  # source://sequel//lib/sequel/dataset/query.rb#232
  def for_update; end

  # :nocov:
  #
  # source://sequel//lib/sequel/dataset/misc.rb#74
  def freeze; end

  # Returns a copy of the dataset with the source changed. If no
  # source is given, removes all tables.  If multiple sources
  # are given, it is the same as using a CROSS JOIN (cartesian product) between all tables.
  # If a block is given, it is treated as a virtual row block, similar to +where+.
  #
  #   DB[:items].from # SQL: SELECT *
  #   DB[:items].from(:blah) # SQL: SELECT * FROM blah
  #   DB[:items].from(:blah, :foo) # SQL: SELECT * FROM blah, foo
  #   DB[:items].from{fun(arg)} # SQL: SELECT * FROM fun(arg)
  #
  # source://sequel//lib/sequel/dataset/query.rb#245
  def from(*source, &block); end

  # Returns a dataset selecting from the current dataset.
  # Options:
  # :alias :: Controls the alias of the table
  # :column_aliases :: Also aliases columns, using derived column lists.
  #                    Only used in conjunction with :alias.
  #
  #   ds = DB[:items].order(:name).select(:id, :name)
  #   # SELECT id,name FROM items ORDER BY name
  #
  #   ds.from_self
  #   # SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS t1
  #
  #   ds.from_self(alias: :foo)
  #   # SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS foo
  #
  #   ds.from_self(alias: :foo, column_aliases: [:c1, :c2])
  #   # SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS foo(c1, c2)
  #
  # source://sequel//lib/sequel/dataset/query.rb#293
  def from_self(opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def full_join(*args, &block); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def full_outer_join(*args, &block); end

  # Append literalization of function call to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#461
  def function_sql_append(sql, f); end

  # Return the column value for the first matching record in the dataset.
  # Raises an error if both an argument and block is given.
  #
  #   DB[:table].get(:id) # SELECT id FROM table LIMIT 1
  #   # => 3
  #
  #   ds.get{sum(id)} # SELECT sum(id) AS v FROM table LIMIT 1
  #   # => 6
  #
  # You can pass an array of arguments to return multiple arguments,
  # but you must make sure each element in the array has an alias that
  # Sequel can determine:
  #
  #   DB[:table].get([:id, :name]) # SELECT id, name FROM table LIMIT 1
  #   # => [3, 'foo']
  #
  #   DB[:table].get{[sum(id).as(sum), name]} # SELECT sum(id) AS sum, name FROM table LIMIT 1
  #   # => [6, 'foo']
  #
  # source://sequel//lib/sequel/dataset/actions.rb#285
  def get(column = T.unsafe(nil), &block); end

  # Similar to Dataset#join_table, but uses unambiguous aliases for selected
  # columns and keeps metadata about the aliases for use in other methods.
  #
  # Arguments:
  # dataset :: Can be a symbol (specifying a table), another dataset,
  #            or an SQL::Identifier, SQL::QualifiedIdentifier, or SQL::AliasedExpression.
  # join_conditions :: Any condition(s) allowed by +join_table+.
  # block :: A block that is passed to +join_table+.
  #
  # Options:
  # :from_self_alias :: The alias to use when the receiver is not a graphed
  #                     dataset but it contains multiple FROM tables or a JOIN.  In this case,
  #                     the receiver is wrapped in a from_self before graphing, and this option
  #                     determines the alias to use.
  # :implicit_qualifier :: The qualifier of implicit conditions, see #join_table.
  # :join_only :: Only join the tables, do not change the selected columns.
  # :join_type :: The type of join to use (passed to +join_table+).  Defaults to :left_outer.
  # :qualify:: The type of qualification to do, see #join_table.
  # :select :: An array of columns to select.  When not used, selects
  #            all columns in the given dataset.  When set to false, selects no
  #            columns and is like simply joining the tables, though graph keeps
  #            some metadata about the join that makes it important to use +graph+ instead
  #            of +join_table+.
  # :table_alias :: The alias to use for the table.  If not specified, doesn't
  #                 alias the table.  You will get an error if the alias (or table) name is
  #                 used more than once.
  #
  # source://sequel//lib/sequel/dataset/graph.rb#53
  def graph(dataset, join_conditions = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Match any of the columns to any of the patterns. The terms can be
  # strings (which use LIKE) or regular expressions if the database supports that.
  # Note that the total number of pattern matches will be
  # Array(columns).length * Array(terms).length,
  # which could cause performance issues.
  #
  # Options (all are boolean):
  #
  # :all_columns :: All columns must be matched to any of the given patterns.
  # :all_patterns :: All patterns must match at least one of the columns.
  # :case_insensitive :: Use a case insensitive pattern match (the default is
  #                      case sensitive if the database supports it).
  #
  # If both :all_columns and :all_patterns are true, all columns must match all patterns.
  #
  # Examples:
  #
  #   dataset.grep(:a, '%test%')
  #   # SELECT * FROM items WHERE (a LIKE '%test%' ESCAPE '\')
  #
  #   dataset.grep([:a, :b], %w'%test% foo')
  #   # SELECT * FROM items WHERE ((a LIKE '%test%' ESCAPE '\') OR (a LIKE 'foo' ESCAPE '\')
  #   #   OR (b LIKE '%test%' ESCAPE '\') OR (b LIKE 'foo' ESCAPE '\'))
  #
  #   dataset.grep([:a, :b], %w'%foo% %bar%', all_patterns: true)
  #   # SELECT * FROM a WHERE (((a LIKE '%foo%' ESCAPE '\') OR (b LIKE '%foo%' ESCAPE '\'))
  #   #   AND ((a LIKE '%bar%' ESCAPE '\') OR (b LIKE '%bar%' ESCAPE '\')))
  #
  #   dataset.grep([:a, :b], %w'%foo% %bar%', all_columns: true)
  #   # SELECT * FROM a WHERE (((a LIKE '%foo%' ESCAPE '\') OR (a LIKE '%bar%' ESCAPE '\'))
  #   #   AND ((b LIKE '%foo%' ESCAPE '\') OR (b LIKE '%bar%' ESCAPE '\')))
  #
  #   dataset.grep([:a, :b], %w'%foo% %bar%', all_patterns: true, all_columns: true)
  #   # SELECT * FROM a WHERE ((a LIKE '%foo%' ESCAPE '\') AND (b LIKE '%foo%' ESCAPE '\')
  #   #   AND (a LIKE '%bar%' ESCAPE '\') AND (b LIKE '%bar%' ESCAPE '\'))
  #
  # source://sequel//lib/sequel/dataset/query.rb#342
  def grep(columns, patterns, opts = T.unsafe(nil)); end

  # Returns a copy of the dataset with the results grouped by the value of
  # the given columns.  If a block is given, it is treated
  # as a virtual row block, similar to +where+.
  #
  #   DB[:items].group(:id) # SELECT * FROM items GROUP BY id
  #   DB[:items].group(:id, :name) # SELECT * FROM items GROUP BY id, name
  #   DB[:items].group{[a, sum(b)]} # SELECT * FROM items GROUP BY a, sum(b)
  #
  # source://sequel//lib/sequel/dataset/query.rb#364
  def group(*columns, &block); end

  # Returns a dataset grouped by the given column with count by group.
  # Column aliases may be supplied, and will be included in the select clause.
  # If a block is given, it is treated as a virtual row block, similar to +where+.
  #
  # Examples:
  #
  #   DB[:items].group_and_count(:name).all
  #   # SELECT name, count(*) AS count FROM items GROUP BY name
  #   # => [{:name=>'a', :count=>1}, ...]
  #
  #   DB[:items].group_and_count(:first_name, :last_name).all
  #   # SELECT first_name, last_name, count(*) AS count FROM items GROUP BY first_name, last_name
  #   # => [{:first_name=>'a', :last_name=>'b', :count=>1}, ...]
  #
  #   DB[:items].group_and_count(Sequel[:first_name].as(:name)).all
  #   # SELECT first_name AS name, count(*) AS count FROM items GROUP BY first_name
  #   # => [{:name=>'a', :count=>1}, ...]
  #
  #   DB[:items].group_and_count{substr(:first_name, 1, 1).as(:initial)}.all
  #   # SELECT substr(first_name, 1, 1) AS initial, count(*) AS count FROM items GROUP BY substr(first_name, 1, 1)
  #   # => [{:initial=>'a', :count=>1}, ...]
  #
  # source://sequel//lib/sequel/dataset/query.rb#395
  def group_and_count(*columns, &block); end

  # Returns a copy of the dataset with the given columns added to the list of
  # existing columns to group on. If no existing columns are present this
  # method simply sets the columns as the initial ones to group on.
  #
  #   DB[:items].group_append(:b) # SELECT * FROM items GROUP BY b
  #   DB[:items].group(:a).group_append(:b) # SELECT * FROM items GROUP BY a, b
  #
  # source://sequel//lib/sequel/dataset/query.rb#405
  def group_append(*columns, &block); end

  # Alias of group
  #
  # source://sequel//lib/sequel/dataset/query.rb#370
  def group_by(*columns, &block); end

  # Adds the appropriate CUBE syntax to GROUP BY.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/query.rb#411
  def group_cube; end

  # Adds the appropriate ROLLUP syntax to GROUP BY.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/query.rb#417
  def group_rollup; end

  # Adds the appropriate GROUPING SETS syntax to GROUP BY.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/query.rb#423
  def grouping_sets; end

  # Define a hash value such that datasets with the same class, DB, and opts,
  # will have the same hash value.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#146
  def hash; end

  # Returns a copy of the dataset with the HAVING conditions changed. See #where for argument types.
  #
  #   DB[:items].group(:sum).having(sum: 10)
  #   # SELECT * FROM items GROUP BY sum HAVING (sum = 10)
  #
  # source://sequel//lib/sequel/dataset/query.rb#432
  def having(*cond, &block); end

  # Inserts multiple records into the associated table. This method can be
  # used to efficiently insert a large number of records into a table in a
  # single query if the database supports it. Inserts are automatically
  # wrapped in a transaction if necessary.
  #
  # This method is called with a columns array and an array of value arrays:
  #
  #   DB[:table].import([:x, :y], [[1, 2], [3, 4]])
  #   # INSERT INTO table (x, y) VALUES (1, 2)
  #   # INSERT INTO table (x, y) VALUES (3, 4)
  #
  # or, if the database supports it:
  #
  #   # INSERT INTO table (x, y) VALUES (1, 2), (3, 4)
  #
  # This method also accepts a dataset instead of an array of value arrays:
  #
  #   DB[:table].import([:x, :y], DB[:table2].select(:a, :b))
  #   # INSERT INTO table (x, y) SELECT a, b FROM table2
  #
  # Options:
  # :commit_every :: Open a new transaction for every given number of
  #                  records. For example, if you provide a value of 50,
  #                  will commit after every 50 records. When a
  #                  transaction is not required, this option controls
  #                  the maximum number of values to insert with a single
  #                  statement; it does not force the use of a
  #                  transaction.
  # :return :: When this is set to :primary_key, returns an array of
  #            autoincremented primary key values for the rows inserted.
  #            This does not have an effect if +values+ is a Dataset.
  # :server :: Set the server/shard to use for the transaction and insert
  #            queries.
  # :slice :: Same as :commit_every, :commit_every takes precedence.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#360
  def import(columns, values, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def inner_join(*args, &block); end

  # Inserts values into the associated table.  The returned value is generally
  # the value of the autoincremented primary key for the inserted row, assuming that
  # a single row is inserted and the table has an autoincrementing primary key.
  #
  # +insert+ handles a number of different argument formats:
  # no arguments or single empty hash :: Uses DEFAULT VALUES
  # single hash :: Most common format, treats keys as columns and values as values
  # single array :: Treats entries as values, with no columns
  # two arrays :: Treats first array as columns, second array as values
  # single Dataset :: Treats as an insert based on a selection from the dataset given,
  #                   with no columns
  # array and dataset :: Treats as an insert based on a selection from the dataset
  #                      given, with the columns given by the array.
  #
  # Examples:
  #
  #   DB[:items].insert
  #   # INSERT INTO items DEFAULT VALUES
  #
  #   DB[:items].insert({})
  #   # INSERT INTO items DEFAULT VALUES
  #
  #   DB[:items].insert([1,2,3])
  #   # INSERT INTO items VALUES (1, 2, 3)
  #
  #   DB[:items].insert([:a, :b], [1,2])
  #   # INSERT INTO items (a, b) VALUES (1, 2)
  #
  #   DB[:items].insert(a: 1, b: 2)
  #   # INSERT INTO items (a, b) VALUES (1, 2)
  #
  #   DB[:items].insert(DB[:old_items])
  #   # INSERT INTO items SELECT * FROM old_items
  #
  #   DB[:items].insert([:a, :b], DB[:old_items])
  #   # INSERT INTO items (a, b) SELECT * FROM old_items
  #
  # source://sequel//lib/sequel/dataset/actions.rb#416
  def insert(*values, &block); end

  # Returns an INSERT SQL query string.  See +insert+.
  #
  #   DB[:items].insert_sql(a: 1)
  #   # => "INSERT INTO items (a) VALUES (1)"
  #
  # source://sequel//lib/sequel/dataset/sql.rb#22
  def insert_sql(*values); end

  # Returns a string representation of the dataset including the class name
  # and the corresponding SQL select statement.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#152
  def inspect; end

  # Adds an INTERSECT clause using a second dataset object.
  # An INTERSECT compound dataset returns all rows in both the current dataset
  # and the given dataset.
  # Raises an +InvalidOperation+ if the operation is not supported.
  # Options:
  # :alias :: Use the given value as the from_self alias
  # :all :: Set to true to use INTERSECT ALL instead of INTERSECT, so duplicate rows can occur
  # :from_self :: Set to false to not wrap the returned dataset in a from_self, use with care.
  #
  #   DB[:items].intersect(DB[:other_items])
  #   # SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS t1
  #
  #   DB[:items].intersect(DB[:other_items], all: true, from_self: false)
  #   # SELECT * FROM items INTERSECT ALL SELECT * FROM other_items
  #
  #   DB[:items].intersect(DB[:other_items], alias: :i)
  #   # SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS i
  #
  # @raise [InvalidOperation]
  #
  # source://sequel//lib/sequel/dataset/query.rb#453
  def intersect(dataset, opts = T.unsafe(nil)); end

  # Inverts the current WHERE and HAVING clauses.  If there is neither a
  # WHERE or HAVING clause, adds a WHERE clause that is always false.
  #
  #   DB[:items].where(category: 'software').invert
  #   # SELECT * FROM items WHERE (category != 'software')
  #
  #   DB[:items].where(category: 'software', id: 3).invert
  #   # SELECT * FROM items WHERE ((category != 'software') OR (id != 3))
  #
  # See documentation for exclude for how inversion is handled in regards
  # to SQL 3-valued boolean logic.
  #
  # source://sequel//lib/sequel/dataset/query.rb#470
  def invert; end

  # Alias of +inner_join+
  #
  # source://sequel//lib/sequel/dataset/query.rb#485
  def join(*args, &block); end

  # Append literalization of JOIN clause without ON or USING to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#546
  def join_clause_sql_append(sql, jc); end

  # Append literalization of JOIN ON clause to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#556
  def join_on_clause_sql_append(sql, jc); end

  # Returns a joined dataset.  Not usually called directly, users should use the
  # appropriate join method (e.g. join, left_join, natural_join, cross_join) which fills
  # in the +type+ argument.
  #
  # Takes the following arguments:
  #
  # type :: The type of join to do (e.g. :inner)
  # table :: table to join into the current dataset.  Generally one of the following types:
  #          String, Symbol :: identifier used as table or view name
  #          Dataset :: a subselect is performed with an alias of tN for some value of N
  #          SQL::Function :: set returning function
  #          SQL::AliasedExpression :: already aliased expression.  Uses given alias unless
  #                                    overridden by the :table_alias option.
  # expr :: conditions used when joining, depends on type:
  #         Hash, Array of pairs :: Assumes key (1st arg) is column of joined table (unless already
  #                                 qualified), and value (2nd arg) is column of the last joined or
  #                                 primary table (or the :implicit_qualifier option).
  #                                 To specify multiple conditions on a single joined table column,
  #                                 you must use an array.  Uses a JOIN with an ON clause.
  #         Array :: If all members of the array are symbols, considers them as columns and
  #                  uses a JOIN with a USING clause.  Most databases will remove duplicate columns from
  #                  the result set if this is used.
  #         nil :: If a block is not given, doesn't use ON or USING, so the JOIN should be a NATURAL
  #                or CROSS join. If a block is given, uses an ON clause based on the block, see below.
  #         otherwise :: Treats the argument as a filter expression, so strings are considered literal, symbols
  #                      specify boolean columns, and Sequel expressions can be used. Uses a JOIN with an ON clause.
  # options :: a hash of options, with the following keys supported:
  #            :table_alias :: Override the table alias used when joining.  In general you shouldn't use this
  #                            option, you should provide the appropriate SQL::AliasedExpression as the table
  #                            argument.
  #            :implicit_qualifier :: The name to use for qualifying implicit conditions.  By default,
  #                                   the last joined or primary table is used.
  #            :join_using :: Force the using of JOIN USING, even if +expr+ is not an array of symbols.
  #            :reset_implicit_qualifier :: Can set to false to ignore this join when future joins determine qualifier
  #                                         for implicit conditions.
  #            :qualify :: Can be set to false to not do any implicit qualification.  Can be set
  #                        to :deep to use the Qualifier AST Transformer, which will attempt to qualify
  #                        subexpressions of the expression tree.  Can be set to :symbol to only qualify
  #                        symbols. Defaults to the value of default_join_table_qualification.
  # block :: The block argument should only be given if a JOIN with an ON clause is used,
  #          in which case it yields the table alias/name for the table currently being joined,
  #          the table alias/name for the last joined (or first table), and an array of previous
  #          SQL::JoinClause. Unlike +where+, this block is not treated as a virtual row block.
  #
  # Examples:
  #
  #   DB[:a].join_table(:cross, :b)
  #   # SELECT * FROM a CROSS JOIN b
  #
  #   DB[:a].join_table(:inner, DB[:b], c: d)
  #   # SELECT * FROM a INNER JOIN (SELECT * FROM b) AS t1 ON (t1.c = a.d)
  #
  #   DB[:a].join_table(:left, Sequel[:b].as(:c), [:d])
  #   # SELECT * FROM a LEFT JOIN b AS c USING (d)
  #
  #   DB[:a].natural_join(:b).join_table(:inner, :c) do |ta, jta, js|
  #     (Sequel.qualify(ta, :d) > Sequel.qualify(jta, :e)) & {Sequel.qualify(ta, :f)=>DB.from(js.first.table).select(:g)}
  #   end
  #   # SELECT * FROM a NATURAL JOIN b INNER JOIN c
  #   #   ON ((c.d > b.e) AND (c.f IN (SELECT g FROM b)))
  #
  # source://sequel//lib/sequel/dataset/query.rb#549
  def join_table(type, table, expr = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Append literalization of JOIN USING clause to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#563
  def join_using_clause_sql_append(sql, jc); end

  # Whether this dataset is a joined dataset (multiple FROM tables or any JOINs).
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/misc.rb#157
  def joined_dataset?; end

  # Reverses the order and then runs #first with the given arguments and block.  Note that this
  # will not necessarily give you the last record in the dataset,
  # unless you have an unambiguous order.  If there is not
  # currently an order for this dataset, raises an +Error+.
  #
  #   DB[:table].order(:id).last # SELECT * FROM table ORDER BY id DESC LIMIT 1
  #   # => {:id=>10}
  #
  #   DB[:table].order(Sequel.desc(:id)).last(2) # SELECT * FROM table ORDER BY id ASC LIMIT 2
  #   # => [{:id=>1}, {:id=>2}]
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#435
  def last(*args, &block); end

  # Marks this dataset as a lateral dataset.  If used in another dataset's FROM
  # or JOIN clauses, it will surround the subquery with LATERAL to enable it
  # to deal with previous tables in the query:
  #
  #   DB.from(:a, DB[:b].where(Sequel[:a][:c]=>Sequel[:b][:d]).lateral)
  #   # SELECT * FROM a, LATERAL (SELECT * FROM b WHERE (a.c = b.d))
  #
  # source://sequel//lib/sequel/dataset/query.rb#643
  def lateral; end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def left_join(*args, &block); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def left_outer_join(*args, &block); end

  # If given an integer, the dataset will contain only the first l results.
  # If given a range, it will contain only those at offsets within that
  # range. If a second argument is given, it is used as an offset. To use
  # an offset without a limit, pass nil as the first argument.
  #
  #   DB[:items].limit(10) # SELECT * FROM items LIMIT 10
  #   DB[:items].limit(10, 20) # SELECT * FROM items LIMIT 10 OFFSET 20
  #   DB[:items].limit(10...20) # SELECT * FROM items LIMIT 10 OFFSET 10
  #   DB[:items].limit(10..20) # SELECT * FROM items LIMIT 11 OFFSET 10
  #   DB[:items].limit(nil, 20) # SELECT * FROM items OFFSET 20
  #
  # source://sequel//lib/sequel/dataset/query.rb#657
  def limit(l, o = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/sql.rb#264
  def literal(*args, &block); end

  # Append a literal representation of a value to the given SQL string.
  #
  # If an unsupported object is given, an +Error+ is raised.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#40
  def literal_append(sql, v); end

  # Returns a cloned dataset with the given lock style.  If style is a
  # string, it will be used directly. You should never pass a string
  # to this method that is derived from user input, as that can lead to
  # SQL injection.
  #
  # A symbol may be used for database independent locking behavior, but
  # all supported symbols have separate methods (e.g. for_update).
  #
  #   DB[:items].lock_style('FOR SHARE NOWAIT')
  #   # SELECT * FROM items FOR SHARE NOWAIT
  #   DB[:items].lock_style('FOR UPDATE OF table1 SKIP LOCKED')
  #   # SELECT * FROM items FOR UPDATE OF table1 SKIP LOCKED
  #
  # source://sequel//lib/sequel/dataset/query.rb#687
  def lock_style(style); end

  # Maps column values for each record in the dataset (if an argument is given)
  # or performs the stock mapping functionality of +Enumerable+ otherwise.
  # Raises an +Error+ if both an argument and block are given.
  #
  #   DB[:table].map(:id) # SELECT * FROM table
  #   # => [1, 2, 3, ...]
  #
  #   DB[:table].map{|r| r[:id] * 2} # SELECT * FROM table
  #   # => [2, 4, 6, ...]
  #
  # You can also provide an array of column names:
  #
  #   DB[:table].map([:id, :name]) # SELECT * FROM table
  #   # => [[1, 'A'], [2, 'B'], [3, 'C'], ...]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#454
  def map(column = T.unsafe(nil), &block); end

  # Returns the maximum value for the given column/expression.
  # Uses a virtual row block if no argument is given.
  #
  #   DB[:table].max(:id) # SELECT max(id) FROM table LIMIT 1
  #   # => 10
  #   DB[:table].max{function(column)} # SELECT max(function(column)) FROM table LIMIT 1
  #   # => 7
  #
  # source://sequel//lib/sequel/dataset/actions.rb#475
  def max(arg = T.unsafe(nil), &block); end

  # Execute a MERGE statement, which allows for INSERT, UPDATE, and DELETE
  # behavior in a single query, based on whether rows from a source table
  # match rows in the current table, based on the join conditions.
  #
  # Unless the dataset uses static SQL, to use #merge, you must first have
  # called #merge_using to specify the merge source and join conditions.
  # You will then likely to call one or more of the following methods
  # to specify MERGE behavior by adding WHEN [NOT] MATCHED clauses:
  #
  # * #merge_insert
  # * #merge_update
  # * #merge_delete
  #
  # The WHEN [NOT] MATCHED clauses are added to the SQL in the order these
  # methods were called on the dataset.  If none of these methods are
  # called, an error is raised.
  #
  # Example:
  #
  #   DB[:m1]
  #     merge_using(:m2, i1: :i2).
  #     merge_insert(i1: :i2, a: Sequel[:b]+11).
  #     merge_delete{a > 30}.
  #     merge_update(i1: Sequel[:i1]+:i2+10, a: Sequel[:a]+:b+20).
  #     merge
  #
  # SQL:
  #
  #   MERGE INTO m1 USING m2 ON (i1 = i2)
  #   WHEN NOT MATCHED THEN INSERT (i1, a) VALUES (i2, (b + 11))
  #   WHEN MATCHED AND (a > 30) THEN DELETE
  #   WHEN MATCHED THEN UPDATE SET i1 = (i1 + i2 + 10), a = (a + b + 20)
  #
  # On PostgreSQL, two additional merge methods are supported, for the
  # PostgreSQL-specific DO NOTHING syntax.
  #
  # * #merge_do_nothing_when_matched
  # * #merge_do_nothing_when_not_matched
  #
  # This method is supported on Oracle, but Oracle's MERGE support is
  # non-standard, and has the following issues:
  #
  # * DELETE clause requires UPDATE clause
  # * DELETE clause requires a condition
  # * DELETE clause only affects rows updated by UPDATE clause
  #
  # source://sequel//lib/sequel/dataset/actions.rb#525
  def merge; end

  # Return a dataset with a WHEN MATCHED THEN DELETE clause added to the
  # MERGE statement.  If a block is passed, treat it as a virtual row and
  # use it as additional conditions for the match.
  #
  #   merge_delete
  #   # WHEN MATCHED THEN DELETE
  #
  #   merge_delete{a > 30}
  #   # WHEN MATCHED AND (a > 30) THEN DELETE
  #
  # source://sequel//lib/sequel/dataset/query.rb#700
  def merge_delete(&block); end

  # Return a dataset with a WHEN NOT MATCHED THEN INSERT clause added to the
  # MERGE statement.  If a block is passed, treat it as a virtual row and
  # use it as additional conditions for the match.
  #
  # The arguments provided can be any arguments that would be accepted by
  # #insert.
  #
  #   merge_insert(i1: :i2, a: Sequel[:b]+11)
  #   # WHEN NOT MATCHED THEN INSERT (i1, a) VALUES (i2, (b + 11))
  #
  #   merge_insert(:i2, Sequel[:b]+11){a > 30}
  #   # WHEN NOT MATCHED AND (a > 30) THEN INSERT VALUES (i2, (b + 11))
  #
  # source://sequel//lib/sequel/dataset/query.rb#716
  def merge_insert(*values, &block); end

  # The SQL to use for the MERGE statement.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#94
  def merge_sql; end

  # Return a dataset with a WHEN MATCHED THEN UPDATE clause added to the
  # MERGE statement.  If a block is passed, treat it as a virtual row and
  # use it as additional conditions for the match.
  #
  #   merge_update(i1: Sequel[:i1]+:i2+10, a: Sequel[:a]+:b+20)
  #   # WHEN MATCHED THEN UPDATE SET i1 = (i1 + i2 + 10), a = (a + b + 20)
  #
  #   merge_update(i1: :i2){a > 30}
  #   # WHEN MATCHED AND (a > 30) THEN UPDATE SET i1 = i2
  #
  # source://sequel//lib/sequel/dataset/query.rb#729
  def merge_update(values, &block); end

  # Return a dataset with the source and join condition to use for the MERGE statement.
  #
  #   merge_using(:m2, i1: :i2)
  #   # USING m2 ON (i1 = i2)
  #
  # source://sequel//lib/sequel/dataset/query.rb#737
  def merge_using(source, join_condition); end

  # Returns the minimum value for the given column/expression.
  # Uses a virtual row block if no argument is given.
  #
  #   DB[:table].min(:id) # SELECT min(id) FROM table LIMIT 1
  #   # => 1
  #   DB[:table].min{function(column)} # SELECT min(function(column)) FROM table LIMIT 1
  #   # => 0
  #
  # source://sequel//lib/sequel/dataset/actions.rb#536
  def min(arg = T.unsafe(nil), &block); end

  # This is a front end for import that allows you to submit an array of
  # hashes instead of arrays of columns and values:
  #
  #   DB[:table].multi_insert([{x: 1}, {x: 2}])
  #   # INSERT INTO table (x) VALUES (1)
  #   # INSERT INTO table (x) VALUES (2)
  #
  # Be aware that all hashes should have the same keys if you use this calling method,
  # otherwise some columns could be missed or set to null instead of to default
  # values.
  #
  # This respects the same options as #import.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#553
  def multi_insert(hashes, opts = T.unsafe(nil)); end

  # Returns an array of insert statements for inserting multiple records.
  # This method is used by +multi_insert+ to format insert statements and
  # expects a keys array and and an array of value arrays.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#121
  def multi_insert_sql(columns, values); end

  # Returns a cloned dataset without a row_proc.
  #
  #   ds = DB[:items].with_row_proc(:invert.to_proc)
  #   ds.all # => [{2=>:id}]
  #   ds.naked.all # => [{:id=>2}]
  #
  # source://sequel//lib/sequel/dataset/query.rb#746
  def naked; end

  # source://sequel//lib/sequel/dataset/query.rb#629
  def natural_full_join(table, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/query.rb#629
  def natural_join(table, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/query.rb#629
  def natural_left_join(table, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/query.rb#629
  def natural_right_join(table, opts = T.unsafe(nil)); end

  # Append literalization of negative boolean constant to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#569
  def negative_boolean_constant_sql_append(sql, constant); end

  # Returns a copy of the dataset that will raise a DatabaseLockTimeout instead
  # of waiting for rows that are locked by another transaction
  #
  #   DB[:items].for_update.nowait
  #   # SELECT * FROM items FOR UPDATE NOWAIT
  #
  # source://sequel//lib/sequel/dataset/query.rb#755
  def nowait; end

  # Returns a copy of the dataset with a specified order. Can be safely combined with limit.
  # If you call limit with an offset, it will override the offset if you've called
  # offset first.
  #
  #   DB[:items].offset(10) # SELECT * FROM items OFFSET 10
  #
  # source://sequel//lib/sequel/dataset/query.rb#767
  def offset(o); end

  # The hash of options for this dataset, keys are symbols.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#15
  def opts; end

  # Adds an alternate filter to an existing WHERE clause using OR.  If there
  # is no WHERE clause, then the default is WHERE true, and OR would be redundant,
  # so return the dataset in that case.
  #
  #   DB[:items].where(:a).or(:b) # SELECT * FROM items WHERE a OR b
  #   DB[:items].or(:b) # SELECT * FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#781
  def or(*cond, &block); end

  # Returns a copy of the dataset with the order changed. If the dataset has an
  # existing order, it is ignored and overwritten with this order. If a nil is given
  # the returned dataset has no order. This can accept multiple arguments
  # of varying kinds, such as SQL functions.  If a block is given, it is treated
  # as a virtual row block, similar to +where+.
  #
  #   DB[:items].order(:name) # SELECT * FROM items ORDER BY name
  #   DB[:items].order(:a, :b) # SELECT * FROM items ORDER BY a, b
  #   DB[:items].order(Sequel.lit('a + b')) # SELECT * FROM items ORDER BY a + b
  #   DB[:items].order(Sequel[:a] + :b) # SELECT * FROM items ORDER BY (a + b)
  #   DB[:items].order(Sequel.desc(:name)) # SELECT * FROM items ORDER BY name DESC
  #   DB[:items].order(Sequel.asc(:name, nulls: :last)) # SELECT * FROM items ORDER BY name ASC NULLS LAST
  #   DB[:items].order{sum(name).desc} # SELECT * FROM items ORDER BY sum(name) DESC
  #   DB[:items].order(nil) # SELECT * FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#803
  def order(*columns, &block); end

  # Returns a copy of the dataset with the order columns added
  # to the end of the existing order.
  #
  #   DB[:items].order(:a).order(:b) # SELECT * FROM items ORDER BY b
  #   DB[:items].order(:a).order_append(:b) # SELECT * FROM items ORDER BY a, b
  #
  # source://sequel//lib/sequel/dataset/query.rb#813
  def order_append(*columns, &block); end

  # Alias of order
  #
  # source://sequel//lib/sequel/dataset/query.rb#819
  def order_by(*columns, &block); end

  # Alias of order_append.
  #
  # source://sequel//lib/sequel/dataset/query.rb#824
  def order_more(*columns, &block); end

  # Returns a copy of the dataset with the order columns added
  # to the beginning of the existing order.
  #
  #   DB[:items].order(:a).order(:b) # SELECT * FROM items ORDER BY b
  #   DB[:items].order(:a).order_prepend(:b) # SELECT * FROM items ORDER BY b, a
  #
  # source://sequel//lib/sequel/dataset/query.rb#833
  def order_prepend(*columns, &block); end

  # Append literalization of ordered expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#575
  def ordered_expression_sql_append(sql, oe); end

  # Yields each row in the dataset, but internally uses multiple queries as needed to
  # process the entire result set without keeping all rows in the dataset in memory,
  # even if the underlying driver buffers all query results in memory.
  #
  # Because this uses multiple queries internally, in order to remain consistent,
  # it also uses a transaction internally.  Additionally, to work correctly, the dataset
  # must have unambiguous order.  Using an ambiguous order can result in an infinite loop,
  # as well as subtler bugs such as yielding duplicate rows or rows being skipped.
  #
  # Sequel checks that the datasets using this method have an order, but it cannot
  # ensure that the order is unambiguous.
  #
  # Note that this method is not safe to use on many adapters if you are
  # running additional queries inside the provided block.  If you are
  # running queries inside the block, use a separate thread or shard inside +paged_each+.
  #
  # Options:
  # :rows_per_fetch :: The number of rows to fetch per query.  Defaults to 1000.
  # :strategy :: The strategy to use for paging of results.  By default this is :offset,
  #              for using an approach with a limit and offset for every page.  This can
  #              be set to :filter, which uses a limit and a filter that excludes
  #              rows from previous pages.  In order for this strategy to work, you must be
  #              selecting the columns you are ordering by, and none of the columns can contain
  #              NULLs.  Note that some Sequel adapters have optimized implementations that will
  #              use cursors or streaming regardless of the :strategy option used.
  # :filter_values :: If the strategy: :filter option is used, this option should be a proc
  #                   that accepts the last retrieved row for the previous page and an array of
  #                   ORDER BY expressions, and returns an array of values relating to those
  #                   expressions for the last retrieved row.  You will need to use this option
  #                   if your ORDER BY expressions are not simple columns, if they contain
  #                   qualified identifiers that would be ambiguous unqualified, if they contain
  #                   any identifiers that are aliased in SELECT, and potentially other cases.
  #
  # Examples:
  #
  #   DB[:table].order(:id).paged_each{|row| }
  #   # SELECT * FROM table ORDER BY id LIMIT 1000
  #   # SELECT * FROM table ORDER BY id LIMIT 1000 OFFSET 1000
  #   # ...
  #
  #   DB[:table].order(:id).paged_each(rows_per_fetch: 100){|row| }
  #   # SELECT * FROM table ORDER BY id LIMIT 100
  #   # SELECT * FROM table ORDER BY id LIMIT 100 OFFSET 100
  #   # ...
  #
  #   DB[:table].order(:id).paged_each(strategy: :filter){|row| }
  #   # SELECT * FROM table ORDER BY id LIMIT 1000
  #   # SELECT * FROM table WHERE id > 1001 ORDER BY id LIMIT 1000
  #   # ...
  #
  #   DB[:table].order(:id).paged_each(strategy: :filter,
  #     filter_values: lambda{|row, exprs| [row[:id]]}){|row| }
  #   # SELECT * FROM table ORDER BY id LIMIT 1000
  #   # SELECT * FROM table WHERE id > 1001 ORDER BY id LIMIT 1000
  #   # ...
  #
  # source://sequel//lib/sequel/dataset/actions.rb#614
  def paged_each(opts = T.unsafe(nil)); end

  # Append literalization of placeholder literal string to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#604
  def placeholder_literal_string_sql_append(sql, pls); end

  # The class to use for placeholder literalizers for the current dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#162
  def placeholder_literalizer_class; end

  # A placeholder literalizer loader for the current dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#167
  def placeholder_literalizer_loader(&block); end

  # Prepare an SQL statement for later execution.  Takes a type similar to #call,
  # and the +name+ symbol of the prepared statement.
  #
  # This returns a clone of the dataset extended with PreparedStatementMethods,
  # which you can +call+ with the hash of bind variables to use.
  # The prepared statement is also stored in
  # the associated Database, where it can be called by name.
  # The following usage is identical:
  #
  #   ps = DB[:table].where(name: :$name).prepare(:first, :select_by_name)
  #
  #   ps.call(name: 'Blah')
  #   # SELECT * FROM table WHERE name = ? -- ('Blah')
  #   # => {:id=>1, :name=>'Blah'}
  #
  #   DB.call(:select_by_name, name: 'Blah') # Same thing
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#373
  def prepare(type, name, *values); end

  # Whether this dataset will provide accurate number of rows matched for
  # delete and update statements, true by default.  Accurate in this case is the number of
  # rows matched by the dataset's filter.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#19
  def provides_accurate_rows_matched?; end

  # Append literalization of qualified identifier to SQL string.
  # If 3 arguments are given, the 2nd should be the table/qualifier and the third should be
  # column/qualified.  If 2 arguments are given, the 2nd should be an SQL::QualifiedIdentifier.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#650
  def qualified_identifier_sql_append(sql, table, column = T.unsafe(nil)); end

  # Qualify to the given table, or first source if no table is given.
  #
  #   DB[:items].where(id: 1).qualify
  #   # SELECT items.* FROM items WHERE (items.id = 1)
  #
  #   DB[:items].where(id: 1).qualify(:i)
  #   # SELECT i.* FROM items WHERE (i.id = 1)
  #
  # source://sequel//lib/sequel/dataset/query.rb#845
  def qualify(table = T.unsafe(nil)); end

  # source://sequel//lib/sequel/dataset/sql.rb#264
  def quote_identifier(*args, &block); end

  # Append literalization of unqualified identifier to SQL string.
  # Adds quoting to identifiers (columns and tables). If identifiers are not
  # being quoted, returns name as a string.  If identifiers are being quoted
  # quote the name with quoted_identifier.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#660
  def quote_identifier_append(sql, name); end

  # Whether this dataset quotes identifiers.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#12
  def quote_identifiers?; end

  # source://sequel//lib/sequel/dataset/sql.rb#264
  def quote_schema_table(*args, &block); end

  # Append literalization of identifier or unqualified identifier to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#675
  def quote_schema_table_append(sql, table); end

  # Append literalization of quoted identifier to SQL string.
  # This method quotes the given name with the SQL standard double quote.
  # should be overridden by subclasses to provide quoting not matching the
  # SQL standard, such as backtick (used by MySQL and SQLite).
  #
  # source://sequel//lib/sequel/dataset/sql.rb#688
  def quoted_identifier_append(sql, name); end

  # Whether you must use a column alias list for recursive CTEs, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#24
  def recursive_cte_requires_column_aliases?; end

  # Whether type specifiers are required for prepared statement/bound
  # variable argument placeholders (i.e. :bv__integer), false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#36
  def requires_placeholder_type_specifiers?; end

  # Whether the dataset requires SQL standard datetimes. False by default,
  # as most allow strings with ISO 8601 format.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#30
  def requires_sql_standard_datetimes?; end

  # Modify the RETURNING clause, only supported on a few databases.  If returning
  # is used, instead of insert returning the autogenerated primary key or
  # update/delete returning the number of modified rows, results are
  # returned using +fetch_rows+.
  #
  #   DB[:items].returning # RETURNING *
  #   DB[:items].returning(nil) # RETURNING NULL
  #   DB[:items].returning(:id, :name) # RETURNING id, name
  #
  #   DB[:items].returning.insert(a: 1) do |hash|
  #     # hash for each row inserted, with values for all columns
  #   end
  #   DB[:items].returning.update(a: 1) do |hash|
  #     # hash for each row updated, with values for all columns
  #   end
  #   DB[:items].returning.delete(a: 1) do |hash|
  #     # hash for each row deleted, with values for all columns
  #   end
  #
  # source://sequel//lib/sequel/dataset/query.rb#879
  def returning(*values); end

  # Returns a copy of the dataset with the order reversed. If no order is
  # given, the existing order is inverted.
  #
  #   DB[:items].reverse(:id) # SELECT * FROM items ORDER BY id DESC
  #   DB[:items].reverse{foo(bar)} # SELECT * FROM items ORDER BY foo(bar) DESC
  #   DB[:items].order(:id).reverse # SELECT * FROM items ORDER BY id DESC
  #   DB[:items].order(:id).reverse(Sequel.desc(:name)) # SELECT * FROM items ORDER BY name ASC
  #
  # source://sequel//lib/sequel/dataset/query.rb#898
  def reverse(*order, &block); end

  # Alias of +reverse+
  #
  # source://sequel//lib/sequel/dataset/query.rb#908
  def reverse_order(*order, &block); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def right_join(*args, &block); end

  # source://sequel//lib/sequel/dataset/query.rb#625
  def right_outer_join(*args, &block); end

  # The alias to use for the row_number column, used when emulating OFFSET
  # support and for eager limit strategies
  #
  # source://sequel//lib/sequel/dataset/misc.rb#173
  def row_number_column; end

  # The row_proc for this database, should be any object that responds to +call+ with
  # a single hash argument and returns the object you want #each to return.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#179
  def row_proc; end

  # Split the schema information from the table, returning two strings,
  # one for the schema and one for the table.  The returned schema may
  # be nil, but the table will always have a string value.
  #
  # Note that this function does not handle tables with more than one
  # level of qualification (e.g. database.schema.table on Microsoft
  # SQL Server).
  #
  # source://sequel//lib/sequel/dataset/sql.rb#699
  def schema_and_table(table_name, sch = T.unsafe(nil)); end

  # Returns a copy of the dataset with the columns selected changed
  # to the given columns. This also takes a virtual row block,
  # similar to +where+.
  #
  #   DB[:items].select(:a) # SELECT a FROM items
  #   DB[:items].select(:a, :b) # SELECT a, b FROM items
  #   DB[:items].select{[a, sum(b)]} # SELECT a, sum(b) FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#919
  def select(*columns, &block); end

  # Returns a copy of the dataset selecting the wildcard if no arguments
  # are given.  If arguments are given, treat them as tables and select
  # all columns (using the wildcard) from each table.
  #
  #   DB[:items].select(:a).select_all # SELECT * FROM items
  #   DB[:items].select_all(:items) # SELECT items.* FROM items
  #   DB[:items].select_all(:items, :foo) # SELECT items.*, foo.* FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#931
  def select_all(*tables); end

  # Returns a copy of the dataset with the given columns added
  # to the existing selected columns.  If no columns are currently selected,
  # it will select the columns given in addition to *.
  #
  #   DB[:items].select(:a).select(:b) # SELECT b FROM items
  #   DB[:items].select(:a).select_append(:b) # SELECT a, b FROM items
  #   DB[:items].select_append(:b) # SELECT *, b FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#946
  def select_append(*columns, &block); end

  # Set both the select and group clauses with the given +columns+.
  # Column aliases may be supplied, and will be included in the select clause.
  # This also takes a virtual row block similar to +where+.
  #
  #   DB[:items].select_group(:a, :b)
  #   # SELECT a, b FROM items GROUP BY a, b
  #
  #   DB[:items].select_group(Sequel[:c].as(:a)){f(c2)}
  #   # SELECT c AS a, f(c2) FROM items GROUP BY c, f(c2)
  #
  # source://sequel//lib/sequel/dataset/query.rb#966
  def select_group(*columns, &block); end

  # Returns a hash with key_column values as keys and value_column values as
  # values.  Similar to as_hash, but only selects the columns given.  Like
  # as_hash, it accepts an optional :hash parameter, into which entries will
  # be merged.
  #
  #   DB[:table].select_hash(:id, :name)
  #   # SELECT id, name FROM table
  #   # => {1=>'a', 2=>'b', ...}
  #
  # You can also provide an array of column names for either the key_column,
  # the value column, or both:
  #
  #   DB[:table].select_hash([:id, :foo], [:name, :bar])
  #   # SELECT id, foo, name, bar FROM table
  #   # => {[1, 3]=>['a', 'c'], [2, 4]=>['b', 'd'], ...}
  #
  # When using this method, you must be sure that each expression has an alias
  # that Sequel can determine.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#692
  def select_hash(key_column, value_column, opts = T.unsafe(nil)); end

  # Returns a hash with key_column values as keys and an array of value_column values.
  # Similar to to_hash_groups, but only selects the columns given.  Like to_hash_groups,
  # it accepts an optional :hash parameter, into which entries will be merged.
  #
  #   DB[:table].select_hash_groups(:name, :id)
  #   # SELECT id, name FROM table
  #   # => {'a'=>[1, 4, ...], 'b'=>[2, ...], ...}
  #
  # You can also provide an array of column names for either the key_column,
  # the value column, or both:
  #
  #   DB[:table].select_hash_groups([:first, :middle], [:last, :id])
  #   # SELECT first, middle, last, id FROM table
  #   # => {['a', 'b']=>[['c', 1], ['d', 2], ...], ...}
  #
  # When using this method, you must be sure that each expression has an alias
  # that Sequel can determine.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#713
  def select_hash_groups(key_column, value_column, opts = T.unsafe(nil)); end

  # Selects the column given (either as an argument or as a block), and
  # returns an array of all values of that column in the dataset.  If you
  # give a block argument that returns an array with multiple entries,
  # the contents of the resulting array are undefined.  Raises an Error
  # if called with both an argument and a block.
  #
  #   DB[:table].select_map(:id) # SELECT id FROM table
  #   # => [3, 5, 8, 1, ...]
  #
  #   DB[:table].select_map{id * 2} # SELECT (id * 2) FROM table
  #   # => [6, 10, 16, 2, ...]
  #
  # You can also provide an array of column names:
  #
  #   DB[:table].select_map([:id, :name]) # SELECT id, name FROM table
  #   # => [[1, 'A'], [2, 'B'], [3, 'C'], ...]
  #
  # If you provide an array of expressions, you must be sure that each entry
  # in the array has an alias that Sequel can determine.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#736
  def select_map(column = T.unsafe(nil), &block); end

  # Alias for select_append.
  #
  # source://sequel//lib/sequel/dataset/query.rb#972
  def select_more(*columns, &block); end

  # The same as select_map, but in addition orders the array by the column.
  #
  #   DB[:table].select_order_map(:id) # SELECT id FROM table ORDER BY id
  #   # => [1, 2, 3, 4, ...]
  #
  #   DB[:table].select_order_map{id * 2} # SELECT (id * 2) FROM table ORDER BY (id * 2)
  #   # => [2, 4, 6, 8, ...]
  #
  # You can also provide an array of column names:
  #
  #   DB[:table].select_order_map([:id, :name]) # SELECT id, name FROM table ORDER BY id, name
  #   # => [[1, 'A'], [2, 'B'], [3, 'C'], ...]
  #
  # If you provide an array of expressions, you must be sure that each entry
  # in the array has an alias that Sequel can determine.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#755
  def select_order_map(column = T.unsafe(nil), &block); end

  # source://sequel//lib/sequel/dataset/sql.rb#238
  def select_sql; end

  # Set the server for this dataset to use.  Used to pick a specific database
  # shard to run a query against, or to override the default (where SELECT uses
  # :read_only database and all other queries use the :default database).  This
  # method is always available but is only useful when database sharding is being
  # used.
  #
  #   DB[:items].all # Uses the :read_only or :default server
  #   DB[:items].delete # Uses the :default server
  #   DB[:items].server(:blah).delete # Uses the :blah server
  #
  # source://sequel//lib/sequel/dataset/query.rb#985
  def server(servr); end

  # If the database uses sharding and the current dataset has not had a
  # server set, return a cloned dataset that uses the given server.
  # Otherwise, return the receiver directly instead of returning a clone.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/query.rb#992
  def server?(server); end

  # This allows you to manually specify the graph aliases to use
  # when using graph.  You can use it to only select certain
  # columns, and have those columns mapped to specific aliases
  # in the result set.  This is the equivalent of +select+ for a
  # graphed dataset, and must be used instead of +select+ whenever
  # graphing is used.
  #
  # graph_aliases should be a hash with keys being symbols of
  # column aliases, and values being either symbols or arrays with one to three elements.
  # If the value is a symbol, it is assumed to be the same as a one element
  # array containing that symbol.
  # The first element of the array should be the table alias symbol.
  # The second should be the actual column name symbol.  If the array only
  # has a single element the column name symbol will be assumed to be the
  # same as the corresponding hash key. If the array
  # has a third element, it is used as the value returned, instead of
  # table_alias.column_name.
  #
  #   DB[:artists].graph(:albums, :artist_id: :id).
  #     set_graph_aliases(name: :artists,
  #                       album_name: [:albums, :name],
  #                       forty_two: [:albums, :fourtwo, 42]).first
  #   # SELECT artists.name, albums.name AS album_name, 42 AS forty_two ...
  #
  # source://sequel//lib/sequel/dataset/graph.rb#244
  def set_graph_aliases(graph_aliases); end

  # Limits the dataset to one record, and returns the first record in the dataset,
  # or nil if the dataset has no records. Users should probably use +first+ instead of
  # this method. Example:
  #
  #   DB[:test].single_record # SELECT * FROM test LIMIT 1
  #   # => {:column_name=>'value'}
  #
  # source://sequel//lib/sequel/dataset/actions.rb#765
  def single_record; end

  # Returns the first record in dataset, without limiting the dataset. Returns nil if
  # the dataset has no records. Users should probably use +first+ instead of this method.
  # This should only be used if you know the dataset is already limited to a single record.
  # This method may be desirable to use for performance reasons, as it does not clone the
  # receiver. Example:
  #
  #   DB[:test].single_record! # SELECT * FROM test
  #   # => {:column_name=>'value'}
  #
  # source://sequel//lib/sequel/dataset/actions.rb#777
  def single_record!; end

  # Returns the first value of the first record in the dataset.
  # Returns nil if dataset is empty.  Users should generally use
  # +get+ instead of this method. Example:
  #
  #   DB[:test].single_value # SELECT * FROM test LIMIT 1
  #   # => 'value'
  #
  # source://sequel//lib/sequel/dataset/actions.rb#787
  def single_value; end

  # Returns the first value of the first record in the dataset, without limiting the dataset.
  # Returns nil if the dataset is empty. Users should generally use +get+ instead of this
  # method.  Should not be used on graphed datasets or datasets that have row_procs that
  # don't return hashes.  This method may be desirable to use for performance reasons, as
  # it does not clone the receiver.
  #
  #   DB[:test].single_value! # SELECT * FROM test
  #   # => 'value'
  #
  # source://sequel//lib/sequel/dataset/actions.rb#802
  def single_value!; end

  # Specify that the check for limits/offsets when updating/deleting be skipped for the dataset.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1001
  def skip_limit_check; end

  # Skip locked rows when returning results from this dataset.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1008
  def skip_locked; end

  # Splits a possible implicit alias in +c+, handling both SQL::AliasedExpressions
  # and Symbols.  Returns an array of two elements, with the first being the
  # main expression, and the second being the alias.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#186
  def split_alias(c); end

  # Splits table_name into an array of strings.
  #
  #   ds.split_qualifiers(:s) # ['s']
  #   ds.split_qualifiers(Sequel[:t][:s]) # ['t', 's']
  #   ds.split_qualifiers(Sequel[:d][:t][:s]) # ['d', 't', 's']
  #   ds.split_qualifiers(Sequel.qualify(Sequel[:h][:d], Sequel[:t][:s])) # ['h', 'd', 't', 's']
  #
  # source://sequel//lib/sequel/dataset/sql.rb#722
  def split_qualifiers(table_name, *args); end

  # Same as +select_sql+, not aliased directly to make subclassing simpler.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#149
  def sql; end

  # Append literalization of subscripts (SQL array accesses) to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#733
  def subscript_sql_append(sql, s); end

  # Returns the sum for the given column/expression.
  # Uses a virtual row block if no column is given.
  #
  #   DB[:table].sum(:id) # SELECT sum(id) FROM table LIMIT 1
  #   # => 55
  #   DB[:table].sum{function(column)} # SELECT sum(function(column)) FROM table LIMIT 1
  #   # => 10
  #
  # source://sequel//lib/sequel/dataset/actions.rb#813
  def sum(arg = T.unsafe(nil), &block); end

  # Whether the dataset supports common table expressions, false by default.
  # If given, +type+ can be :select, :insert, :update, or :delete, in which case it
  # determines whether WITH is supported for the respective statement type.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#43
  def supports_cte?(type = T.unsafe(nil)); end

  # Whether the dataset supports common table expressions in subqueries, false by default.
  # If false, applies the WITH clause to the main query, which can cause issues
  # if multiple WITH clauses use the same name.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#50
  def supports_cte_in_subqueries?; end

  # Whether deleting from joined datasets is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#55
  def supports_deleting_joins?; end

  # Whether the database supports derived column lists (e.g.
  # "table_expr AS table_alias(column_alias1, column_alias2, ...)"), true by
  # default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#62
  def supports_derived_column_lists?; end

  # Whether the dataset supports or can emulate the DISTINCT ON clause, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#67
  def supports_distinct_on?; end

  # Whether the dataset supports CUBE with GROUP BY, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#72
  def supports_group_cube?; end

  # Whether the dataset supports ROLLUP with GROUP BY, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#77
  def supports_group_rollup?; end

  # Whether the dataset supports GROUPING SETS with GROUP BY, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#82
  def supports_grouping_sets?; end

  # Whether this dataset supports the +insert_select+ method for returning all columns values
  # directly from an insert query, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#88
  def supports_insert_select?; end

  # Whether the dataset supports the INTERSECT and EXCEPT compound operations, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#93
  def supports_intersect_except?; end

  # Whether the dataset supports the INTERSECT ALL and EXCEPT ALL compound operations, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#98
  def supports_intersect_except_all?; end

  # Whether the dataset supports the IS TRUE syntax, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#103
  def supports_is_true?; end

  # Whether the dataset supports the JOIN table USING (column1, ...) syntax, true by default.
  # If false, support is emulated using JOIN table ON (table.column1 = other_table.column1).
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#109
  def supports_join_using?; end

  # Whether the dataset supports LATERAL for subqueries in the FROM or JOIN clauses, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#114
  def supports_lateral_subqueries?; end

  # Whether limits are supported in correlated subqueries, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#119
  def supports_limits_in_correlated_subqueries?; end

  # Whether the MERGE statement is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#129
  def supports_merge?; end

  # Whether modifying joined datasets is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#134
  def supports_modifying_joins?; end

  # Whether the IN/NOT IN operators support multiple columns when an
  # array of values is given, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#140
  def supports_multiple_column_in?; end

  # Whether the dataset supports skipping raising an error instead of waiting for locked rows when returning data, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#124
  def supports_nowait?; end

  # Whether offsets are supported in correlated subqueries, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#145
  def supports_offsets_in_correlated_subqueries?; end

  # Whether the dataset supports or can fully emulate the DISTINCT ON clause,
  # including respecting the ORDER BY clause, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#151
  def supports_ordered_distinct_on?; end

  # Whether placeholder literalizers are supported, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#156
  def supports_placeholder_literalizer?; end

  # Whether the dataset supports pattern matching by regular expressions, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#161
  def supports_regexp?; end

  # Whether the dataset supports REPLACE syntax, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#166
  def supports_replace?; end

  # Whether the RETURNING clause is supported for the given type of query, false by default.
  # +type+ can be :insert, :update, or :delete.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#172
  def supports_returning?(type); end

  # Whether the database supports <tt>SELECT *, column FROM table</tt>, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#182
  def supports_select_all_and_column?; end

  # Whether the dataset supports skipping locked rows when returning data, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#177
  def supports_skip_locked?; end

  # Whether the dataset supports timezones in literal timestamps, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#187
  def supports_timestamp_timezones?; end

  # Whether the dataset supports fractional seconds in literal timestamps, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#192
  def supports_timestamp_usecs?; end

  # Whether updating joined datasets is supported, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#197
  def supports_updating_joins?; end

  # Whether the dataset supports WHERE TRUE (or WHERE 1 for databases that
  # that use 1 for true), true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#226
  def supports_where_true?; end

  # Whether the dataset supports the WINDOW clause to define windows used by multiple
  # window functions, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#203
  def supports_window_clause?; end

  # Whether the dataset supports the given window function option.  True by default.
  # This should only be called if supports_window_functions? is true. Possible options
  # are :rows, :range, :groups, :offset, :exclude.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#215
  def supports_window_function_frame_option?(option); end

  # Whether the dataset supports window functions, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#208
  def supports_window_functions?; end

  # Alias of as_hash for backwards compatibility.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#870
  def to_hash(*a); end

  # Returns a hash with one column used as key and the values being an
  # array of column values. If the value_column is not given or nil, uses
  # the entire hash as the value.
  #
  #   DB[:table].to_hash_groups(:name, :id) # SELECT * FROM table
  #   # {'Jim'=>[1, 4, 16, ...], 'Bob'=>[2], ...}
  #
  #   DB[:table].to_hash_groups(:name) # SELECT * FROM table
  #   # {'Jim'=>[{:id=>1, :name=>'Jim'}, {:id=>4, :name=>'Jim'}, ...], 'Bob'=>[{:id=>2, :name=>'Bob'}], ...}
  #
  # You can also provide an array of column names for either the key_column,
  # the value column, or both:
  #
  #   DB[:table].to_hash_groups([:first, :middle], [:last, :id]) # SELECT * FROM table
  #   # {['Jim', 'Bob']=>[['Smith', 1], ['Jackson', 4], ...], ...}
  #
  #   DB[:table].to_hash_groups([:first, :middle]) # SELECT * FROM table
  #   # {['Jim', 'Bob']=>[{:id=>1, :first=>'Jim', :middle=>'Bob', :last=>'Smith'}, ...], ...}
  #
  # Options:
  # :all :: Use all instead of each to retrieve the objects
  # :hash :: The object into which the values will be placed.  If this is not
  #          given, an empty hash is used.  This can be used to use a hash with
  #          a default value or default proc.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#898
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Truncates the dataset.  Returns nil.
  #
  #   DB[:table].truncate # TRUNCATE table
  #   # => nil
  #
  # source://sequel//lib/sequel/dataset/actions.rb#928
  def truncate; end

  # Returns a TRUNCATE SQL query string.  See +truncate+
  #
  #   DB[:items].truncate_sql # => 'TRUNCATE items'
  #
  # source://sequel//lib/sequel/dataset/sql.rb#156
  def truncate_sql; end

  # Returns a copy of the dataset with no filters (HAVING or WHERE clause) applied.
  #
  #   DB[:items].group(:a).having(a: 1).where(:b).unfiltered
  #   # SELECT * FROM items GROUP BY a
  #
  # source://sequel//lib/sequel/dataset/query.rb#1019
  def unfiltered; end

  # Remove the splitting of results into subhashes, and all metadata
  # related to the current graph (if any).
  #
  # source://sequel//lib/sequel/dataset/graph.rb#255
  def ungraphed; end

  # Returns a copy of the dataset with no grouping (GROUP or HAVING clause) applied.
  #
  #   DB[:items].group(:a).having(a: 1).where(:b).ungrouped
  #   # SELECT * FROM items WHERE b
  #
  # source://sequel//lib/sequel/dataset/query.rb#1027
  def ungrouped; end

  # Adds a UNION clause using a second dataset object.
  # A UNION compound dataset returns all rows in either the current dataset
  # or the given dataset.
  # Options:
  # :alias :: Use the given value as the from_self alias
  # :all :: Set to true to use UNION ALL instead of UNION, so duplicate rows can occur
  # :from_self :: Set to false to not wrap the returned dataset in a from_self, use with care.
  #
  #   DB[:items].union(DB[:other_items])
  #   # SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS t1
  #
  #   DB[:items].union(DB[:other_items], all: true, from_self: false)
  #   # SELECT * FROM items UNION ALL SELECT * FROM other_items
  #
  #   DB[:items].union(DB[:other_items], alias: :i)
  #   # SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS i
  #
  # source://sequel//lib/sequel/dataset/query.rb#1047
  def union(dataset, opts = T.unsafe(nil)); end

  # Returns a copy of the dataset with no limit or offset.
  #
  #   DB[:items].limit(10, 20).unlimited # SELECT * FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#1054
  def unlimited; end

  # Returns a copy of the dataset with no order.
  #
  #   DB[:items].order(:a).unordered # SELECT * FROM items
  #
  # source://sequel//lib/sequel/dataset/query.rb#1061
  def unordered; end

  # This returns an SQL::Identifier or SQL::AliasedExpression containing an
  # SQL identifier that represents the unqualified column for the given value.
  # The given value should be a Symbol, SQL::Identifier, SQL::QualifiedIdentifier,
  # or SQL::AliasedExpression containing one of those.  In other cases, this
  # returns nil.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#205
  def unqualified_column_for(v); end

  # Creates a unique table alias that hasn't already been used in the dataset.
  # table_alias can be any type of object accepted by alias_symbol.
  # The symbol returned will be the implicit alias in the argument,
  # possibly appended with "_N" if the implicit alias has already been
  # used, where N is an integer starting at 0 and increasing until an
  # unused one is found.
  #
  # You can provide a second addition array argument containing symbols
  # that should not be considered valid table aliases.  The current aliases
  # for the FROM and JOIN tables are automatically included in this array.
  #
  #   DB[:table].unused_table_alias(:t)
  #   # => :t
  #
  #   DB[:table].unused_table_alias(:table)
  #   # => :table_0
  #
  #   DB[:table, :table_0].unused_table_alias(:table)
  #   # => :table_1
  #
  #   DB[:table, :table_0].unused_table_alias(:table, [:table_1, :table_2])
  #   # => :table_3
  #
  # source://sequel//lib/sequel/dataset/misc.rb#233
  def unused_table_alias(table_alias, used_aliases = T.unsafe(nil)); end

  # Updates values for the dataset.  The returned value is the number of rows updated.
  # +values+ should be a hash where the keys are columns to set and values are the values to
  # which to set the columns.
  #
  #   DB[:table].update(x: nil) # UPDATE table SET x = NULL
  #   # => 10
  #
  #   DB[:table].update(x: Sequel[:x]+1, y: 0) # UPDATE table SET x = (x + 1), y = 0
  #   # => 10
  #
  # Some databases support using multiple tables in an UPDATE query. This requires
  # multiple FROM tables (JOINs can also be used). As multiple FROM tables use
  # an implicit CROSS JOIN, you should make sure your WHERE condition uses the
  # appropriate filters for the FROM tables:
  #
  #  DB.from(:a, :b).join(:c, :d=>Sequel[:b][:e]).where{{a[:f]=>b[:g], a[:id]=>10}}.
  #    update(:f=>Sequel[:c][:h])
  #  # UPDATE a
  #  # SET f = c.h
  #  # FROM b
  #  # INNER JOIN c ON (c.d = b.e)
  #  # WHERE ((a.f = b.g) AND (a.id = 10))
  #
  # source://sequel//lib/sequel/dataset/actions.rb#954
  def update(values = T.unsafe(nil), &block); end

  # Formats an UPDATE statement using the given values.  See +update+.
  #
  #   DB[:items].update_sql(price: 100, category: 'software')
  #   # => "UPDATE items SET price = 100, category = 'software'
  #
  # Raises an +Error+ if the dataset is grouped or includes more
  # than one table.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#176
  def update_sql(values = T.unsafe(nil)); end

  # Returns a copy of the dataset with the given WHERE conditions imposed upon it.
  #
  # Accepts the following argument types:
  #
  # Hash, Array of pairs :: list of equality/inclusion expressions
  # Symbol :: taken as a boolean column argument (e.g. WHERE active)
  # Sequel::SQL::BooleanExpression, Sequel::LiteralString :: an existing condition expression, probably created
  #                                                          using the Sequel expression filter DSL.
  #
  # where also accepts a block, which should return one of the above argument
  # types, and is treated the same way.  This block yields a virtual row object,
  # which is easy to use to create identifiers and functions.  For more details
  # on the virtual row support, see the {"Virtual Rows" guide}[rdoc-ref:doc/virtual_rows.rdoc]
  #
  # If both a block and regular argument are provided, they get ANDed together.
  #
  # Examples:
  #
  #   DB[:items].where(id: 3)
  #   # SELECT * FROM items WHERE (id = 3)
  #
  #   DB[:items].where(Sequel.lit('price < ?', 100))
  #   # SELECT * FROM items WHERE price < 100
  #
  #   DB[:items].where([[:id, [1,2,3]], [:id, 0..10]])
  #   # SELECT * FROM items WHERE ((id IN (1, 2, 3)) AND ((id >= 0) AND (id <= 10)))
  #
  #   DB[:items].where(Sequel.lit('price < 100'))
  #   # SELECT * FROM items WHERE price < 100
  #
  #   DB[:items].where(:active)
  #   # SELECT * FROM items WHERE :active
  #
  #   DB[:items].where{price < 100}
  #   # SELECT * FROM items WHERE (price < 100)
  #
  # Multiple where calls can be chained for scoping:
  #
  #   software = dataset.where(category: 'software').where{price < 100}
  #   # SELECT * FROM items WHERE ((category = 'software') AND (price < 100))
  #
  # See the {"Dataset Filtering" guide}[rdoc-ref:doc/dataset_filtering.rdoc] for more examples and details.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1107
  def where(*cond, &block); end

  # Return an array of all rows matching the given filter condition, also
  # yielding each row to the given block.  Basically the same as where(cond).all(&block),
  # except it can be optimized to not create an intermediate dataset.
  #
  #   DB[:table].where_all(id: [1,2,3])
  #   # SELECT * FROM table WHERE (id IN (1, 2, 3))
  #
  # source://sequel//lib/sequel/dataset/actions.rb#969
  def where_all(cond, &block); end

  # Iterate over all rows matching the given filter condition,
  # yielding each row to the given block.  Basically the same as where(cond).each(&block),
  # except it can be optimized to not create an intermediate dataset.
  #
  #   DB[:table].where_each(id: [1,2,3]){|row| p row}
  #   # SELECT * FROM table WHERE (id IN (1, 2, 3))
  #
  # source://sequel//lib/sequel/dataset/actions.rb#983
  def where_each(cond, &block); end

  # Filter the datasets using the given filter condition, then return a single value.
  # This assumes that the dataset has already been setup to limit the selection to
  # a single column.  Basically the same as where(cond).single_value,
  # except it can be optimized to not create an intermediate dataset.
  #
  #   DB[:table].select(:name).where_single_value(id: 1)
  #   # SELECT name FROM table WHERE (id = 1) LIMIT 1
  #
  # source://sequel//lib/sequel/dataset/actions.rb#998
  def where_single_value(cond); end

  # Return a clone of the dataset with an addition named window that can be
  # referenced in window functions. See Sequel::SQL::Window for a list of
  # options that can be passed in. Example:
  #
  #   DB[:items].window(:w, partition: :c1, order: :c2)
  #   # SELECT * FROM items WINDOW w AS (PARTITION BY c1 ORDER BY c2)
  #
  # source://sequel//lib/sequel/dataset/query.rb#1117
  def window(name, opts); end

  # Append literalization of windows (for window functions) to SQL string.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#761
  def window_sql_append(sql, opts); end

  # Add a common table expression (CTE) with the given name and a dataset that defines the CTE.
  # A common table expression acts as an inline view for the query.
  #
  # Options:
  # :args :: Specify the arguments/columns for the CTE, should be an array of symbols.
  # :recursive :: Specify that this is a recursive CTE
  # :materialized :: Set to false to force inlining of the CTE, or true to force not inlining
  #                  the CTE (PostgreSQL 12+/SQLite 3.35+).
  #
  #   DB[:items].with(:items, DB[:syx].where(Sequel[:name].like('A%')))
  #   # WITH items AS (SELECT * FROM syx WHERE (name LIKE 'A%' ESCAPE '\')) SELECT * FROM items
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1132
  def with(name, dataset, opts = T.unsafe(nil)); end

  # :nocov:
  #
  # source://sequel//lib/sequel/dataset/query.rb#1221
  def with_extend(*mods, &block); end

  # Return a modified dataset with quote_identifiers set.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#250
  def with_quote_identifiers(v); end

  # Add a recursive common table expression (CTE) with the given name, a dataset that
  # defines the nonrecursive part of the CTE, and a dataset that defines the recursive part
  # of the CTE.
  #
  # Options:
  # :args :: Specify the arguments/columns for the CTE, should be an array of symbols.
  # :union_all :: Set to false to use UNION instead of UNION ALL combining the nonrecursive and recursive parts.
  #
  # PostgreSQL 14+ Options:
  # :cycle :: Stop recursive searching when a cycle is detected. Includes two columns in the
  #           result of the CTE, a cycle column indicating whether a cycle was detected for
  #           the current row, and a path column for the path traversed to get to the current
  #           row.  If given, must be a hash with the following keys:
  #           :columns :: (required) The column or array of columns to use to detect a cycle.
  #                       If the value of these columns match columns already traversed, then
  #                       a cycle is detected, and recursive searching will not traverse beyond
  #                       the cycle (the CTE will include the row where the cycle was detected).
  #           :cycle_column :: The name of the cycle column in the output, defaults to :is_cycle.
  #           :cycle_value :: The value of the cycle column in the output if the current row was
  #                           detected as a cycle, defaults to true.
  #           :noncycle_value :: The value of the cycle column in the output if the current row
  #                              was not detected as a cycle, defaults to false. Only respected
  #                              if :cycle_value is given.
  #           :path_column :: The name of the path column in the output, defaults to :path.
  # :search :: Include an order column in the result of the CTE that allows for breadth or
  #            depth first searching. If given, must be a hash with the following keys:
  #            :by :: (required) The column or array of columns to search by.
  #            :order_column :: The name of the order column in the output, defaults to :ordercol.
  #            :type :: Set to :breadth to use breadth-first searching (depth-first searching
  #                     is the default).
  #
  #   DB[:t].with_recursive(:t,
  #     DB[:i1].select(:id, :parent_id).where(parent_id: nil),
  #     DB[:i1].join(:t, id: :parent_id).select(Sequel[:i1][:id], Sequel[:i1][:parent_id]),
  #     args: [:id, :parent_id])
  #
  #   # WITH RECURSIVE t(id, parent_id) AS (
  #   #   SELECT id, parent_id FROM i1 WHERE (parent_id IS NULL)
  #   #   UNION ALL
  #   #   SELECT i1.id, i1.parent_id FROM i1 INNER JOIN t ON (t.id = i1.parent_id)
  #   # ) SELECT * FROM t
  #
  #   DB[:t].with_recursive(:t,
  #     DB[:i1].where(parent_id: nil),
  #     DB[:i1].join(:t, id: :parent_id).select_all(:i1),
  #     search: {by: :id, type: :breadth},
  #     cycle: {columns: :id, cycle_value: 1, noncycle_value: 2})
  #
  #   # WITH RECURSIVE t AS (
  #   #     SELECT * FROM i1 WHERE (parent_id IS NULL)
  #   #     UNION ALL
  #   #     (SELECT i1.* FROM i1 INNER JOIN t ON (t.id = i1.parent_id))
  #   #   )
  #   #   SEARCH BREADTH FIRST BY id SET ordercol
  #   #   CYCLE id SET is_cycle TO 1 DEFAULT 2 USING path
  #   # SELECT * FROM t
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1198
  def with_recursive(name, nonrecursive, recursive, opts = T.unsafe(nil)); end

  # Returns a cloned dataset with the given row_proc.
  #
  #   ds = DB[:items]
  #   ds.all # => [{:id=>2}]
  #   ds.with_row_proc(:invert.to_proc).all # => [{2=>:id}]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1250
  def with_row_proc(callable); end

  # Returns a copy of the dataset with the static SQL used.  This is useful if you want
  # to keep the same row_proc/graph, but change the SQL used to custom SQL.
  #
  #   DB[:items].with_sql('SELECT * FROM foo') # SELECT * FROM foo
  #
  # You can use placeholders in your SQL and provide arguments for those placeholders:
  #
  #   DB[:items].with_sql('SELECT ? FROM foo', 1) # SELECT 1 FROM foo
  #
  # You can also provide a method name and arguments to call to get the SQL:
  #
  #   DB[:items].with_sql(:insert_sql, b: 1) # INSERT INTO items (b) VALUES (1)
  #
  # Note that datasets that specify custom SQL using this method will generally
  # ignore future dataset methods that modify the SQL used, as specifying custom SQL
  # overrides Sequel's SQL generator.  You should probably limit yourself to the following
  # dataset methods when using this method, or use the implicit_subquery extension:
  #
  # * each
  # * all
  # * single_record (if only one record could be returned)
  # * single_value (if only one record could be returned, and a single column is selected)
  # * map
  # * as_hash
  # * to_hash
  # * to_hash_groups
  # * delete (if a DELETE statement)
  # * update (if an UPDATE statement, with no arguments)
  # * insert (if an INSERT statement, with no arguments)
  # * truncate (if a TRUNCATE statement, with no arguments)
  #
  # source://sequel//lib/sequel/dataset/query.rb#1284
  def with_sql(sql, *args); end

  # Run the given SQL and return an array of all rows.  If a block is given,
  # each row is yielded to the block after all rows are loaded. See with_sql_each.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1011
  def with_sql_all(sql, &block); end

  # Execute the given SQL and return the number of rows deleted.  This exists
  # solely as an optimization, replacing with_sql(sql).delete.  It's significantly
  # faster as it does not require cloning the current dataset.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1018
  def with_sql_delete(sql); end

  # Run the given SQL and yield each returned row to the block.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1024
  def with_sql_each(sql); end

  # Run the given SQL and return the first row, or nil if no rows were returned.
  # See with_sql_each.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1035
  def with_sql_first(sql); end

  # Execute the given SQL and (on most databases) return the primary key of the
  # inserted row.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1051
  def with_sql_insert(sql); end

  # Run the given SQL and return the first value in the first row, or nil if no
  # rows were returned.  For this to make sense, the SQL given should select
  # only a single value.  See with_sql_each.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1043
  def with_sql_single_value(sql); end

  # Execute the given SQL and return the number of rows deleted.  This exists
  # solely as an optimization, replacing with_sql(sql).delete.  It's significantly
  # faster as it does not require cloning the current dataset.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1018
  def with_sql_update(sql); end

  protected

  # The cached columns for the current dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#281
  def _columns; end

  # Internals of #import.  If primary key values are requested, use
  # separate insert commands for each row.  Otherwise, call #multi_insert_sql
  # and execute each statement it gives separately. A transaction is only used
  # if there are multiple statements to execute.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1061
  def _import(columns, values, opts); end

  # Return an array of arrays of values given by the symbols in ret_cols.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1073
  def _select_map_multiple(ret_cols); end

  # Returns an array of the first value in each row.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1078
  def _select_map_single; end

  # Access the cache for the current dataset.  Should be used with caution,
  # as access to the cache is not thread safe without a mutex if other
  # threads can reference the dataset.  Symbol keys prefixed with an
  # underscore are reserved for internal use.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#260
  def cache; end

  # Retreive a value from the dataset's cache in a thread safe manner.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#263
  def cache_get(k); end

  # Set a value in the dataset's cache in a thread safe manner.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#268
  def cache_set(k, v); end

  # Clear the columns hash for the current dataset.  This is not a
  # thread safe operation, so it should only be used if the dataset
  # could not be used by another thread (such as one that was just
  # created via clone).
  #
  # source://sequel//lib/sequel/dataset/misc.rb#276
  def clear_columns_cache; end

  # Add the dataset to the list of compounds
  #
  # source://sequel//lib/sequel/dataset/query.rb#1296
  def compound_clone(type, dataset, opts); end

  # Return a from_self dataset if an order or limit is specified, so it works as expected
  # with UNION, EXCEPT, and INTERSECT clauses.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#850
  def compound_from_self; end

  # Return true if the dataset has a non-nil value for any key in opts.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1306
  def options_overlap(opts); end

  # Whether this dataset is a simple select from an underlying table, such as:
  #
  #   SELECT * FROM table
  #   SELECT table.* FROM table
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1317
  def simple_select_all?; end

  # A dataset for returning single values from the current dataset.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1084
  def single_value_ds; end

  # Return a cloned copy of the current dataset extended with
  # PreparedStatementMethods, setting the type and modify values.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#393
  def to_prepared_statement(type, values = T.unsafe(nil), opts = T.unsafe(nil)); end

  private

  # Cached placeholder literalizer for methods that return values using aggregate functions.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1100
  def _aggregate(function, arg); end

  # Internals of all and with_sql_all
  #
  # @yield [a]
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1091
  def _all(block); end

  # Internals of the check_*_allowed! methods
  #
  # @raise [InvalidOperation]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1031
  def _check_modification_allowed!(modifying_joins_supported); end

  # Save original clone implementation, as some other methods need
  # to call it internally.
  def _clone(freeze: T.unsafe(nil)); end

  # Return a plain symbol given a potentially qualified or aliased symbol,
  # specifying the symbol that is likely to be used as the hash key
  # for the column when records are returned.  Return nil if no hash key
  # can be determined
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1210
  def _hash_key_symbol(s, recursing = T.unsafe(nil)); end

  # Use a transaction when yielding to the block if multiple values/statements
  # are provided. When only a single value or statement is provided, then yield
  # without using a transaction.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1113
  def _import_transaction(values, trans_opts, &block); end

  # source://sequel//lib/sequel/dataset/sql.rb#1256
  def _insert_columns_sql(sql, columns); end

  # source://sequel//lib/sequel/dataset/sql.rb#239
  def _insert_sql; end

  # source://sequel//lib/sequel/dataset/sql.rb#1278
  def _insert_values_sql(sql, values); end

  # If invert is true, invert the condition.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1357
  def _invert_filter(cond, invert); end

  # source://sequel//lib/sequel/dataset/sql.rb#869
  def _merge_delete_sql(sql, data); end

  # Append the INSERT sql used in a MERGE
  #
  # source://sequel//lib/sequel/dataset/sql.rb#857
  def _merge_insert_sql(sql, data); end

  # source://sequel//lib/sequel/dataset/sql.rb#864
  def _merge_update_sql(sql, data); end

  # Append to the current MERGE WHEN clauses.
  # Mutates the hash to add the conditions, if a virtual row block is passed.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1367
  def _merge_when(hash, &block); end

  # Append MERGE WHEN conditions, if there are conditions provided.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#895
  def _merge_when_conditions_sql(sql, data); end

  # Add the WHEN clauses to the MERGE SQL
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#884
  def _merge_when_sql(sql); end

  # Parse the values passed to insert_sql, returning columns and values
  # to use for the INSERT.  Returned columns is always an array, but can be empty
  # for an INSERT without explicit column references. Returned values can be an
  # array, dataset, or literal string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#906
  def _parse_insert_sql_args(values); end

  # Internals of +select_hash+ and +select_hash_groups+
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1122
  def _select_hash(meth, key_column, value_column, opts = T.unsafe(nil)); end

  # Internals of +select_map+ and +select_order_map+
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1128
  def _select_map(column, order, &block); end

  # A cached dataset for a single record for this dataset.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1142
  def _single_record_ds; end

  # Formats the truncate statement.  Assumes the table given has already been
  # literalized.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#935
  def _truncate_sql(table); end

  # Internal recursive version of unqualified_column_for, handling Strings inside
  # of other objects.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#355
  def _unqualified_column_for(v); end

  # source://sequel//lib/sequel/dataset/sql.rb#239
  def _update_sql; end

  # Loader used for where_all and where_each.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1147
  def _where_loader(where_args, where_block); end

  # Cached dataset to use for with_sql_#{all,each,first,single_value}.
  # This is used so that the columns returned by the given SQL do not
  # affect the receiver of the with_sql_* method.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1328
  def _with_sql_dataset; end

  # Add the given filter condition. Arguments:
  # clause :: Symbol or which SQL clause to effect, should be :where or :having
  # cond :: The filter condition to add
  # invert :: Whether the condition should be inverted (true or false)
  # combine :: How to combine the condition with an existing condition, should be :AND or :OR
  #
  # source://sequel//lib/sequel/dataset/query.rb#1382
  def add_filter(clause, cond, invert = T.unsafe(nil), combine = T.unsafe(nil), &block); end

  # Whether to use from_self for an aggregate dataset.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#984
  def aggreate_dataset_use_from_self?; end

  # Clone of this dataset usable in aggregate operations.  Does
  # a from_self if dataset contains any parameters that would
  # affect normal aggregation, or just removes an existing
  # order if not. Also removes the row_proc, which isn't needed
  # for aggregate calculations.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#979
  def aggregate_dataset; end

  # Returns an appropriate symbol for the alias represented by s.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#940
  def alias_alias_symbol(s); end

  # Returns an appropriate alias symbol for the given object, which can be
  # a Symbol, String, SQL::Identifier, SQL::QualifiedIdentifier, or
  # SQL::AliasedExpression.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#956
  def alias_symbol(sym); end

  # Don't allow preparing prepared statements by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#405
  def allow_preparing_prepared_statements?; end

  # Append aliasing expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#989
  def as_sql_append(sql, aliaz, column_aliases = T.unsafe(nil)); end

  # Automatically alias the given expression if it does not have an identifiable alias.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1154
  def auto_alias_expression(v); end

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#409
  def bound_variable_modules; end

  # Don't allow caching SQL if specifically marked not to.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1001
  def cache_sql?; end

  # Check the cache for the given key, returning the value.
  # Otherwise, yield to get the dataset and cache the dataset under the given key.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#289
  def cached_dataset(key); end

  # Return a cached placeholder literalizer for the given key if there
  # is one for this dataset.  If there isn't one, increment the counter
  # for the number of calls for the key, and if the counter is at least
  # three, then create a placeholder literalizer by yielding to the block,
  # and cache it.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#303
  def cached_placeholder_literalizer(key); end

  # Return a cached placeholder literalizer for the key, unless where_block is
  # nil and where_args is an empty array or hash.  This is designed to guard
  # against placeholder literalizer use when passing arguments to where
  # in the uncached case and filter_expr if a cached placeholder literalizer
  # is used.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#327
  def cached_where_placeholder_literalizer(where_args, where_block, key, &block); end

  # Check whether it is allowed to delete from this dataset.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1021
  def check_delete_allowed!; end

  # Check whether it is allowed to insert into this dataset.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1015
  def check_insert_allowed!; end

  # Raise an InvalidOperation exception if modification is not allowed for this dataset.
  # Check whether it is allowed to insert into this dataset.
  # Only for backwards compatibility with older external adapters.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1008
  def check_modification_allowed!; end

  # Raise error if the dataset uses limits or offsets.
  #
  # @raise [InvalidOperation]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1037
  def check_not_limited!(type); end

  # Check whether it is allowed to insert into this dataset.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1015
  def check_truncation_allowed!; end

  # Check whether it is allowed to update this dataset.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1026
  def check_update_allowed!; end

  # Append column list to SQL string.
  # If the column list is empty, a wildcard (*) is appended.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1044
  def column_list_append(sql, columns); end

  # Set the columns for the current dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#337
  def columns=(v); end

  # Yield each pair of arguments to the block, which should
  # return an object representing the SQL expression for those
  # two arguments.  For more than two arguments, the first
  # argument to the block will be result of the previous block call.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1056
  def complex_expression_arg_pairs(args); end

  # Append the literalization of the args using complex_expression_arg_pairs
  # to the given SQL string, used when database operator/function is 2-ary
  # where Sequel expression is N-ary.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1070
  def complex_expression_arg_pairs_append(sql, args, &block); end

  # Append literalization of complex expression to SQL string, for
  # operators unsupported by some databases. Used by adapters for databases
  # that don't support the operators natively.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1077
  def complex_expression_emulate_append(sql, op, args); end

  # Append literalization of dataset used in UNION/INTERSECT/EXCEPT clause to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1098
  def compound_dataset_sql_append(sql, ds); end

  # The alias to use for datasets, takes a number to make sure the name is unique.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1103
  def dataset_alias(number); end

  # The default number of rows that can be inserted in a single INSERT statement via import.
  # The default is for no limit.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1165
  def default_import_slice; end

  # The default :qualify option to use for join tables if one is not specified.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1413
  def default_join_table_qualification; end

  # Return self if the dataset already has a server, or a cloned dataset with the
  # default server otherwise.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1488
  def default_server; end

  # Set the server to use to :default unless it is already set in the passed opts
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1170
  def default_server_opts(opts); end

  # The strftime format to use when literalizing the time.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1108
  def default_timestamp_format; end

  # source://sequel//lib/sequel/dataset/sql.rb#1112
  def delete_delete_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1116
  def delete_from_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1599
  def delete_order_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1297
  def delete_returning_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1612
  def delete_where_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1637
  def delete_with_sql(sql); end

  # Disable caching of SQL for the current dataset
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1124
  def disable_sql_caching!; end

  # An expression for how to handle an empty array lookup.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1168
  def empty_array_value(op, cols); end

  # An SQL FROM clause to use in SELECT statements where the dataset has
  # no from tables.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1130
  def empty_from_sql; end

  # Whether to emulate the function with the given name.  This should only be true
  # if the emulation goes beyond choosing a function with a different name.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1136
  def emulate_function?(name); end

  # Whether prepared statements should be emulated.  True by
  # default so that adapters have to opt in.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#415
  def emulate_prepared_statements?; end

  # Execute the given select SQL on the database using execute. Use the
  # :read_only server unless a specific server is set.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1180
  def execute(sql, opts = T.unsafe(nil), &block); end

  # Execute the given SQL on the database using execute_ddl.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1191
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end

  # Execute the given SQL on the database using execute_dui.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1197
  def execute_dui(sql, opts = T.unsafe(nil), &block); end

  # Execute the given SQL on the database using execute_insert.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1202
  def execute_insert(sql, opts = T.unsafe(nil), &block); end

  # Append literalization of array of expressions to SQL string, separating them
  # with commas.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1142
  def expression_list_append(sql, columns); end

  # SQL expression object based on the expr type.  See +where+.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1418
  def filter_expr(expr = T.unsafe(nil), &block); end

  # Format the timestamp based on the default_timestamp_format, with a couple
  # of modifiers.  First, allow %N to be used for fractions seconds (if the
  # database supports them), and override %z to always use a numeric offset
  # of hours and minutes.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1176
  def format_timestamp(v); end

  # Return the SQL timestamp fragment to use for the timezone offset.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1197
  def format_timestamp_offset(hour, minute); end

  # Return the SQL timestamp fragment to use for the fractional time part.
  # Should start with the decimal point.  Uses 6 decimal places by default.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1203
  def format_timestamp_usec(usec, ts = T.unsafe(nil)); end

  # Transform the hash of graph aliases and return a two element array
  # where the first element is an array of identifiers suitable to pass to
  # a select method, and the second is a new hash of preprocessed graph aliases.
  #
  # source://sequel//lib/sequel/dataset/graph.rb#283
  def graph_alias_columns(graph_aliases); end

  # Append literalization of array of grouping elements to SQL string, seperating them with commas.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1153
  def grouping_element_list_append(sql, columns); end

  # Return a plain symbol given a potentially qualified or aliased symbol,
  # specifying the symbol that is likely to be used as the hash key
  # for the column when records are returned.  Raise Error if the hash key
  # symbol cannot be returned.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1230
  def hash_key_symbol(s); end

  # If s is an array, return an array with the given hash key symbols.
  # Otherwise, return a hash key symbol for the given expression
  # If a hash key symbol cannot be determined, raise an error.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1241
  def hash_key_symbols(s); end

  # Return two datasets, the first a clone of the receiver with the WITH
  # clause from the given dataset added to it, and the second a clone of
  # the given dataset with the WITH clause removed.
  #
  # source://sequel//lib/sequel/dataset/query.rb#1460
  def hoist_cte(ds); end

  # Whether CTEs need to be hoisted from the given ds into the current ds.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1465
  def hoist_cte?(ds); end

  # Append literalization of identifier to SQL string, considering regular strings
  # as SQL identifiers instead of SQL strings.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1212
  def identifier_append(sql, v); end

  # Append literalization of array of identifiers to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1228
  def identifier_list_append(sql, args); end

  # Returns an expression that will ignore values preceding the given row, using the
  # receiver's current order. This yields the row and the array of order expressions
  # to the block, which should return an array of values to use.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1248
  def ignore_values_preceding(row); end

  # Set the db, opts, and cache for the copy of the dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#342
  def initialize_clone(c, _ = T.unsafe(nil)); end

  # Set the db, opts, and cache for the copy of the dataset.
  #
  # source://sequel//lib/sequel/dataset/misc.rb#342
  def initialize_copy(c, _ = T.unsafe(nil)); end

  # Upcase identifiers by default when inputting them into the database.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1239
  def input_identifier(v); end

  # source://sequel//lib/sequel/dataset/sql.rb#1252
  def insert_columns_sql(sql); end

  # The columns and values to use for an empty insert if the database doesn't support
  # INSERT with DEFAULT VALUES.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1266
  def insert_empty_columns_values; end

  # source://sequel//lib/sequel/dataset/sql.rb#1270
  def insert_insert_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1243
  def insert_into_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1297
  def insert_returning_sql(sql); end

  # Whether insert(nil) or insert({}) must be emulated by
  # using at least one value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#234
  def insert_supports_empty_values?; end

  # source://sequel//lib/sequel/dataset/sql.rb#1274
  def insert_values_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1637
  def insert_with_sql(sql); end

  # Inverts the given order by breaking it into a list of column references
  # and inverting them.
  #
  #   DB[:items].invert_order([Sequel.desc(:id)]]) #=> [Sequel.asc(:id)]
  #   DB[:items].invert_order([:category, Sequel.desc(:price)]) #=> [Sequel.desc(:category), Sequel.asc(:price)]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1474
  def invert_order(order); end

  # SQL fragment specifying a JOIN type, converts underscores to
  # spaces and upcases.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1308
  def join_type_sql(join_type); end

  # Append USING clause for JOIN USING
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1313
  def join_using_clause_using_sql_append(sql, using_columns); end

  # Append a literalization of the array to SQL string.
  # Treats as an expression if an array of all two pairs, or as a SQL array otherwise.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1321
  def literal_array_append(sql, v); end

  # SQL fragment for BigDecimal
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1330
  def literal_big_decimal(v); end

  # Append literalization of SQL::Blob to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1336
  def literal_blob_append(sql, v); end

  # Append literalization of dataset to SQL string.  Does a subselect inside parantheses.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1341
  def literal_dataset_append(sql, v); end

  # SQL fragment for Date, using the ISO8601 format.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1349
  def literal_date(v); end

  # SQL fragment for DateTime
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1358
  def literal_datetime(v); end

  # Append literalization of DateTime to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1363
  def literal_datetime_append(sql, v); end

  # Append literalization of SQL::Expression to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1368
  def literal_expression_append(sql, v); end

  # SQL fragment for false
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1373
  def literal_false; end

  # SQL fragment for Float
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1378
  def literal_float(v); end

  # Append literalization of Hash to SQL string, treating hash as a boolean expression.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1383
  def literal_hash_append(sql, v); end

  # SQL fragment for Integer
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1388
  def literal_integer(v); end

  # SQL fragment for nil
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1393
  def literal_nil; end

  # Append a literalization of the object to the given SQL string.
  # Calls +sql_literal_append+ if object responds to it, otherwise
  # calls +sql_literal+ if object responds to it, otherwise raises an error.
  # If a database specific type is allowed, this should be overriden in a subclass.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1401
  def literal_other_append(sql, v); end

  # SQL fragment for Sequel::SQLTime, containing just the time part
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1416
  def literal_sqltime(v); end

  # Append literalization of Sequel::SQLTime to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1421
  def literal_sqltime_append(sql, v); end

  # Append literalization of string to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1426
  def literal_string_append(sql, v); end

  # Append literalization of symbol to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1431
  def literal_symbol_append(sql, v); end

  # SQL fragment for Time
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1442
  def literal_time(v); end

  # Append literalization of Time to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1447
  def literal_time_append(sql, v); end

  # SQL fragment for true
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1452
  def literal_true; end

  # What strategy to use for import/multi_insert.  While SQL-92 defaults
  # to allowing multiple rows in a VALUES clause, there are enough databases
  # that don't allow that that it can't be the default.  Use separate queries
  # by default, which works everywhere.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1460
  def multi_insert_sql_strategy; end

  # Get the native function name given the emulated function name.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1466
  def native_function_name(emulated_function); end

  # Whether the given option key does not affect the generated SQL.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/query.rb#1493
  def non_sql_option?(key); end

  # Downcase identifiers by default when outputing them from the database.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1273
  def output_identifier(v); end

  # This is run inside .all, after all of the records have been loaded
  # via .each, but before any block passed to all is called.  It is called with
  # a single argument, an array of all returned records.  Does nothing by
  # default, added to make the model eager loading code simpler.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1282
  def post_load(all_records); end

  # The argument placeholder.  Most databases used unnumbered
  # arguments with question marks, so that is the default.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#425
  def prepared_arg_placeholder; end

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#419
  def prepared_statement_modules; end

  # Returns a qualified column name (including a table name) if the column
  # name isn't already qualified.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1472
  def qualified_column_name(column, table); end

  # Qualify the given expression to the given table.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1492
  def qualified_expression(e, table); end

  # Wrap the alias symbol in an SQL::Identifier if the identifier on which is based
  # is an SQL::Identifier.  This works around cases where symbol splitting is enabled and the alias symbol contains
  # double embedded underscores which would be considered an implicit qualified identifier
  # if not wrapped in an SQL::Identifier.
  #
  # source://sequel//lib/sequel/dataset/graph.rb#265
  def qualifier_from_alias_symbol(aliaz, identifier); end

  # Whether ORDER BY col NULLS FIRST/LAST must be emulated.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#244
  def requires_emulating_nulls_first?; end

  # Whether the dataset needs ESCAPE for LIKE for correct behavior.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#239
  def requires_like_escape?; end

  # Called by insert/update/delete when returning is used.
  # Yields each row as a plain hash to the block if one is given, or returns
  # an array of plain hashes for all rows if a block is not given
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1288
  def returning_fetch_rows(sql, &block); end

  # source://sequel//lib/sequel/dataset/sql.rb#1496
  def select_columns_sql(sql); end

  # Modify the sql to add a dataset to the via an EXCEPT, INTERSECT, or UNION clause.
  # This uses a subselect for the compound datasets used, because using parantheses doesn't
  # work on all databases.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1515
  def select_compounds_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1501
  def select_distinct_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1525
  def select_from_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1534
  def select_group_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1556
  def select_having_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1563
  def select_join_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1569
  def select_limit_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1582
  def select_lock_sql(sql); end

  # Used only if there is an offset and no limit, making it easier to override
  # in the adapter, as many databases do not support just a plain offset with
  # no limit.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1594
  def select_only_offset_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1599
  def select_order_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1608
  def select_select_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1612
  def select_where_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1621
  def select_window_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1637
  def select_with_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1655
  def select_with_sql_base; end

  # source://sequel//lib/sequel/dataset/sql.rb#1659
  def select_with_sql_cte(sql, cte); end

  # source://sequel//lib/sequel/dataset/sql.rb#1664
  def select_with_sql_prefix(sql, w); end

  # Whether the symbol cache should be skipped when literalizing the dataset
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1682
  def skip_symbol_cache?; end

  # Append literalization of array of sources/tables to SQL string, raising an Error if there
  # are no sources.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1688
  def source_list_append(sql, sources); end

  # Delegate to Sequel.split_symbol.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1694
  def split_symbol(sym); end

  # The string that is appended to to create the SQL query, the empty
  # string by default.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1700
  def sql_string_origin; end

  # The precision to use for SQLTime instances (time column values without dates).
  # Defaults to timestamp_precision.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1706
  def sqltime_precision; end

  # SQL to use if this dataset uses static SQL.  Since static SQL
  # can be a PlaceholderLiteralString in addition to a String,
  # we literalize nonstrings.  If there is an append_sql for this
  # dataset, append to that SQL instead of returning the value.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1714
  def static_sql(sql); end

  # Append literalization of the subselect to SQL string.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1731
  def subselect_sql_append(sql, ds); end

  # source://sequel//lib/sequel/dataset/sql.rb#1745
  def subselect_sql_append_sql(sql, ds); end

  # source://sequel//lib/sequel/dataset/sql.rb#1741
  def subselect_sql_dataset(sql, ds); end

  # Whether common table expressions are supported in UNION/INTERSECT/EXCEPT clauses.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#249
  def supports_cte_in_compounds?; end

  # Whether the dataset supports the FILTER clause for aggregate functions.
  # If not, support is emulated using CASE.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#255
  def supports_filtered_aggregates?; end

  # Whether the database supports quoting function names.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#260
  def supports_quoted_function_names?; end

  # The number of decimal digits of precision to use in timestamps.
  #
  # source://sequel//lib/sequel/dataset/sql.rb#1750
  def timestamp_precision; end

  # Return the unaliased part of the identifier.  Handles both
  # implicit aliases in symbols, as well as SQL::AliasedExpression
  # objects.  Other objects are returned as is.
  #
  # source://sequel//lib/sequel/dataset/actions.rb#1302
  def unaliased_identifier(c); end

  # source://sequel//lib/sequel/dataset/sql.rb#1599
  def update_order_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1297
  def update_returning_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1760
  def update_set_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1770
  def update_sql_values_hash(sql, values); end

  # source://sequel//lib/sequel/dataset/sql.rb#1754
  def update_table_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1786
  def update_update_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1612
  def update_where_sql(sql); end

  # source://sequel//lib/sequel/dataset/sql.rb#1637
  def update_with_sql(sql); end

  # Whether the RETURNING clause is used for the given dataset.
  # +type+ can be :insert, :update, or :delete.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#266
  def uses_returning?(type); end

  # Whether the dataset uses WITH ROLLUP/CUBE instead of ROLLUP()/CUBE().
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/features.rb#271
  def uses_with_rollup?; end

  # Treat the +block+ as a virtual_row block if not +nil+ and
  # add the resulting columns to the +columns+ array (modifies +columns+).
  #
  # source://sequel//lib/sequel/dataset/query.rb#1499
  def virtual_row_columns(columns, block); end

  # Return the class name for this dataset, but skip anonymous classes
  #
  # source://sequel//lib/sequel/dataset/misc.rb#375
  def visible_class_name; end

  # source://sequel//lib/sequel/dataset/sql.rb#1790
  def window_frame_boundary_sql_append(sql, boundary, direction); end

  class << self
    # Given a type (e.g. select) and an array of clauses,
    # return an array of methods to call to build the SQL string.
    #
    # source://sequel//lib/sequel/dataset/sql.rb#198
    def clause_methods(type, clauses); end

    # Define a dataset literalization method for the given type in the given module,
    # using the given clauses.
    #
    # Arguments:
    # mod :: Module in which to define method
    # type :: Type of SQL literalization method to create, either :select, :insert, :update, or :delete
    # clauses :: array of clauses that make up the SQL query for the type.  This can either be a single
    #            array of symbols/strings, or it can be an array of pairs, with the first element in
    #            each pair being an if/elsif/else code fragment, and the second element in each pair
    #            being an array of symbol/strings for the appropriate branch.
    #
    # source://sequel//lib/sequel/dataset/sql.rb#212
    def def_sql_method(mod, type, clauses); end

    # Register an extension callback for Dataset objects.  ext should be the
    # extension name symbol, and mod should be a Module that will be
    # included in the dataset's class. This also registers a Database extension that will
    # extend all of the database's datasets.
    #
    # source://sequel//lib/sequel/dataset/query.rb#55
    def register_extension(ext, mod = T.unsafe(nil), &block); end

    private

    # source://sequel//lib/sequel/dataset/prepared_statements.rb#20
    def prepared_statements_module(code, mods, meths = T.unsafe(nil), &block); end
  end
end

# Action methods defined by Sequel that execute code on the database.
#
# source://sequel//lib/sequel/dataset/actions.rb#13
Sequel::Dataset::ACTION_METHODS = T.let(T.unsafe(nil), Array)

# Default implementation of the argument mapper to allow
# native database support for bind variables and prepared
# statements (as opposed to the emulated ones used by default).
#
# source://sequel//lib/sequel/dataset/prepared_statements.rb#43
module Sequel::Dataset::ArgumentMapper
  # The bind arguments to use for running this prepared statement
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#50
  def bind_arguments; end

  # Set the bind arguments based on the hash and call super.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#55
  def call(bind_vars = T.unsafe(nil), &block); end

  # Override the given *_sql method based on the type, and
  # cache the result of the sql.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#64
  def prepared_sql; end

  # The name of the prepared statement, if any.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#45
  def prepared_statement_name; end

  private

  # Report that prepared statements are not emulated, since
  # all adapters that use this use native prepared statements.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#75
  def emulate_prepared_statements?; end
end

# source://sequel//lib/sequel/dataset/sql.rb#251
Sequel::Dataset::BITWISE_METHOD_MAP = T.let(T.unsafe(nil), Hash)

# The clone options to use when retrieving columns for a dataset.
#
# source://sequel//lib/sequel/dataset/actions.rb#22
Sequel::Dataset::COLUMNS_CLONE_OPTIONS = T.let(T.unsafe(nil), Hash)

# The dataset options that require the removal of cached columns if changed.
#
# source://sequel//lib/sequel/dataset/query.rb#22
Sequel::Dataset::COLUMN_CHANGE_OPTS = T.let(T.unsafe(nil), Array)

# These symbols have _join methods created (e.g. inner_join) that
# call join_table with the symbol, passing along the arguments and
# block from the method call.
#
# source://sequel//lib/sequel/dataset/query.rb#31
Sequel::Dataset::CONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/sql.rb#252
Sequel::Dataset::COUNT_FROM_SELF_OPTS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/sql.rb#247
Sequel::Dataset::COUNT_OF_ALL_AS_COUNT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

# source://sequel//lib/sequel/dataset/actions.rb#95
Sequel::Dataset::COUNT_SELECT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

# source://sequel//lib/sequel/dataset/sql.rb#248
Sequel::Dataset::DEFAULT = T.let(T.unsafe(nil), Sequel::LiteralString)

# source://sequel//lib/sequel/dataset/prepared_statements.rb#13
Sequel::Dataset::DEFAULT_PREPARED_STATEMENT_MODULE_METHODS = T.let(T.unsafe(nil), Array)

# This Module subclass is used by Database#extend_datasets
# and Dataset#with_extend to add dataset methods to classes.
# It adds some helper methods inside the module that can define
# named methods on the dataset instances which do specific actions.
# For example:
#
#   DB.extend_datasets do
#     order :by_id, :id
#     select :with_id_and_name, :id, :name
#     where :active, :active
#   end
#
#   DB[:table].active.with_id_and_name.by_id
#   # SELECT id, name FROM table WHERE active ORDER BY id
#
# source://sequel//lib/sequel/dataset/dataset_module.rb#19
class Sequel::Dataset::DatasetModule < ::Module
  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def distinct(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def exclude(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def exclude_having(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def grep(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def group(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def group_and_count(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def group_append(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def having(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def limit(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def offset(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def order(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def order_append(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def order_prepend(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def reverse(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def select(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def select_all(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def select_append(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def select_group(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def server(name, *args, &block); end

  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def where(name, *args, &block); end

  class << self
    # Define a method in the module
    #
    # source://sequel//lib/sequel/dataset/dataset_module.rb#28
    def def_dataset_caching_method(mod, meth); end
  end
end

# This module implements methods to support deprecated use of extensions registered
# not using a module.  In such cases, for backwards compatibility, Sequel has to use
# a singleton class for the dataset.
#
# source://sequel//lib/sequel/dataset/deprecated_singleton_class_methods.rb#8
module Sequel::Dataset::DeprecatedSingletonClassMethods
  # Load the extension into a clone of the receiver.
  #
  # source://sequel//lib/sequel/dataset/deprecated_singleton_class_methods.rb#10
  def extension(*a); end

  # Extend the cloned of the receiver with the given modules, instead of the default
  # approach of creating a subclass of the receiver's class and including the modules
  # into that.
  #
  # source://sequel//lib/sequel/dataset/deprecated_singleton_class_methods.rb#19
  def with_extend(*mods, &block); end

  private

  # Load the extensions into the receiver.
  #
  # source://sequel//lib/sequel/dataset/deprecated_singleton_class_methods.rb#29
  def _extension!(exts); end
end

# source://sequel//lib/sequel/dataset/query.rb#19
Sequel::Dataset::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/actions.rb#169
Sequel::Dataset::EMPTY_SELECT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

# source://sequel//lib/sequel/dataset/sql.rb#250
Sequel::Dataset::EXISTS = T.let(T.unsafe(nil), Array)

# Hash of extension name symbols to callable objects to load the extension
# into the Dataset object (usually by extending it with a module defined
# in the extension).
#
# source://sequel//lib/sequel/dataset/query.rb#13
Sequel::Dataset::EXTENSIONS = T.let(T.unsafe(nil), Hash)

# Hash of extension name symbols to modules to load to implement the extension.
#
# source://sequel//lib/sequel/dataset/query.rb#16
Sequel::Dataset::EXTENSION_MODULES = T.let(T.unsafe(nil), Hash)

# Prepared statements emulation support for adapters that don't
# support native prepared statements.  Uses a placeholder
# literalizer to hold the prepared sql with the ability to
# interpolate arguments to prepare the final SQL string.
#
# source://sequel//lib/sequel/dataset/prepared_statements.rb#272
module Sequel::Dataset::EmulatePreparedStatementMethods
  include ::Sequel::Dataset::ArgumentMapper
  include ::Sequel::Dataset::UnnumberedArgumentMapper

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#275
  def run(&block); end

  private

  # Turn emulation of prepared statements back on, since ArgumentMapper
  # turns it off.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#288
  def emulate_prepared_statements?; end

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#292
  def emulated_prepared_statement(type, name, values); end

  # Associates the argument with name k with the next position in
  # the output array.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#314
  def prepared_arg(k); end

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#319
  def subselect_sql_dataset(sql, ds); end
end

# source://sequel//lib/sequel/dataset/sql.rb#253
Sequel::Dataset::IS_LITERALS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/dataset/sql.rb#256
Sequel::Dataset::IS_OPERATORS = T.let(T.unsafe(nil), Array)

# All methods that return modified datasets with a joined table added.
#
# source://sequel//lib/sequel/dataset/query.rb#39
Sequel::Dataset::JOIN_METHODS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/sql.rb#257
Sequel::Dataset::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)

# Mapping of merge types to related SQL
#
# source://sequel//lib/sequel/dataset/sql.rb#874
Sequel::Dataset::MERGE_TYPE_SQL = T.let(T.unsafe(nil), Hash)

# Which options don't affect the SQL generation.  Used by simple_select_all?
# to determine if this is a simple SELECT * FROM table.
#
# source://sequel//lib/sequel/dataset/query.rb#26
Sequel::Dataset::NON_SQL_OPTIONS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/sql.rb#258
Sequel::Dataset::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset.rb#30
Sequel::Dataset::OPTS = T.let(T.unsafe(nil), Hash)

# ---------------------
# :section: 8 - Methods related to prepared statements or bound variables
# On some adapters, these use native prepared statements and bound variables, on others
# support is emulated.  For details, see the {"Prepared Statements/Bound Variables" guide}[rdoc-ref:doc/prepared_statements.rdoc].
# ---------------------
#
# source://sequel//lib/sequel/dataset/prepared_statements.rb#11
Sequel::Dataset::PREPARED_ARG_PLACEHOLDER = T.let(T.unsafe(nil), Sequel::LiteralString)

# source://sequel//lib/sequel/dataset/prepared_statements.rb#14
Sequel::Dataset::PREPARED_STATEMENT_MODULE_CODE = T.let(T.unsafe(nil), Hash)

# PlaceholderLiteralizer allows you to record the application of arbitrary changes
# to a dataset with placeholder arguments, recording where those placeholder arguments
# are used in the query.  When running the query, the literalization process is much
# faster as Sequel can skip most of the work it normally has to do when literalizing a
# dataset.
#
# Basically, this enables optimizations that allow Sequel to cache the SQL produced
# for a given dataset, so that it doesn't need to recompute that information every
# time.
#
# Example:
#
#   loader = Sequel::Dataset::PlaceholderLiteralizer.loader(DB[:items]) do |pl, ds|
#     ds.where(id: pl.arg).exclude(name: pl.arg).limit(1)
#   end
#   loader.first(1, "foo")
#   # SELECT * FROM items WHERE ((id = 1) AND (name != 'foo')) LIMIT 1
#   loader.first(2, "bar")
#   # SELECT * FROM items WHERE ((id = 2) AND (name != 'bar')) LIMIT 1
#
# Caveats:
#
# Note that this method does not handle all possible cases.  For example:
#
#   loader = Sequel::Dataset::PlaceholderLiteralizer.loader(DB[:items]) do |pl, ds|
#     ds.join(pl.arg, item_id: :id)
#   end
#   loader.all(:cart_items)
#
# Will not qualify the item_id column with cart_items.  In this type of situation it's
# best to add a table alias when joining:
#
#   loader = Sequel::Dataset::PlaceholderLiteralizer.loader(DB[:items]) do |pl, ds|
#     ds.join(Sequel.as(pl.arg, :t), item_id: :id)
#   end
#   loader.all(:cart_items)
#
# There are other similar cases that are not handled, mainly when Sequel changes the
# SQL produced depending on the types of the arguments.
#
# source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#44
class Sequel::Dataset::PlaceholderLiteralizer
  # Save the dataset, array of SQL fragments, and ending SQL string.
  #
  # @return [PlaceholderLiteralizer] a new instance of PlaceholderLiteralizer
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#152
  def initialize(dataset, fragments, final_sql, arity); end

  # Return an array of all objects by running the SQL query for the given arguments.
  # If a block is given, yields all objects to the block after loading them.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#179
  def all(*args, &block); end

  # Append the SQL query to use for the given arguments to the given SQL string.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#207
  def append_sql(sql, *args); end

  # Run the SQL query for the given arguments, yielding each returned row to the block.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#184
  def each(*args, &block); end

  # Run the SQL query for the given arguments, returning the first row.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#189
  def first(*args); end

  # Freeze the fragments and final SQL when freezing the literalizer.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#161
  def freeze; end

  # Run the SQL query for the given arguments, returning the first value.  For this to
  # make sense, the dataset should return a single row with a single value (or no rows).
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#195
  def get(*args); end

  # Return the SQL query to use for the given arguments.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#200
  def sql(*args); end

  # Return a new PlaceholderLiteralizer with a modified dataset.  This yields the
  # receiver's dataset to the block, and the block should return the new dataset
  # to use.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#170
  def with_dataset; end

  private

  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#225
  def sql_origin; end

  class << self
    # Create a PlaceholderLiteralizer by yielding a Recorder and dataset to the
    # given block, recording the offsets at which the recorders arguments
    # are used in the query.
    #
    # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#147
    def loader(dataset, &block); end
  end
end

# A placeholder argument used by the PlaceholderLiteralizer.  This records the offset
# that the argument should be used in the resulting SQL.
#
# source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#47
class Sequel::Dataset::PlaceholderLiteralizer::Argument
  # Set the recorder, the argument position, and any transforming block to use
  # for this placeholder.
  #
  # @return [Argument] a new instance of Argument
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#50
  def initialize(recorder, pos, transformer = T.unsafe(nil)); end

  # Record the SQL query offset, argument position, and transforming block where the
  # argument should be literalized.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#59
  def sql_literal_append(ds, sql); end

  # Return a new Argument object for the same recorder and argument position, but with a
  # different transformer block.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#69
  def transform(&block); end
end

# Records the offsets at which the placeholder arguments are used in
# the SQL query.
#
# source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#76
class Sequel::Dataset::PlaceholderLiteralizer::Recorder
  # Return an Argument with the specified position, or the next position. In
  # general you shouldn't mix calls with an argument and calls without an
  # argument for the same receiver.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#87
  def arg(v = T.unsafe(nil)); end

  # Yields the receiver and the dataset to the block, which should
  # call #arg on the receiver for each placeholder argument, and
  # return the dataset that you want to load.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#80
  def loader(pl, dataset, &block); end

  # Record the offset at which the argument is used in the SQL query, and any
  # transforming block.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#96
  def use(sql, arg, transformer); end

  private

  # Return an array with two elements, the first being an
  # SQL string with interpolated prepared argument placeholders
  # (suitable for inspect), the the second being an array of
  # SQL fragments suitable for using for creating a
  # Sequel::SQL::PlaceholderLiteralString. Designed for use with
  # emulated prepared statements.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#108
  def prepared_sql_and_frags(dataset, prepared_args, &block); end

  # Internals of #loader and #prepared_sql_and_frags.
  #
  # source://sequel//lib/sequel/dataset/placeholder_literalizer.rb#124
  def process(dataset); end
end

# Backbone of the prepared statement support.  Grafts bind variable
# support into datasets by hijacking #literal and using placeholders.
# By default, emulates prepared statements and bind variables by
# taking the hash of bind variables and directly substituting them
# into the query, which works on all databases, as it is no different
# from using the dataset without bind variables.
#
# source://sequel//lib/sequel/dataset/prepared_statements.rb#86
module Sequel::Dataset::PreparedStatementMethods
  # Sets the prepared_args to the given hash and runs the
  # prepared statement.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#117
  def call(bind_vars = T.unsafe(nil), &block); end

  # Send the columns to the original dataset, as calling it
  # on the prepared statement can cause problems.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#130
  def columns; end

  # Disallow use of delayed evaluations in prepared statements.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#135
  def delayed_evaluation_sql_append(sql, delay); end

  # Programmer friendly string showing this is a prepared statement,
  # with the prepared SQL it represents (which in general won't have
  # substituted variables).
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#176
  def inspect; end

  # Changes the values of symbols if they start with $ and
  # prepared_args is present.  If so, they are considered placeholders,
  # and they are substituted using prepared_arg.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#165
  def literal_symbol_append(sql, v); end

  # Whether to log the full SQL query.  By default, just the prepared statement
  # name is generally logged on adapters that support native prepared statements.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#89
  def log_sql; end

  # The dataset that created this prepared statement.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#105
  def orig_dataset; end

  # Raise an error if attempting to call prepare on an already
  # prepared statement.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#123
  def prepare(*_arg0); end

  # The array/hash of bound variable placeholder names.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#100
  def prepared_args; end

  # The argument to supply to insert and update, which may use
  # placeholders specified by prepared_args
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#111
  def prepared_modify_values; end

  # Returns the SQL for the prepared statement, depending on
  # the type of the statement and the prepared_modify_values.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#142
  def prepared_sql; end

  # The type of prepared statement, should be one of :select, :first,
  # :insert, :update, :delete, or :single_value
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#95
  def prepared_type; end

  protected

  # Run the method based on the type of prepared statement.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#183
  def run(&block); end

  private

  # Returns the value of the prepared_args hash for the given key.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#220
  def prepared_arg(k); end

  # The symbol cache should always be skipped, since placeholders are symbols.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#225
  def skip_symbol_cache?; end

  # Use a clone of the dataset extended with prepared statement
  # support and using the same argument hash so that you can use
  # bind variables/prepared arguments in subselects.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#232
  def subselect_sql_append(sql, ds); end

  # source://sequel//lib/sequel/dataset/prepared_statements.rb#236
  def subselect_sql_dataset(sql, ds); end
end

# source://sequel//lib/sequel/dataset/sql.rb#254
Sequel::Dataset::QUALIFY_KEYS = T.let(T.unsafe(nil), Array)

# Methods that return modified datasets
#
# source://sequel//lib/sequel/dataset/query.rb#42
Sequel::Dataset::QUERY_METHODS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/dataset/sql.rb#260
Sequel::Dataset::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)

# From types allowed to be considered a simple_select_all
#
# source://sequel//lib/sequel/dataset/query.rb#1311
Sequel::Dataset::SIMPLE_SELECT_ALL_ALLOWED_FROM = T.let(T.unsafe(nil), Array)

# Whether Dataset#freeze can actually freeze datasets.  True only on ruby 2.4+,
# as it requires clone(freeze: false)
#
# source://sequel//lib/sequel/dataset.rb#34
Sequel::Dataset::TRUE_FREEZE = T.let(T.unsafe(nil), TrueClass)

# source://sequel//lib/sequel/dataset/sql.rb#259
Sequel::Dataset::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

# These symbols have _join methods created (e.g. natural_join).
# They accept a table argument and options hash which is passed to join_table,
# and they raise an error if called with a block.
#
# source://sequel//lib/sequel/dataset/query.rb#36
Sequel::Dataset::UNCONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)

# Default implementation for an argument mapper that uses
# unnumbered SQL placeholder arguments.  Keeps track of which
# arguments have been used, and allows arguments to
# be used more than once.
#
# source://sequel//lib/sequel/dataset/prepared_statements.rb#246
module Sequel::Dataset::UnnumberedArgumentMapper
  include ::Sequel::Dataset::ArgumentMapper

  protected

  # Returns a single output array mapping the values of the input hash.
  # Keys in the input hash that are used more than once in the query
  # have multiple entries in the output array.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#254
  def map_to_prepared_args(bind_vars); end

  private

  # Associates the argument with name k with the next position in
  # the output array.
  #
  # source://sequel//lib/sequel/dataset/prepared_statements.rb#262
  def prepared_arg(k); end
end

# source://sequel//lib/sequel/dataset/sql.rb#246
Sequel::Dataset::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)

# This module makes it easy to print deprecation warnings with optional backtraces to a given stream.
# There are a two accessors you can use to change how/where the deprecation methods are printed
# and whether/how backtraces should be included:
#
#   Sequel::Deprecation.output = $stderr # print deprecation messages to standard error (default)
#   Sequel::Deprecation.output = File.open('deprecated_calls.txt', 'wb') # use a file instead
#   Sequel::Deprecation.output = false # do not output deprecation messages
#
#   Sequel::Deprecation.prefix = "SEQUEL DEPRECATION WARNING: " # prefix deprecation messages with a given string (default)
#   Sequel::Deprecation.prefix = false # do not prefix deprecation messages
#
#   Sequel::Deprecation.backtrace_filter = false # don't include backtraces
#   Sequel::Deprecation.backtrace_filter = true # include full backtraces
#   Sequel::Deprecation.backtrace_filter = 10 # include 10 backtrace lines (default)
#   Sequel::Deprecation.backtrace_filter = 1 # include 1 backtrace line
#   Sequel::Deprecation.backtrace_filter = lambda{|line, line_no| line_no < 3 || line =~ /my_app/} # select backtrace lines to output
#
# source://sequel//lib/sequel/deprecated.rb#20
module Sequel::Deprecation
  class << self
    # How to filter backtraces.  +false+ does not include backtraces, +true+ includes
    # full backtraces, an Integer includes that number of backtrace lines, and
    # a proc is called with the backtrace line and line number to select the backtrace
    # lines to include.  The default is 10 backtrace lines.
    #
    # source://sequel//lib/sequel/deprecated.rb#30
    def backtrace_filter; end

    # How to filter backtraces.  +false+ does not include backtraces, +true+ includes
    # full backtraces, an Integer includes that number of backtrace lines, and
    # a proc is called with the backtrace line and line number to select the backtrace
    # lines to include.  The default is 10 backtrace lines.
    #
    # source://sequel//lib/sequel/deprecated.rb#30
    def backtrace_filter=(_arg0); end

    # Print the message and possibly backtrace to the output.
    #
    # source://sequel//lib/sequel/deprecated.rb#40
    def deprecate(method, instead = T.unsafe(nil)); end

    # If using ruby 2.3+, use Module#deprecate_constant to deprecate the constant,
    # otherwise do nothing as the ruby implementation does not support constant deprecation.
    #
    # source://sequel//lib/sequel/deprecated.rb#62
    def deprecate_constant(mod, constant); end

    # Where deprecation messages should be output, must respond to puts.  $stderr by default.
    #
    # source://sequel//lib/sequel/deprecated.rb#33
    def output; end

    # Where deprecation messages should be output, must respond to puts.  $stderr by default.
    #
    # source://sequel//lib/sequel/deprecated.rb#33
    def output=(_arg0); end

    # Where deprecation messages should be prefixed with ("SEQUEL DEPRECATION WARNING: " by default).
    #
    # source://sequel//lib/sequel/deprecated.rb#36
    def prefix; end

    # Where deprecation messages should be prefixed with ("SEQUEL DEPRECATION WARNING: " by default).
    #
    # source://sequel//lib/sequel/deprecated.rb#36
    def prefix=(_arg0); end
  end
end

# The default exception class for exceptions raised by Sequel.
# All exception classes defined by Sequel are descendants of this class.
#
# source://sequel//lib/sequel/exceptions.rb#6
class Sequel::Error < ::StandardError
  # Returned the wrapped exception if one exists, otherwise use
  # ruby's default behavior.
  #
  # source://sequel//lib/sequel/exceptions.rb#16
  def cause; end

  # If this exception wraps an underlying exception, the underlying
  # exception is held here.
  #
  # source://sequel//lib/sequel/exceptions.rb#9
  def wrapped_exception; end

  # If this exception wraps an underlying exception, the underlying
  # exception is held here.
  #
  # source://sequel//lib/sequel/exceptions.rb#9
  def wrapped_exception=(_arg0); end
end

# source://sequel//lib/sequel/exceptions.rb#60
class Sequel::ForeignKeyConstraintViolation < ::Sequel::ConstraintViolation; end

# Exception class raised when +raise_on_save_failure+ is set and an action is canceled in a hook.
# or an around hook doesn't yield.
#
# source://sequel//lib/sequel/model/exceptions.rb#6
class Sequel::HookFailed < ::Sequel::Error
  # @return [HookFailed] a new instance of HookFailed
  #
  # source://sequel//lib/sequel/model/exceptions.rb#10
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil)); end

  # The Sequel::Model instance related to this error.
  #
  # source://sequel//lib/sequel/model/exceptions.rb#8
  def model; end
end

# This module acts as a singleton returned/yielded by Sequel.inflections,
# which is used to override or specify additional inflection rules
# for Sequel. Examples:
#
#   Sequel.inflections do |inflect|
#     inflect.plural /^(ox)$/i, '\1\2en'
#     inflect.singular /^(ox)en/i, '\1'
#
#     inflect.irregular 'octopus', 'octopi'
#
#     inflect.uncountable "equipment"
#   end
#
# New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the
# pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may
# already have been loaded.
#
# source://sequel//lib/sequel/model/inflections.rb#27
module Sequel::Inflections
  private

  # Convert the given string to CamelCase.  Will also convert '/' to '::' which is useful for converting paths to namespaces.
  #
  # source://sequel//lib/sequel/model/inflections.rb#100
  def camelize(s); end

  # Tries to find a declared constant with the name specified
  # in the string. It raises a NameError when the name is not in CamelCase
  # or is not initialized.
  #
  # @raise [NameError]
  #
  # source://sequel//lib/sequel/model/inflections.rb#110
  def constantize(s); end

  # Removes the module part from the expression in the string
  #
  # source://sequel//lib/sequel/model/inflections.rb#118
  def demodulize(s); end

  # Returns the plural form of the word in the string.
  #
  # source://sequel//lib/sequel/model/inflections.rb#125
  def pluralize(s); end

  # The reverse of pluralize, returns the singular form of a word in a string.
  #
  # source://sequel//lib/sequel/model/inflections.rb#134
  def singularize(s); end

  # The reverse of camelize. Makes an underscored form from the expression in the string.
  # Also changes '::' to '/' to convert namespaces to paths.
  #
  # source://sequel//lib/sequel/model/inflections.rb#144
  def underscore(s); end

  class << self
    # Clears the loaded inflections within a given scope (default is :all). Give the scope as a symbol of the inflection type,
    # the options are: :plurals, :singulars, :uncountables
    #
    # Examples:
    #   clear :all
    #   clear :plurals
    #
    # source://sequel//lib/sequel/model/inflections.rb#47
    def clear(scope = T.unsafe(nil)); end

    # Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
    # for strings, not regular expressions. You simply pass the irregular in singular and plural form.
    #
    # Examples:
    #   irregular 'octopus', 'octopi'
    #   irregular 'person', 'people'
    #
    # source://sequel//lib/sequel/model/inflections.rb#62
    def irregular(singular, plural); end

    # Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
    # The replacement should always be a string that may include references to the matched data from the rule.
    #
    # Example:
    #   plural(/(x|ch|ss|sh)$/i, '\1es')
    #
    # source://sequel//lib/sequel/model/inflections.rb#72
    def plural(rule, replacement); end

    # Array of two element arrays, first containing a regex, and the second containing a substitution pattern, used for plurization.
    #
    # source://sequel//lib/sequel/model/inflections.rb#32
    def plurals; end

    # Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
    # The replacement should always be a string that may include references to the matched data from the rule.
    #
    # Example:
    #   singular(/([^aeiouy]|qu)ies$/i, '\1y')
    #
    # source://sequel//lib/sequel/model/inflections.rb#81
    def singular(rule, replacement); end

    # Array of two element arrays, first containing a regex, and the second containing a substitution pattern, used for singularization.
    #
    # source://sequel//lib/sequel/model/inflections.rb#35
    def singulars; end

    # Add uncountable words that shouldn't be attempted inflected.
    #
    # Examples:
    #   uncountable "money"
    #   uncountable "money", "information"
    #   uncountable %w( money information rice )
    #
    # source://sequel//lib/sequel/model/inflections.rb#91
    def uncountable(*words); end

    # Array of strings for words were the singular form is the same as the plural form
    #
    # source://sequel//lib/sequel/model/inflections.rb#38
    def uncountables; end
  end
end

# source://sequel//lib/sequel/exceptions.rb#88
class Sequel::InvalidOperation < ::Sequel::Error; end

# source://sequel//lib/sequel/exceptions.rb#93
class Sequel::InvalidValue < ::Sequel::Error; end

# +LiteralString+ is used to represent literal SQL expressions. A
# +LiteralString+ is copied verbatim into an SQL statement. Instances of
# +LiteralString+ can be created by calling <tt>Sequel.lit</tt>.
#
# source://sequel//lib/sequel/sql.rb#17
class Sequel::LiteralString < ::String
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods

  # Show that the current string is a literal string in addition to the output.
  #
  # source://sequel//lib/sequel/sql.rb#2030
  def inspect; end

  # Return self if no args are given, otherwise return a SQL::PlaceholderLiteralString
  # with the current string and the given args.
  #
  # source://sequel//lib/sequel/sql.rb#2036
  def lit(*args); end

  # Convert a literal string to a SQL::Blob.
  #
  # source://sequel//lib/sequel/sql.rb#2041
  def to_sequel_blob; end
end

# The major version of Sequel.  Only bumped for major changes.
#
# source://sequel//lib/sequel/version.rb#5
Sequel::MAJOR = T.let(T.unsafe(nil), Integer)

# The minor version of Sequel.  Bumped for every non-patch level
# release, generally around once a month.
#
# source://sequel//lib/sequel/version.rb#9
Sequel::MINOR = T.let(T.unsafe(nil), Integer)

# source://sequel//lib/sequel/model/exceptions.rb#30
class Sequel::MassAssignmentRestriction < ::Sequel::Error; end

# <tt>Sequel::Model</tt> is an object relational mapper built on top of Sequel core.  Each
# model class is backed by a dataset instance, and many dataset methods can be
# called directly on the class.  Model datasets return rows as model instances,
# which are wrappers around the underlying hash that allow easily updating or
# deleting the individual row.
#
# <tt>Sequel::Model</tt> is built completely out of plugins.  Plugins can override any class,
# instance, or dataset method defined by a previous plugin and call super to get the default
# behavior.  By default, <tt>Sequel::Model</tt> loads two plugins, <tt>Sequel::Model</tt>
# (which is itself a plugin) for the base support, and <tt>Sequel::Model::Associations</tt>
# for the associations support.
#
# You can set the +SEQUEL_NO_ASSOCIATIONS+ constant or environment variable to
# make Sequel not load the associations plugin by default.
#
# source://sequel//lib/sequel/model.rb#20
class Sequel::Model
  include ::Sequel::Model::InstanceMethods
  include ::Sequel::Model::Associations::InstanceMethods
  extend ::Enumerable
  extend ::Sequel::Inflections
  extend ::Sequel::Model::ClassMethods
  extend ::Sequel::Model::Associations::ClassMethods
end

# Associations are used in order to specify relationships between model classes
# that reflect relations between tables in the database using foreign keys.
#
# source://sequel//lib/sequel/model/associations.rb#7
module Sequel::Model::Associations
  class << self
    # Set an empty association reflection hash in the model
    #
    # source://sequel//lib/sequel/model/associations.rb#12
    def apply(model); end
  end
end

# Map of association type symbols to association reflection classes.
#
# source://sequel//lib/sequel/model/associations.rb#9
Sequel::Model::Associations::ASSOCIATION_TYPES = T.let(T.unsafe(nil), Hash)

# This module contains methods added to all association datasets
#
# source://sequel//lib/sequel/model/associations.rb#1514
module Sequel::Model::Associations::AssociationDatasetMethods
  # The association reflection related to the association dataset
  #
  # source://sequel//lib/sequel/model/associations.rb#1521
  def association_reflection; end

  # The model object that created the association dataset
  #
  # source://sequel//lib/sequel/model/associations.rb#1516
  def model_object; end

  private

  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1527
  def non_sql_option?(key); end
end

# AssociationReflection is a Hash subclass that keeps information on Sequel::Model associations. It
# provides methods to reduce internal code duplication.  It should not
# be instantiated by the user.
#
# source://sequel//lib/sequel/model/associations.rb#32
class Sequel::Model::Associations::AssociationReflection < ::Hash
  include ::Sequel::Inflections

  # Name symbol for the _add internal association method
  #
  # source://sequel//lib/sequel/model/associations.rb#36
  def _add_method; end

  # Name symbol for the _remove_all internal association method
  #
  # source://sequel//lib/sequel/model/associations.rb#41
  def _remove_all_method; end

  # Name symbol for the _remove internal association method
  #
  # source://sequel//lib/sequel/model/associations.rb#46
  def _remove_method; end

  # Name symbol for the _setter association method
  #
  # source://sequel//lib/sequel/model/associations.rb#51
  def _setter_method; end

  # Name symbol for the add association method
  #
  # source://sequel//lib/sequel/model/associations.rb#56
  def add_method; end

  # Apply all non-instance specific changes to the given dataset and return it.
  #
  # source://sequel//lib/sequel/model/associations.rb#84
  def apply_dataset_changes(ds); end

  # Use DISTINCT ON and ORDER BY clauses to limit the results to the first record with matching keys.
  #
  # source://sequel//lib/sequel/model/associations.rb#138
  def apply_distinct_on_eager_limit_strategy(ds); end

  # Apply all non-instance specific changes and the eager_block option to the given
  # dataset and return it.
  #
  # source://sequel//lib/sequel/model/associations.rb#103
  def apply_eager_dataset_changes(ds); end

  # Apply the eager graph limit strategy to the dataset to graph into the current dataset, or return
  # the dataset unmodified if no SQL limit strategy is needed.
  #
  # source://sequel//lib/sequel/model/associations.rb#113
  def apply_eager_graph_limit_strategy(strategy, ds); end

  # Apply an eager limit strategy to the dataset, or return the dataset
  # unmodified if it doesn't need an eager limit strategy.
  #
  # source://sequel//lib/sequel/model/associations.rb#126
  def apply_eager_limit_strategy(ds, strategy = T.unsafe(nil), limit_and_offset = T.unsafe(nil)); end

  # If the ruby eager limit strategy is being used, slice the array using the slice
  # range to return the object(s) at the correct offset/limit.
  #
  # source://sequel//lib/sequel/model/associations.rb#165
  def apply_ruby_eager_limit_strategy(rows, limit_and_offset = T.unsafe(nil)); end

  # Use a window function to limit the results of the eager loading dataset.
  #
  # source://sequel//lib/sequel/model/associations.rb#144
  def apply_window_function_eager_limit_strategy(ds, limit_and_offset = T.unsafe(nil)); end

  # Whether the associations cache should use an array when storing the
  # associated records during eager loading.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#178
  def assign_singular?; end

  # The class associated to the current model class via this association
  #
  # source://sequel//lib/sequel/model/associations.rb#66
  def associated_class; end

  # The dataset associated via this association, with the non-instance specific
  # changes already applied.  This will be a joined dataset if the association
  # requires joining tables.
  #
  # source://sequel//lib/sequel/model/associations.rb#79
  def associated_dataset; end

  # Return an dataset that will load the appropriate associated objects for
  # the given object using this association.
  #
  # source://sequel//lib/sequel/model/associations.rb#215
  def association_dataset_for(object); end

  # Proc used to create the association dataset method.
  #
  # source://sequel//lib/sequel/model/associations.rb#227
  def association_dataset_proc; end

  # Name symbol for association method, the same as the name of the association.
  #
  # source://sequel//lib/sequel/model/associations.rb#61
  def association_method; end

  # Whether this association can have associated objects, given the current
  # object.  Should be false if obj cannot have associated objects because
  # the necessary key columns are NULL.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#185
  def can_have_associated_objects?(obj); end

  # Whether you are able to clone from the given association type to the current
  # association type, true by default only if the types match.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#191
  def cloneable?(ref); end

  # Name symbol for the dataset association method
  #
  # source://sequel//lib/sequel/model/associations.rb#196
  def dataset_method; end

  # Whether the dataset needs a primary key to function, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#201
  def dataset_need_primary_key?; end

  # Return the symbol used for the row number column if the window function
  # eager limit strategy is being used, or nil otherwise.
  #
  # source://sequel//lib/sequel/model/associations.rb#207
  def delete_row_number_column(ds = T.unsafe(nil)); end

  # Whether to eagerly graph a lazy dataset, true by default.  If this
  # is false, the association won't respect the :eager_graph option
  # when loading the association for a single record.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#354
  def eager_graph_lazy_dataset?; end

  # The eager_graph limit strategy to use for this dataset
  #
  # source://sequel//lib/sequel/model/associations.rb#232
  def eager_graph_limit_strategy(strategy); end

  # The eager limit strategy to use for this dataset.
  #
  # source://sequel//lib/sequel/model/associations.rb#249
  def eager_limit_strategy; end

  # Eager load the associated objects using the hash of eager options,
  # yielding each row to the block.
  #
  # source://sequel//lib/sequel/model/associations.rb#264
  def eager_load_results(eo, &block); end

  # The key to use for the key hash when eager loading
  #
  # source://sequel//lib/sequel/model/associations.rb#341
  def eager_loader_key; end

  # By default associations do not need to select a key in an associated table
  # to eagerly load.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#347
  def eager_loading_use_associated_key?; end

  # Whether additional conditions should be added when using the filter
  # by associations support.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#360
  def filter_by_associations_add_conditions?; end

  # The expression to use for the additional conditions to be added for
  # the filter by association support, when the association itself is
  # filtered.  Works by using a subquery to test that the objects passed
  # also meet the association filter criteria.
  #
  # source://sequel//lib/sequel/model/associations.rb#368
  def filter_by_associations_conditions_expression(obj); end

  # Finalize the association by first attempting to populate the thread-safe cache,
  # and then transfering the thread-safe cache value to the association itself,
  # so that a mutex is not needed to get the value.
  #
  # source://sequel//lib/sequel/model/associations.rb#376
  def finalize; end

  # source://sequel//lib/sequel/model/associations.rb#407
  def finalize_settings; end

  # Whether to handle silent modification failure when adding/removing
  # associated records, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#413
  def handle_silent_modification_failure?; end

  # Initialize the associations cache for the current association for the given objects.
  #
  # source://sequel//lib/sequel/model/associations.rb#418
  def initialize_association_cache(objects); end

  # Show which type of reflection this is, and a guess at what code was used to create the
  # association.
  #
  # source://sequel//lib/sequel/model/associations.rb#429
  def inspect; end

  # The limit and offset for this association (returned as a two element array).
  #
  # source://sequel//lib/sequel/model/associations.rb#440
  def limit_and_offset; end

  # Whether the associated object needs a primary key to be added/removed,
  # false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#450
  def need_associated_primary_key?; end

  # A placeholder literalizer that can be used to lazily load the association. If
  # one can't be used, returns nil.
  #
  # source://sequel//lib/sequel/model/associations.rb#456
  def placeholder_loader; end

  # The values that predicate_keys should match for objects to be associated.
  #
  # source://sequel//lib/sequel/model/associations.rb#476
  def predicate_key_values(object); end

  # The keys to use for loading of the regular dataset, as an array.
  #
  # source://sequel//lib/sequel/model/associations.rb#471
  def predicate_keys; end

  # Qualify +col+ with the given table name.
  #
  # source://sequel//lib/sequel/model/associations.rb#481
  def qualify(table, col); end

  # Qualify col with the associated model's table name.
  #
  # source://sequel//lib/sequel/model/associations.rb#493
  def qualify_assoc(col); end

  # Qualify col with the current model's table name.
  #
  # source://sequel//lib/sequel/model/associations.rb#498
  def qualify_cur(col); end

  # Returns the reciprocal association variable, if one exists. The reciprocal
  # association is the association in the associated class that is the opposite
  # of the current association.  For example, Album.many_to_one :artist and
  # Artist.one_to_many :albums are reciprocal associations.  This information is
  # to populate reciprocal associations.  For example, when you do this_artist.add_album(album)
  # it sets album.artist to this_artist.
  #
  # source://sequel//lib/sequel/model/associations.rb#508
  def reciprocal; end

  # Whether the reciprocal of this association returns an array of objects instead of a single object,
  # true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#527
  def reciprocal_array?; end

  # Name symbol for the remove_all_ association method
  #
  # source://sequel//lib/sequel/model/associations.rb#532
  def remove_all_method; end

  # Whether associated objects need to be removed from the association before
  # being destroyed in order to preserve referential integrity.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#538
  def remove_before_destroy?; end

  # Name symbol for the remove_ association method
  #
  # source://sequel//lib/sequel/model/associations.rb#543
  def remove_method; end

  # Whether to check that an object to be disassociated is already associated to this object, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#548
  def remove_should_check_existing?; end

  # Whether this association returns an array of objects instead of a single object,
  # true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#554
  def returns_array?; end

  # The columns to select when loading the association.
  #
  # source://sequel//lib/sequel/model/associations.rb#559
  def select; end

  # Whether to set the reciprocal association to self when loading associated
  # records, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#565
  def set_reciprocal_to_self?; end

  # Name symbol for the setter association method
  #
  # source://sequel//lib/sequel/model/associations.rb#570
  def setter_method; end

  # The range used for slicing when using the :ruby eager limit strategy.
  #
  # source://sequel//lib/sequel/model/associations.rb#575
  def slice_range(limit_and_offset = T.unsafe(nil)); end

  private

  # The base dataset used for the association, before any order/conditions
  # options have been applied.
  #
  # source://sequel//lib/sequel/model/associations.rb#605
  def _associated_dataset; end

  # Whether for the reciprocal type for the given association cannot be
  # known in advantage, false by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#611
  def ambiguous_reciprocal_type?; end

  # Apply a distinct on eager limit strategy using IN with a subquery
  # that uses DISTINCT ON to ensure only the first matching record for
  # each key is included.
  #
  # source://sequel//lib/sequel/model/associations.rb#631
  def apply_filter_by_associations_distinct_on_limit_strategy(ds); end

  # Apply a limit strategy to the given dataset so that filter by
  # associations works with a limited dataset.
  #
  # source://sequel//lib/sequel/model/associations.rb#617
  def apply_filter_by_associations_limit_strategy(ds); end

  # Apply a distinct on eager limit strategy using IN with a subquery
  # that uses a filter on the row_number window function to ensure
  # that only rows inside the limit are returned.
  #
  # source://sequel//lib/sequel/model/associations.rb#639
  def apply_filter_by_associations_window_function_limit_strategy(ds); end

  # The associated_dataset with the eager_block callback already applied.
  #
  # source://sequel//lib/sequel/model/associations.rb#644
  def associated_eager_dataset; end

  # If the key exists in the reflection hash, return it.
  # If the key doesn't exist and association reflections are uncached, then yield to get the value.
  # If the key doesn't exist and association reflection are cached, check the cache and return
  # the value if present, or yield to get the value, cache the value, and return it.
  #
  # source://sequel//lib/sequel/model/associations.rb#588
  def cached_fetch(key); end

  # Cache the value at the given key if caching.
  #
  # source://sequel//lib/sequel/model/associations.rb#598
  def cached_set(key, value); end

  # The default eager limit strategy to use for this association
  #
  # source://sequel//lib/sequel/model/associations.rb#681
  def default_eager_limit_strategy; end

  # The dataset to use for eager loading associated objects for multiple current objects,
  # given the hash passed to the eager loader.
  #
  # source://sequel//lib/sequel/model/associations.rb#656
  def eager_loading_dataset(eo = T.unsafe(nil)); end

  # The predicate condition to use for the eager_loader.
  #
  # source://sequel//lib/sequel/model/associations.rb#695
  def eager_loading_predicate_condition(keys); end

  # Set the predicate condition for the eager loading dataset based on the id map
  # in the eager loading options.
  #
  # source://sequel//lib/sequel/model/associations.rb#687
  def eager_loading_set_predicate_condition(ds, eo); end

  # Add conditions to the dataset to not include NULL values for
  # the associated keys, and select those keys.
  #
  # source://sequel//lib/sequel/model/associations.rb#701
  def filter_by_associations_add_conditions_dataset_filter(ds); end

  # The base dataset to use for the filter by associations conditions
  # subquery, regardless of the objects that are passed in as filter
  # values.
  #
  # source://sequel//lib/sequel/model/associations.rb#724
  def filter_by_associations_conditions_dataset; end

  # The conditions to add to the filter by associations conditions
  # subquery to restrict it to to the object(s) that was used as the
  # filter value.
  #
  # source://sequel//lib/sequel/model/associations.rb#709
  def filter_by_associations_conditions_subquery_conditions(obj); end

  # The strategy to use to filter by a limited association
  #
  # source://sequel//lib/sequel/model/associations.rb#734
  def filter_by_associations_limit_strategy; end

  # Whether to limit the associated dataset to a single row.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#749
  def limit_to_single_row?; end

  # Any offset to use for this association (or nil if there is no offset).
  #
  # source://sequel//lib/sequel/model/associations.rb#754
  def offset; end

  # A placeholder literalizer used to speed up eager loading.
  #
  # source://sequel//lib/sequel/model/associations.rb#759
  def placeholder_eager_loader; end

  # The reciprocal type as an array, should be overridden in reflection subclasses that
  # have ambiguous reciprocal types.
  #
  # source://sequel//lib/sequel/model/associations.rb#769
  def possible_reciprocal_types; end

  # Whether the given association reflection is possible reciprocal
  # association for the current association reflection.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#775
  def reciprocal_association?(assoc_reflect); end

  # The number of subqueries to use in each union query, used to eagerly load
  # limited associations.  Defaults to 40, the optimal number depends on the
  # latency between the database and the application.
  #
  # source://sequel//lib/sequel/model/associations.rb#785
  def subqueries_per_union; end

  # If +s+ is an array, map +s+ over the block.  Otherwise, just call the
  # block with +s+.
  #
  # source://sequel//lib/sequel/model/associations.rb#791
  def transform(s, &block); end

  # The eager_graph limit strategy used when true is given as the value, choosing the
  # best strategy based on what the database supports.
  #
  # source://sequel//lib/sequel/model/associations.rb#809
  def true_eager_graph_limit_strategy; end

  # What eager limit strategy should be used when true is given as the value,
  # defaults to UNION as that is the fastest strategy if the appropriate keys are indexed.
  #
  # source://sequel//lib/sequel/model/associations.rb#797
  def true_eager_limit_strategy; end

  # A placeholder literalizer used to speed up the creation of union queries when eager
  # loading a limited association.
  #
  # source://sequel//lib/sequel/model/associations.rb#819
  def union_eager_loader; end

  # Whether the placeholder loader can be used to load the association.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#834
  def use_placeholder_loader?; end
end

# source://sequel//lib/sequel/model/associations.rb#225
Sequel::Model::Associations::AssociationReflection::ASSOCIATION_DATASET_PROC = T.let(T.unsafe(nil), Proc)

# Map of methods to cache keys used for finalizing associations.
#
# source://sequel//lib/sequel/model/associations.rb#398
Sequel::Model::Associations::AssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

# Each kind of association adds a number of instance methods to the model class which
# are specialized according to the association type and optional parameters
# given in the definition. Example:
#
#   class Project < Sequel::Model
#     many_to_one :portfolio
#     # or: one_to_one :portfolio
#     one_to_many :milestones
#     # or: many_to_many :milestones
#   end
#
# The project class now has the following instance methods:
# portfolio :: Returns the associated portfolio.
# portfolio=(obj) :: Sets the associated portfolio to the object,
#                    but the change is not persisted until you save the record (for many_to_one associations).
# portfolio_dataset :: Returns a dataset that would return the associated
#                      portfolio, only useful in fairly specific circumstances.
# milestones :: Returns an array of associated milestones
# add_milestone(obj) :: Associates the passed milestone with this object.
# remove_milestone(obj) :: Removes the association with the passed milestone.
# remove_all_milestones :: Removes associations with all associated milestones.
# milestones_dataset :: Returns a dataset that would return the associated
#                       milestones, allowing for further filtering/limiting/etc.
#
# If you want to override the behavior of the add_/remove_/remove_all_/ methods
# or the association setter method, use the :adder, :remover, :clearer, and/or :setter
# options.  These options override the default behavior.
#
# By default the classes for the associations are inferred from the association
# name, so for example the Project#portfolio will return an instance of
# Portfolio, and Project#milestones will return an array of Milestone
# instances.  You can use the :class option to change which class is used.
#
# Association definitions are also reflected by the class, e.g.:
#
#   Project.associations
#   => [:portfolio, :milestones]
#   Project.association_reflection(:portfolio)
#   => #<Sequel::Model::Associations::ManyToOneAssociationReflection Project.many_to_one :portfolio>
#
# Associations should not have the same names as any of the columns in the
# model's current table they reference. If you are dealing with an existing schema that
# has a column named status, you can't name the association status, you'd
# have to name it foo_status or something else.  If you give an association the same name
# as a column, you will probably end up with an association that doesn't work, or a SystemStackError.
#
# For a more in depth general overview, as well as a reference guide,
# see the {Association Basics guide}[rdoc-ref:doc/association_basics.rdoc].
# For examples of advanced usage, see the {Advanced Associations guide}[rdoc-ref:doc/advanced_associations.rdoc].
#
# source://sequel//lib/sequel/model/associations.rb#1581
module Sequel::Model::Associations::ClassMethods
  # Array of all association reflections for this model class
  #
  # source://sequel//lib/sequel/model/associations.rb#1610
  def all_association_reflections; end

  # Associates a related model with the current model. The following types are
  # supported:
  #
  # :many_to_one :: Foreign key in current model's table points to
  #                 associated model's primary key.  Each associated model object can
  #                 be associated with more than one current model objects.  Each current
  #                 model object can be associated with only one associated model object.
  # :one_to_many :: Foreign key in associated model's table points to this
  #                 model's primary key.   Each current model object can be associated with
  #                 more than one associated model objects.  Each associated model object
  #                 can be associated with only one current model object.
  # :one_through_one :: Similar to many_to_many in terms of foreign keys, but only one object
  #                     is associated to the current object through the association.
  #                     Provides only getter methods, no setter or modification methods.
  # :one_to_one :: Similar to one_to_many in terms of foreign keys, but
  #                only one object is associated to the current object through the
  #                association.  The methods created are similar to many_to_one, except
  #                that the one_to_one setter method saves the passed object.
  # :many_to_many :: A join table is used that has a foreign key that points
  #                  to this model's primary key and a foreign key that points to the
  #                  associated model's primary key.  Each current model object can be
  #                  associated with many associated model objects, and each associated
  #                  model object can be associated with many current model objects.
  #
  # The following options can be supplied:
  # === Multiple Types
  # :adder :: Proc used to define the private _add_* method for doing the database work
  #           to associate the given object to the current object (*_to_many assocations).
  #           Set to nil to not define a add_* method for the association.
  # :after_add :: Symbol, Proc, or array of both/either specifying a callback to call
  #               after a new item is added to the association.
  # :after_load :: Symbol, Proc, or array of both/either specifying a callback to call
  #                after the associated record(s) have been retrieved from the database.
  # :after_remove :: Symbol, Proc, or array of both/either specifying a callback to call
  #                  after an item is removed from the association.
  # :after_set :: Symbol, Proc, or array of both/either specifying a callback to call
  #               after an item is set using the association setter method.
  # :allow_eager :: If set to false, you cannot load the association eagerly
  #                 via eager or eager_graph
  # :allow_eager_graph :: If set to false, you cannot load the association eagerly via eager_graph.
  # :allow_filtering_by :: If set to false, you cannot use the association when filtering
  # :before_add :: Symbol, Proc, or array of both/either specifying a callback to call
  #                before a new item is added to the association.
  # :before_remove :: Symbol, Proc, or array of both/either specifying a callback to call
  #                   before an item is removed from the association.
  # :before_set :: Symbol, Proc, or array of both/either specifying a callback to call
  #                before an item is set using the association setter method.
  # :cartesian_product_number :: the number of joins completed by this association that could cause more
  #                              than one row for each row in the current table (default: 0 for
  #                              many_to_one, one_to_one, and one_through_one associations, 1
  #                              for one_to_many and many_to_many associations).
  # :class :: The associated class or its name as a string or symbol. If not
  #           given, uses the association's name, which is camelized (and
  #           singularized unless the type is :many_to_one, :one_to_one, or one_through_one).  If this is specified
  #           as a string or symbol, you must specify the full class name (e.g. "::SomeModule::MyModel").
  # :class_namespace :: If :class is given as a string or symbol, sets the default namespace in which to look for
  #                     the class.  <tt>class: 'Foo', class_namespace: 'Bar'</tt> looks for <tt>::Bar::Foo</tt>.)
  # :clearer :: Proc used to define the private _remove_all_* method for doing the database work
  #             to remove all objects associated to the current object (*_to_many assocations).
  #             Set to nil to not define a remove_all_* method for the association.
  # :clone :: Merge the current options and block into the options and block used in defining
  #           the given association.  Can be used to DRY up a bunch of similar associations that
  #           all share the same options such as :class and :key, while changing the order and block used.
  # :conditions :: The conditions to use to filter the association, can be any argument passed to where.
  #                This option is not respected when using eager_graph or association_join, unless it
  #                is hash or array of two element arrays.  Consider also specifying the :graph_block
  #                option if the value for this option is not a hash or array of two element arrays
  #                and you plan to use this association in eager_graph or association_join.
  # :dataset :: A proc that is used to define the method to get the base dataset to use (before the other
  #             options are applied).  If the proc accepts an argument, it is passed the related
  #             association reflection.  It is a best practice to always have the dataset accept an argument
  #             and use the argument to return the appropriate dataset.
  # :distinct :: Use the DISTINCT clause when selecting associating object, both when
  #              lazy loading and eager loading via .eager (but not when using .eager_graph).
  # :eager :: The associations to eagerly load via +eager+ when loading the associated object(s).
  # :eager_block :: If given, use the block instead of the default block when
  #                 eagerly loading.  To not use a block when eager loading (when one is used normally),
  #                 set to nil.
  # :eager_graph :: The associations to eagerly load via +eager_graph+ when loading the associated object(s).
  #                 many_to_many associations with this option cannot be eagerly loaded via +eager+.
  # :eager_grapher :: A proc to use to implement eager loading via +eager_graph+, overriding the default.
  #                   Takes an options hash with at least the entries :self (the receiver of the eager_graph call),
  #                   :table_alias (the alias to use for table to graph into the association), and :implicit_qualifier
  #                   (the alias that was used for the current table).
  #                   Should return a copy of the dataset with the association graphed into it.
  # :eager_limit_strategy :: Determines the strategy used for enforcing limits and offsets when eager loading
  #                          associations via the +eager+ method.
  # :eager_loader :: A proc to use to implement eager loading, overriding the default.  Takes a single hash argument,
  #                  with at least the keys: :rows, which is an array of current model instances, :associations,
  #                  which is a hash of dependent associations, :self, which is the dataset doing the eager loading,
  #                  :eager_block, which is a dynamic callback that should be called with the dataset, and :id_map,
  #                  which is a mapping of key values to arrays of current model instances. In the proc, the
  #                  associated records should be queried from the database and the associations cache for each
  #                  record should be populated.
  # :eager_loader_key :: A symbol for the key column to use to populate the key_hash
  #                      for the eager loader.  Can be set to nil to not populate the key_hash.
  # :extend :: A module or array of modules to extend the dataset with.
  # :filter_limit_strategy :: Determines the strategy used for enforcing limits and offsets when filtering by
  #                           limited associations.  Possible options are :window_function, :distinct_on, or
  #                           :correlated_subquery depending on association type and database type.
  # :graph_alias_base :: The base name to use for the table alias when eager graphing.  Defaults to the name
  #                      of the association.  If the alias name has already been used in the query, Sequel will create
  #                      a unique alias by appending a numeric suffix (e.g. alias_0, alias_1, ...) until the alias is
  #                      unique.
  # :graph_block :: The block to pass to join_table when eagerly loading
  #                 the association via +eager_graph+.
  # :graph_conditions :: The additional conditions to use on the SQL join when eagerly loading
  #                      the association via +eager_graph+.  Should be a hash or an array of two element arrays. If not
  #                      specified, the :conditions option is used if it is a hash or array of two element arrays.
  # :graph_join_type :: The type of SQL join to use when eagerly loading the association via
  #                     eager_graph.  Defaults to :left_outer.
  # :graph_only_conditions :: The conditions to use on the SQL join when eagerly loading
  #                           the association via +eager_graph+, instead of the default conditions specified by the
  #                           foreign/primary keys.  This option causes the :graph_conditions option to be ignored.
  # :graph_order :: the order to use when using eager_graph, instead of the default order.  This should be used
  #                 in the case where :order contains an identifier qualified by the table's name, which may not match
  #                 the alias used when eager graphing.  By setting this to the unqualified identifier, it will be
  #                 automatically qualified when using eager_graph.
  # :graph_select :: A column or array of columns to select from the associated table
  #                  when eagerly loading the association via +eager_graph+. Defaults to all
  #                  columns in the associated table.
  # :graph_use_association_block :: Makes eager_graph consider the association block. Without this, eager_graph
  #                                 ignores the bock and only use the :graph_* options.
  # :instance_specific :: Marks the association as instance specific. Should be used if the association block
  #                       uses instance specific state, or transient state (accessing current date/time, etc.).
  # :limit :: Limit the number of records to the provided value.  Use
  #           an array with two elements for the value to specify a
  #           limit (first element) and an offset (second element).
  # :methods_module :: The module that methods the association creates will be placed into. Defaults
  #                    to the module containing the model's columns.
  # :no_association_method :: Do not add a method for the association. This can save memory if the association
  #                           method is never used.
  # :no_dataset_method :: Do not add a method for the association dataset. This can save memory if the dataset
  #                       method is never used.
  # :order :: the column(s) by which to order the association dataset.  Can be a
  #           singular column symbol or an array of column symbols.
  # :order_eager_graph :: Whether to add the association's order to the graphed dataset's order when graphing
  #                       via +eager_graph+.  Defaults to true, so set to false to disable.
  # :read_only :: Do not add a setter method (for many_to_one or one_to_one associations),
  #               or add_/remove_/remove_all_ methods (for one_to_many and many_to_many associations).
  # :reciprocal :: the symbol name of the reciprocal association,
  #                if it exists.  By default, Sequel will try to determine it by looking at the
  #                associated model's assocations for a association that matches
  #                the current association's key(s).  Set to nil to not use a reciprocal.
  # :remover :: Proc used to define the private _remove_* method for doing the database work
  #             to remove the association between the given object and the current object (*_to_many assocations).
  #             Set to nil to not define a remove_* method for the association.
  # :select :: the columns to select.  Defaults to the associated class's table_name.* in an association
  #            that uses joins, which means it doesn't include the attributes from the
  #            join table.  If you want to include the join table attributes, you can
  #            use this option, but beware that the join table attributes can clash with
  #            attributes from the model table, so you should alias any attributes that have
  #            the same name in both the join table and the associated table.
  # :setter :: Proc used to define the private _*= method for doing the work to setup the assocation
  #            between the given object and the current object (*_to_one associations).
  #            Set to nil to not define a setter method for the association.
  # :subqueries_per_union :: The number of subqueries to use in each UNION query, for eager
  #                          loading limited associations using the default :union strategy.
  # :validate :: Set to false to not validate when implicitly saving any associated object.
  # === :many_to_one
  # :key :: foreign key in current model's table that references
  #         associated model's primary key, as a symbol.  Defaults to :"#{name}_id".  Can use an
  #         array of symbols for a composite key association.
  # :key_column :: Similar to, and usually identical to, :key, but :key refers to the model method
  #                to call, where :key_column refers to the underlying column.  Should only be
  #                used if the model method differs from the foreign key column, in conjunction
  #                with defining a model alias method for the key column.
  # :primary_key :: column in the associated table that :key option references, as a symbol.
  #                 Defaults to the primary key of the associated table. Can use an
  #                 array of symbols for a composite key association.
  # :primary_key_method :: the method symbol or array of method symbols to call on the associated
  #                        object to get the foreign key values.  Defaults to :primary_key option.
  # :qualify :: Whether to use qualified primary keys when loading the association.  The default
  #             is true, so you must set to false to not qualify.  Qualification rarely causes
  #             problems, but it's necessary to disable in some cases, such as when you are doing
  #             a JOIN USING operation on the column on Oracle.
  # === :one_to_many and :one_to_one
  # :key :: foreign key in associated model's table that references
  #         current model's primary key, as a symbol.  Defaults to
  #         :"#{self.name.underscore}_id".  Can use an
  #         array of symbols for a composite key association.
  # :key_method :: the method symbol or array of method symbols to call on the associated
  #                object to get the foreign key values.  Defaults to :key option.
  # :primary_key :: column in the current table that :key option references, as a symbol.
  #                 Defaults to primary key of the current table. Can use an
  #                 array of symbols for a composite key association.
  # :primary_key_column :: Similar to, and usually identical to, :primary_key, but :primary_key refers
  #                        to the model method call, where :primary_key_column refers to the underlying column.
  #                        Should only be used if the model method differs from the primary key column, in
  #                        conjunction with defining a model alias method for the primary key column.
  # :raise_on_save_failure :: Do not raise exceptions for hook or validation failures when saving associated
  #                           objects in the add/remove methods (return nil instead) [one_to_many only].
  # === :many_to_many and :one_through_one
  # :graph_join_table_block :: The block to pass to +join_table+ for
  #                            the join table when eagerly loading the association via +eager_graph+.
  # :graph_join_table_conditions :: The additional conditions to use on the SQL join for
  #                                 the join table when eagerly loading the association via +eager_graph+.
  #                                 Should be a hash or an array of two element arrays.
  # :graph_join_table_join_type :: The type of SQL join to use for the join table when eagerly
  #                                loading the association via +eager_graph+.  Defaults to the
  #                                :graph_join_type option or :left_outer.
  # :graph_join_table_only_conditions :: The conditions to use on the SQL join for the join
  #                                      table when eagerly loading the association via +eager_graph+,
  #                                      instead of the default conditions specified by the
  #                                      foreign/primary keys.  This option causes the
  #                                      :graph_join_table_conditions option to be ignored.
  # :join_table :: name of table that includes the foreign keys to both
  #                the current model and the associated model, as a symbol.  Defaults to the name
  #                of current model and name of associated model, pluralized,
  #                underscored, sorted, and joined with '_'.
  # :join_table_block :: proc that can be used to modify the dataset used in the add/remove/remove_all
  #                      methods.  Should accept a dataset argument and return a modified dataset if present.
  # :join_table_db :: When retrieving records when using lazy loading or eager loading via +eager+, instead of
  #                   a join between to the join table and the associated table, use a separate query for the
  #                   join table using the given Database object.
  # :left_key :: foreign key in join table that points to current model's
  #              primary key, as a symbol. Defaults to :"#{self.name.underscore}_id".
  #              Can use an array of symbols for a composite key association.
  # :left_primary_key :: column in current table that :left_key points to, as a symbol.
  #                      Defaults to primary key of current table.  Can use an
  #                      array of symbols for a composite key association.
  # :left_primary_key_column :: Similar to, and usually identical to, :left_primary_key, but :left_primary_key refers to
  #                             the model method to call, where :left_primary_key_column refers to the underlying column.  Should only
  #                             be used if the model method differs from the left primary key column, in conjunction
  #                             with defining a model alias method for the left primary key column.
  # :right_key :: foreign key in join table that points to associated
  #               model's primary key, as a symbol.  Defaults to :"#{name.to_s.singularize}_id".
  #               Can use an array of symbols for a composite key association.
  # :right_primary_key :: column in associated table that :right_key points to, as a symbol.
  #                       Defaults to primary key of the associated table.  Can use an
  #                       array of symbols for a composite key association.
  # :right_primary_key_method :: the method symbol or array of method symbols to call on the associated
  #                              object to get the foreign key values for the join table.
  #                              Defaults to :right_primary_key option.
  # :uniq :: Adds a after_load callback that makes the array of objects unique.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#1849
  def associate(type, name, opts = T.unsafe(nil), &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def association_full_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def association_inner_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def association_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def association_left_join(*args, **_arg1, &block); end

  # The association reflection hash for the association of the given name.
  #
  # source://sequel//lib/sequel/model/associations.rb#1928
  def association_reflection(name); end

  # All association reflections defined for this model (default: {}).
  #
  # source://sequel//lib/sequel/model/associations.rb#1583
  def association_reflections; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def association_right_join(*args, **_arg1, &block); end

  # Array of association name symbols
  #
  # source://sequel//lib/sequel/model/associations.rb#1933
  def associations; end

  # Hash with column symbol keys and arrays of many_to_one
  # association symbols that should be cleared when the column
  # value changes.
  #
  # source://sequel//lib/sequel/model/associations.rb#1588
  def autoreloading_associations; end

  # Whether association metadata should be cached in the association reflection.  If not cached, it will be computed
  # on demand.  In general you only want to set this to false when using code reloading.  When using code reloading,
  # setting this will make sure that if an associated class is removed or modified, this class will not have a reference to
  # the previous class.
  #
  # source://sequel//lib/sequel/model/associations.rb#1594
  def cache_associations; end

  # Whether association metadata should be cached in the association reflection.  If not cached, it will be computed
  # on demand.  In general you only want to set this to false when using code reloading.  When using code reloading,
  # setting this will make sure that if an associated class is removed or modified, this class will not have a reference to
  # the previous class.
  #
  # source://sequel//lib/sequel/model/associations.rb#1594
  def cache_associations=(_arg0); end

  # The default options to use for all associations.  This hash is merged into the association reflection hash for
  # all association reflections.
  #
  # source://sequel//lib/sequel/model/associations.rb#1598
  def default_association_options; end

  # The default options to use for all associations.  This hash is merged into the association reflection hash for
  # all association reflections.
  #
  # source://sequel//lib/sequel/model/associations.rb#1598
  def default_association_options=(_arg0); end

  # The default options to use for all associations of a given type.  This is a hash keyed by association type
  # symbol.  If there is a value for the association type symbol key, the resulting hash will be merged into the
  # association reflection hash for all association reflections of that type.
  #
  # source://sequel//lib/sequel/model/associations.rb#1603
  def default_association_type_options; end

  # The default options to use for all associations of a given type.  This is a hash keyed by association type
  # symbol.  If there is a value for the association type symbol key, the resulting hash will be merged into the
  # association reflection hash for all association reflections of that type.
  #
  # source://sequel//lib/sequel/model/associations.rb#1603
  def default_association_type_options=(_arg0); end

  # The default :eager_limit_strategy option to use for limited or offset associations (default: true, causing Sequel
  # to use what it considers the most appropriate strategy).
  #
  # source://sequel//lib/sequel/model/associations.rb#1607
  def default_eager_limit_strategy; end

  # The default :eager_limit_strategy option to use for limited or offset associations (default: true, causing Sequel
  # to use what it considers the most appropriate strategy).
  #
  # source://sequel//lib/sequel/model/associations.rb#1607
  def default_eager_limit_strategy=(_arg0); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def eager(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def eager_graph(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def eager_graph_with_options(*args, **_arg1, &block); end

  # Eager load the association with the given eager loader options.
  #
  # source://sequel//lib/sequel/model/associations.rb#1938
  def eager_load_results(opts, eo, &block); end

  # Finalize all associations such that values that are looked up
  # dynamically in associated classes are set statically.
  # As this modifies the associations, it must be done before
  # calling freeze.
  #
  # source://sequel//lib/sequel/model/associations.rb#1957
  def finalize_associations; end

  # Freeze association related metadata when freezing model class.
  #
  # source://sequel//lib/sequel/model/associations.rb#1943
  def freeze; end

  # Shortcut for adding a many_to_many association, see #associate
  #
  # source://sequel//lib/sequel/model/associations.rb#1962
  def many_to_many(name, opts = T.unsafe(nil), &block); end

  # Shortcut for adding a many_to_one association, see #associate
  #
  # source://sequel//lib/sequel/model/associations.rb#1967
  def many_to_one(name, opts = T.unsafe(nil), &block); end

  # Shortcut for adding a one_through_one association, see #associate
  #
  # source://sequel//lib/sequel/model/associations.rb#1972
  def one_through_one(name, opts = T.unsafe(nil), &block); end

  # Shortcut for adding a one_to_many association, see #associate
  #
  # source://sequel//lib/sequel/model/associations.rb#1977
  def one_to_many(name, opts = T.unsafe(nil), &block); end

  # Shortcut for adding a one_to_one association, see #associate
  #
  # source://sequel//lib/sequel/model/associations.rb#1982
  def one_to_one(name, opts = T.unsafe(nil), &block); end

  private

  # The default value for the instance_specific option, if the association
  # could be instance specific and the :instance_specific option is not specified.
  #
  # source://sequel//lib/sequel/model/associations.rb#1993
  def _association_instance_specific_default(_); end

  # The module to use for the association's methods.  Defaults to
  # the overridable_methods_module.
  #
  # source://sequel//lib/sequel/model/associations.rb#1999
  def association_module(opts = T.unsafe(nil)); end

  # Add a method to the module included in the class, so the method
  # can be easily overridden in the class itself while allowing for
  # super to be called.
  #
  # source://sequel//lib/sequel/model/associations.rb#2006
  def association_module_def(name, opts = T.unsafe(nil), &block); end

  # Add a method to the module included in the class, so the method
  # can be easily overridden in the class itself while allowing for
  # super to be called.  This method allows passing keywords through
  # the defined methods.
  #
  # source://sequel//lib/sequel/model/associations.rb#2016
  def association_module_delegate_def(name, opts, &block); end

  # Add a private method to the module included in the class.
  #
  # source://sequel//lib/sequel/model/associations.rb#2026
  def association_module_private_def(name, opts = T.unsafe(nil), &block); end

  # Delegate to the type-specific association method to setup the
  # association, and define the association instance methods.
  #
  # source://sequel//lib/sequel/model/associations.rb#2033
  def def_association(opts); end

  # Define all of the association instance methods for this association.
  #
  # source://sequel//lib/sequel/model/associations.rb#2046
  def def_association_instance_methods(opts); end

  # Adds the association method to the association methods module.
  #
  # source://sequel//lib/sequel/model/associations.rb#2039
  def def_association_method(opts); end

  # Configures many_to_many and one_through_one association reflection and adds the related association methods
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2096
  def def_many_to_many(opts); end

  # Configures many_to_one association reflection and adds the related association methods
  #
  # source://sequel//lib/sequel/model/associations.rb#2283
  def def_many_to_one(opts); end

  # Alias of def_many_to_many, since they share pretty much the same code.
  #
  # source://sequel//lib/sequel/model/associations.rb#2464
  def def_one_through_one(opts); end

  # Configures one_to_many and one_to_one association reflections and adds the related association methods
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2343
  def def_one_to_many(opts); end

  # Alias of def_one_to_many, since they share pretty much the same code.
  #
  # source://sequel//lib/sequel/model/associations.rb#2469
  def def_one_to_one(opts); end

  # Return dataset to graph into given the association reflection, applying the :callback option if set.
  #
  # source://sequel//lib/sequel/model/associations.rb#2474
  def eager_graph_dataset(opts, eager_options); end

  # source://sequel//lib/sequel/model/plugins.rb#43
  def inherited_instance_variables; end

  # If not caching associations, reload the database schema by default,
  # ignoring any cached values.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#2487
  def reload_db_schema?; end
end

# Eager loading makes it so that you can load all associated records for a
# set of objects in a single query, instead of a separate query for each object.
#
# Two separate implementations are provided.  +eager+ should be used most of the
# time, as it loads associated records using one query per association.  However,
# it does not allow you the ability to filter or order based on columns in associated tables.  +eager_graph+ loads
# all records in a single query using JOINs, allowing you to filter or order based on columns in associated
# tables.  However, +eager_graph+ is usually slower than +eager+, especially if multiple
# one_to_many or many_to_many associations are joined.
#
# You can cascade the eager loading (loading associations on associated objects)
# with no limit to the depth of the cascades.  You do this by passing a hash to +eager+ or +eager_graph+
# with the keys being associations of the current model and values being
# associations of the model associated with the current model via the key.
#
# The arguments can be symbols or hashes with symbol keys (for cascaded
# eager loading). Examples:
#
#   Album.eager(:artist).all
#   Album.eager_graph(:artist).all
#   Album.eager(:artist, :genre).all
#   Album.eager_graph(:artist, :genre).all
#   Album.eager(:artist).eager(:genre).all
#   Album.eager_graph(:artist).eager_graph(:genre).all
#   Artist.eager(albums: :tracks).all
#   Artist.eager_graph(albums: :tracks).all
#   Artist.eager(albums: {tracks: :genre}).all
#   Artist.eager_graph(albums: {tracks: :genre}).all
#
# You can also pass a callback as a hash value in order to customize the dataset being
# eager loaded at query time, analogous to the way the :eager_block association option
# allows you to customize it at association definition time. For example,
# if you wanted artists with their albums since 1990:
#
#   Artist.eager(albums: proc{|ds| ds.where{year > 1990}})
#
# Or if you needed albums and their artist's name only, using a single query:
#
#   Albums.eager_graph(artist: proc{|ds| ds.select(:name)})
#
# To cascade eager loading while using a callback, you substitute the cascaded
# associations with a single entry hash that has the proc callback as the key and
# the cascaded associations as the value.  This will load artists with their albums
# since 1990, and also the tracks on those albums and the genre for those tracks:
#
#   Artist.eager(albums: {proc{|ds| ds.where{year > 1990}}=>{tracks: :genre}})
#
# source://sequel//lib/sequel/model/associations.rb#2942
module Sequel::Model::Associations::DatasetMethods
  # If the dataset is being eagerly loaded, default to calling all
  # instead of each.
  #
  # source://sequel//lib/sequel/model/associations.rb#3319
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/model/associations.rb#2945
  def association_full_join(*associations); end

  # source://sequel//lib/sequel/model/associations.rb#2945
  def association_inner_join(*associations); end

  # Adds one or more INNER JOINs to the existing dataset using the keys and conditions
  # specified by the given association(s).  Take the same arguments as eager_graph, and
  # operates similarly, but only adds the joins as opposed to making the other changes
  # (such as adding selected columns and setting up eager loading).
  #
  # The following methods also exist for specifying a different type of JOIN:
  #
  # association_full_join :: FULL JOIN
  # association_inner_join :: INNER JOIN
  # association_left_join :: LEFT JOIN
  # association_right_join :: RIGHT JOIN
  #
  # Examples:
  #
  #   # For each album, association_join load the artist
  #   Album.association_join(:artist).all
  #   # SELECT *
  #   # FROM albums
  #   # INNER JOIN artists AS artist ON (artists.id = albums.artist_id)
  #
  #   # For each album, association_join load the artist, using a specified alias
  #   Album.association_join(Sequel[:artist].as(:a)).all
  #   # SELECT *
  #   # FROM albums
  #   # INNER JOIN artists AS a ON (a.id = albums.artist_id)
  #
  #   # For each album, association_join load the artist and genre
  #   Album.association_join(:artist, :genre).all
  #   Album.association_join(:artist).association_join(:genre).all
  #   # SELECT *
  #   # FROM albums
  #   # INNER JOIN artists AS artist ON (artist.id = albums.artist_id)
  #   # INNER JOIN genres AS genre ON (genre.id = albums.genre_id)
  #
  #   # For each artist, association_join load albums and tracks for each album
  #   Artist.association_join(albums: :tracks).all
  #   # SELECT *
  #   # FROM artists
  #   # INNER JOIN albums ON (albums.artist_id = artists.id)
  #   # INNER JOIN tracks ON (tracks.album_id = albums.id)
  #
  #   # For each artist, association_join load albums, tracks for each album, and genre for each track
  #   Artist.association_join(albums: {tracks: :genre}).all
  #   # SELECT *
  #   # FROM artists
  #   # INNER JOIN albums ON (albums.artist_id = artists.id)
  #   # INNER JOIN tracks ON (tracks.album_id = albums.id)
  #   # INNER JOIN genres AS genre ON (genre.id = tracks.genre_id)
  #
  #   # For each artist, association_join load albums with year > 1990
  #   Artist.association_join(albums: proc{|ds| ds.where{year > 1990}}).all
  #   # SELECT *
  #   # FROM artists
  #   # INNER JOIN (
  #   #   SELECT * FROM albums WHERE (year > 1990)
  #   # ) AS albums ON (albums.artist_id = artists.id)
  #
  #   # For each artist, association_join load albums and tracks 1-10 for each album
  #   Artist.association_join(albums: {tracks: proc{|ds| ds.where(number: 1..10)}}).all
  #   # SELECT *
  #   # FROM artists
  #   # INNER JOIN albums ON (albums.artist_id = artists.id)
  #   # INNER JOIN (
  #   #   SELECT * FROM tracks WHERE ((number >= 1) AND (number <= 10))
  #   # ) AS tracks ON (tracks.albums_id = albums.id)
  #
  #   # For each artist, association_join load albums with year > 1990, and tracks for those albums
  #   Artist.association_join(albums: {proc{|ds| ds.where{year > 1990}}=>:tracks}).all
  #   # SELECT *
  #   # FROM artists
  #   # INNER JOIN (
  #   #   SELECT * FROM albums WHERE (year > 1990)
  #   # ) AS albums ON (albums.artist_id = artists.id)
  #   # INNER JOIN tracks ON (tracks.album_id = albums.id)
  #
  # source://sequel//lib/sequel/model/associations.rb#3025
  def association_join(*associations); end

  # source://sequel//lib/sequel/model/associations.rb#2945
  def association_left_join(*associations); end

  # source://sequel//lib/sequel/model/associations.rb#2945
  def association_right_join(*associations); end

  # If the expression is in the form <tt>x = y</tt> where +y+ is a <tt>Sequel::Model</tt>
  # instance, array of <tt>Sequel::Model</tt> instances, or a <tt>Sequel::Model</tt> dataset,
  # assume +x+ is an association symbol and look up the association reflection
  # via the dataset's model.  From there, return the appropriate SQL based on the type of
  # association and the values of the foreign/primary keys of +y+.  For most association
  # types, this is a simple transformation, but for +many_to_many+ associations this
  # creates a subquery to the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#3036
  def complex_expression_sql_append(sql, op, args); end

  # The preferred eager loading method.  Loads all associated records using one
  # query for each association.
  #
  # The basic idea for how it works is that the dataset is first loaded normally.
  # Then it goes through all associations that have been specified via +eager+.
  # It loads each of those associations separately, then associates them back
  # to the original dataset via primary/foreign keys.  Due to the necessity of
  # all objects being present, you need to use +all+ to use eager loading, as it
  # can't work with +each+.
  #
  # This implementation avoids the complexity of extracting an object graph out
  # of a single dataset, by building the object graph out of multiple datasets,
  # one for each association.  By using a separate dataset for each association,
  # it avoids problems such as aliasing conflicts and creating cartesian product
  # result sets if multiple one_to_many or many_to_many eager associations are requested.
  #
  # One limitation of using this method is that you cannot filter the current dataset
  # based on values of columns in an associated table, since the associations are loaded
  # in separate queries.  To do that you need to load all associations in the
  # same query, and extract an object graph from the results of that query. If you
  # need to filter based on columns in associated tables, look at +eager_graph+
  # or join the tables you need to filter on manually.
  #
  # Each association's order, if defined, is respected.
  # If the association uses a block or has an :eager_block argument, it is used.
  #
  # To modify the associated dataset that will be used for the eager load, you should use a
  # hash for the association, with the key being the association name symbol, and the value being
  # a callable object that is called with the associated dataset and should return a modified
  # dataset.  If that association also has dependent associations, instead of a callable object,
  # use a hash with the callable object being the key, and the dependent association(s) as the value.
  #
  # Examples:
  #
  #   # For each album, eager load the artist
  #   Album.eager(:artist).all
  #   # SELECT * FROM albums
  #   # SELECT * FROM artists WHERE (id IN (...))
  #
  #   # For each album, eager load the artist and genre
  #   Album.eager(:artist, :genre).all
  #   Album.eager(:artist).eager(:genre).all
  #   # SELECT * FROM albums
  #   # SELECT * FROM artists WHERE (id IN (...))
  #   # SELECT * FROM genres WHERE (id IN (...))
  #
  #   # For each artist, eager load albums and tracks for each album
  #   Artist.eager(albums: :tracks).all
  #   # SELECT * FROM artists
  #   # SELECT * FROM albums WHERE (artist_id IN (...))
  #   # SELECT * FROM tracks WHERE (album_id IN (...))
  #
  #   # For each artist, eager load albums, tracks for each album, and genre for each track
  #   Artist.eager(albums: {tracks: :genre}).all
  #   # SELECT * FROM artists
  #   # SELECT * FROM albums WHERE (artist_id IN (...))
  #   # SELECT * FROM tracks WHERE (album_id IN (...))
  #   # SELECT * FROM genre WHERE (id IN (...))
  #
  #   # For each artist, eager load albums with year > 1990
  #   Artist.eager(albums: proc{|ds| ds.where{year > 1990}}).all
  #   # SELECT * FROM artists
  #   # SELECT * FROM albums WHERE ((year > 1990) AND (artist_id IN (...)))
  #
  #   # For each artist, eager load albums and tracks 1-10 for each album
  #   Artist.eager(albums: {tracks: proc{|ds| ds.where(number: 1..10)}}).all
  #   # SELECT * FROM artists
  #   # SELECT * FROM albums WHERE (artist_id IN (...))
  #   # SELECT * FROM tracks WHERE ((number >= 1) AND (number <= 10) AND (album_id IN (...)))
  #
  #   # For each artist, eager load albums with year > 1990, and tracks for those albums
  #   Artist.eager(albums: {proc{|ds| ds.where{year > 1990}}=>:tracks}).all
  #   # SELECT * FROM artists
  #   # SELECT * FROM albums WHERE ((year > 1990) AND (artist_id IN (...)))
  #   # SELECT * FROM albums WHERE (artist_id IN (...))
  #
  # source://sequel//lib/sequel/model/associations.rb#3156
  def eager(*associations); end

  # The secondary eager loading method.  Loads all associations in a single query. This
  # method should only be used if you need to filter or order based on columns in associated tables,
  # or if you have done comparative benchmarking and determined it is faster.
  #
  # This method uses <tt>Dataset#graph</tt> to create appropriate aliases for columns in all the
  # tables.  Then it uses the graph's metadata to build the associations from the single hash, and
  # finally replaces the array of hashes with an array model objects inside all.
  #
  # Be very careful when using this with multiple one_to_many or many_to_many associations, as you can
  # create large cartesian products.  If you must graph multiple one_to_many and many_to_many associations,
  # make sure your filters are narrow if the datasets are large.
  #
  # Each association's order, if defined, is respected. +eager_graph+ probably
  # won't work correctly on a limited dataset, unless you are
  # only graphing many_to_one, one_to_one, and one_through_one associations.
  #
  # Does not use the block defined for the association, since it does a single query for
  # all objects.  You can use the :graph_* association options to modify the SQL query.
  #
  # Like +eager+, you need to call +all+ on the dataset for the eager loading to work.  If you just
  # call +each+, it will yield plain hashes, each containing all columns from all the tables.
  #
  # To modify the associated dataset that will be joined to the current dataset, you should use a
  # hash for the association, with the key being the association name symbol, and the value being
  # a callable object that is called with the associated dataset and should return a modified
  # dataset.  If that association also has dependent associations, instead of a callable object,
  # use a hash with the callable object being the key, and the dependent association(s) as the value.
  #
  # You can specify an custom alias and/or join type on a per-association basis by providing an
  # Sequel::SQL::AliasedExpression object instead of an a Symbol for the association name.
  #
  # You cannot mix calls to +eager_graph+ and +graph+ on the same dataset.
  #
  # Examples:
  #
  #   # For each album, eager_graph load the artist
  #   Album.eager_graph(:artist).all
  #   # SELECT ...
  #   # FROM albums
  #   # LEFT OUTER JOIN artists AS artist ON (artists.id = albums.artist_id)
  #
  #   # For each album, eager_graph load the artist, using a specified alias
  #   Album.eager_graph(Sequel[:artist].as(:a)).all
  #   # SELECT ...
  #   # FROM albums
  #   # LEFT OUTER JOIN artists AS a ON (a.id = albums.artist_id)
  #
  #   # For each album, eager_graph load the artist, using a specified alias
  #   # and custom join type
  #
  #   Album.eager_graph(Sequel[:artist].as(:a, join_type: :inner)).all
  #   # SELECT ...
  #   # FROM albums
  #   # INNER JOIN artists AS a ON (a.id = albums.artist_id)
  #
  #   # For each album, eager_graph load the artist and genre
  #   Album.eager_graph(:artist, :genre).all
  #   Album.eager_graph(:artist).eager_graph(:genre).all
  #   # SELECT ...
  #   # FROM albums
  #   # LEFT OUTER JOIN artists AS artist ON (artist.id = albums.artist_id)
  #   # LEFT OUTER JOIN genres AS genre ON (genre.id = albums.genre_id)
  #
  #   # For each artist, eager_graph load albums and tracks for each album
  #   Artist.eager_graph(albums: :tracks).all
  #   # SELECT ...
  #   # FROM artists
  #   # LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)
  #   # LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)
  #
  #   # For each artist, eager_graph load albums, tracks for each album, and genre for each track
  #   Artist.eager_graph(albums: {tracks: :genre}).all
  #   # SELECT ...
  #   # FROM artists
  #   # LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)
  #   # LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)
  #   # LEFT OUTER JOIN genres AS genre ON (genre.id = tracks.genre_id)
  #
  #   # For each artist, eager_graph load albums with year > 1990
  #   Artist.eager_graph(albums: proc{|ds| ds.where{year > 1990}}).all
  #   # SELECT ...
  #   # FROM artists
  #   # LEFT OUTER JOIN (
  #   #   SELECT * FROM albums WHERE (year > 1990)
  #   # ) AS albums ON (albums.artist_id = artists.id)
  #
  #   # For each artist, eager_graph load albums and tracks 1-10 for each album
  #   Artist.eager_graph(albums: {tracks: proc{|ds| ds.where(number: 1..10)}}).all
  #   # SELECT ...
  #   # FROM artists
  #   # LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)
  #   # LEFT OUTER JOIN (
  #   #   SELECT * FROM tracks WHERE ((number >= 1) AND (number <= 10))
  #   # ) AS tracks ON (tracks.albums_id = albums.id)
  #
  #   # For each artist, eager_graph load albums with year > 1990, and tracks for those albums
  #   Artist.eager_graph(albums: {proc{|ds| ds.where{year > 1990}}=>:tracks}).all
  #   # SELECT ...
  #   # FROM artists
  #   # LEFT OUTER JOIN (
  #   #   SELECT * FROM albums WHERE (year > 1990)
  #   # ) AS albums ON (albums.artist_id = artists.id)
  #   # LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)
  #
  # source://sequel//lib/sequel/model/associations.rb#3266
  def eager_graph(*associations); end

  # Run eager_graph with some options specific to just this call. Unlike eager_graph, this takes
  # the associations as a single argument instead of multiple arguments.
  #
  # Options:
  #
  # :join_type :: Override the join type specified in the association
  # :limit_strategy :: Use a strategy for handling limits on associations.
  #                    Appropriate :limit_strategy values are:
  #                    true :: Pick the most appropriate based on what the database supports
  #                    :distinct_on :: Force use of DISTINCT ON stategy (*_one associations only)
  #                    :correlated_subquery :: Force use of correlated subquery strategy (one_to_* associations only)
  #                    :window_function :: Force use of window function strategy
  #                    :ruby :: Don't modify the SQL, implement limits/offsets with array slicing
  #
  #                    This can also be a hash with association name symbol keys and one of the above values,
  #                    to use different strategies per association.
  #
  #                    The default is the :ruby strategy.  Choosing a different strategy can make your code
  #                    significantly slower in some cases (perhaps even the majority of cases), so you should
  #                    only use this if you have benchmarked that it is faster for your use cases.
  #
  # source://sequel//lib/sequel/model/associations.rb#3290
  def eager_graph_with_options(associations, opts = T.unsafe(nil)); end

  # If the dataset is being eagerly loaded, default to calling all
  # instead of each.
  #
  # source://sequel//lib/sequel/model/associations.rb#3329
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Do not attempt to split the result set into associations,
  # just return results as simple objects.  This is useful if you
  # want to use eager_graph as a shortcut to have all of the joins
  # and aliasing set up, but want to do something else with the dataset.
  #
  # source://sequel//lib/sequel/model/associations.rb#3341
  def ungraphed; end

  protected

  # Call graph on the association with the correct arguments,
  # update the eager_graph data structure, and recurse into
  # eager_graph_associations if there are any passed in associations
  # (which would be dependencies of the current association)
  #
  # Arguments:
  # ds :: Current dataset
  # model :: Current Model
  # ta :: table_alias used for the parent association
  # requirements :: an array, used as a stack for requirements
  # r :: association reflection for the current association, or an SQL::AliasedExpression
  #      with the reflection as the expression, the alias base as the alias (or nil to
  #      use the default alias), and an optional hash with a :join_type entry as the columns
  #      to use a custom join type.
  # *associations :: any associations dependent on this one
  #
  # source://sequel//lib/sequel/model/associations.rb#3366
  def eager_graph_association(ds, model, ta, requirements, r, *associations); end

  # Check the associations are valid for the given model.
  # Call eager_graph_association on each association.
  #
  # Arguments:
  # ds :: Current dataset
  # model :: Current Model
  # ta :: table_alias used for the parent association
  # requirements :: an array, used as a stack for requirements
  # *associations :: the associations to add to the graph
  #
  # source://sequel//lib/sequel/model/associations.rb#3418
  def eager_graph_associations(ds, model, ta, requirements, *associations); end

  # Replace the array of plain hashes with an array of model objects will all eager_graphed
  # associations set in the associations cache for each object.
  #
  # source://sequel//lib/sequel/model/associations.rb#3437
  def eager_graph_build_associations(hashes); end

  private

  # Return a new dataset with JOINs of the given type added, using the tables and
  # conditions specified by the associations.
  #
  # source://sequel//lib/sequel/model/associations.rb#3445
  def _association_join(type, associations); end

  # Process the array of hashes using the eager graph loader to return an array
  # of model objects with the associations set.
  #
  # source://sequel//lib/sequel/model/associations.rb#3451
  def _eager_graph_build_associations(hashes, egl); end

  # If the association has conditions itself, then it requires additional filters be
  # added to the current dataset to ensure that the passed in object would also be
  # included by the association's conditions.
  #
  # source://sequel//lib/sequel/model/associations.rb#3458
  def add_association_filter_conditions(ref, obj, expr); end

  # Return an expression for filtering by the given association reflection and associated object.
  #
  # source://sequel//lib/sequel/model/associations.rb#3486
  def association_filter_expression(op, ref, obj); end

  # Handle inversion for association filters by returning an inverted expression,
  # plus also handling cases where the referenced columns are NULL.
  #
  # source://sequel//lib/sequel/model/associations.rb#3494
  def association_filter_handle_inversion(op, exp, cols); end

  # Return an expression for making sure that the given keys match the value of
  # the given methods for either the single object given or for any of the objects
  # given if +obj+ is an array.
  #
  # source://sequel//lib/sequel/model/associations.rb#3509
  def association_filter_key_expression(keys, meths, obj); end

  # Make sure the association is valid for this model, and return the related AssociationReflection.
  #
  # @raise [Sequel::UndefinedAssociation]
  #
  # source://sequel//lib/sequel/model/associations.rb#3530
  def check_association(model, association); end

  # Allow associations that are eagerly graphed to be specified as an SQL::AliasedExpression, for
  # per-call determining of the alias base.
  #
  # source://sequel//lib/sequel/model/associations.rb#3538
  def eager_graph_check_association(model, association); end

  # The EagerGraphLoader instance used for converting eager_graph results.
  #
  # source://sequel//lib/sequel/model/associations.rb#3562
  def eager_graph_loader; end

  # Eagerly load all specified associations.
  #
  # source://sequel//lib/sequel/model/associations.rb#3570
  def eager_load(a, eager_assoc = T.unsafe(nil), m = T.unsafe(nil)); end

  # Process the array of associations arguments (Symbols, Arrays, and Hashes),
  # and return a hash of options suitable for cascading.
  #
  # source://sequel//lib/sequel/model/associations.rb#3468
  def eager_options_for_associations(associations); end

  # Return a subquery expression for filering by a many_to_many association
  #
  # source://sequel//lib/sequel/model/associations.rb#3650
  def many_to_many_association_filter_expression(op, ref, obj); end

  # Return a simple equality expression for filering by a many_to_one association
  #
  # source://sequel//lib/sequel/model/associations.rb#3673
  def many_to_one_association_filter_expression(op, ref, obj); end

  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#3701
  def non_sql_option?(key); end

  # Return a subquery expression for filering by a many_to_many association
  #
  # source://sequel//lib/sequel/model/associations.rb#3650
  def one_through_one_association_filter_expression(op, ref, obj); end

  # Return a simple equality expression for filering by a one_to_* association
  #
  # source://sequel//lib/sequel/model/associations.rb#3687
  def one_to_many_association_filter_expression(op, ref, obj); end

  # Return a simple equality expression for filering by a one_to_* association
  #
  # source://sequel//lib/sequel/model/associations.rb#3687
  def one_to_one_association_filter_expression(op, ref, obj); end

  # Perform eager loading for a single association using the loader and eager options.
  #
  # source://sequel//lib/sequel/model/associations.rb#3645
  def perform_eager_load(loader, eo); end

  # Using the hash of loaders and eager options, perform the eager loading.
  #
  # source://sequel//lib/sequel/model/associations.rb#3638
  def perform_eager_loads(eager_load_data); end

  # Build associations from the graph if #eager_graph was used,
  # and/or load other associations if #eager was used.
  #
  # source://sequel//lib/sequel/model/associations.rb#3707
  def post_load(all_records); end

  # Prepare a hash loaders and eager options which will be used to implement the eager loading.
  #
  # source://sequel//lib/sequel/model/associations.rb#3586
  def prepare_eager_load(a, reflections, eager_assoc); end
end

# The dataset module to use for classes using the associations plugin.
#
# source://sequel//lib/sequel/model/associations.rb#25
class Sequel::Model::Associations::DatasetModule < ::Sequel::Model::DatasetModule
  # source://sequel//lib/sequel/dataset/dataset_module.rb#29
  def eager(name, *args, &block); end
end

# This class is the internal implementation of eager_graph.  It is responsible for taking an array of plain
# hashes and returning an array of model objects with all eager_graphed associations already set in the
# association cache.
#
# source://sequel//lib/sequel/model/associations.rb#3717
class Sequel::Model::Associations::EagerGraphLoader
  # Initialize all of the data structures used during loading.
  #
  # @return [EagerGraphLoader] a new instance of EagerGraphLoader
  #
  # source://sequel//lib/sequel/model/associations.rb#3761
  def initialize(dataset); end

  # Hash with table alias symbol keys and after_load hook values
  #
  # source://sequel//lib/sequel/model/associations.rb#3719
  def after_load_map; end

  # Hash with table alias symbol keys and association name values
  #
  # source://sequel//lib/sequel/model/associations.rb#3722
  def alias_map; end

  # Hash with table alias symbol keys and subhash values mapping column_alias symbols to the
  # symbol of the real name of the column
  #
  # source://sequel//lib/sequel/model/associations.rb#3726
  def column_maps; end

  # Recursive hash with table alias symbol keys mapping to hashes with dependent table alias symbol keys.
  #
  # source://sequel//lib/sequel/model/associations.rb#3729
  def dependency_map; end

  # Hash with table alias symbol keys and [limit, offset] values
  #
  # source://sequel//lib/sequel/model/associations.rb#3732
  def limit_map; end

  # Return an array of primary model instances with the associations cache prepopulated
  # for all model objects (both primary and associated).
  #
  # source://sequel//lib/sequel/model/associations.rb#3861
  def load(hashes); end

  # The table alias symbol for the primary model
  #
  # source://sequel//lib/sequel/model/associations.rb#3735
  def master; end

  # Hash with table alias symbol keys and primary key symbol values (or arrays of primary key symbols for
  # composite key tables)
  #
  # source://sequel//lib/sequel/model/associations.rb#3739
  def primary_keys; end

  # Hash with table alias symbol keys and reciprocal association symbol values,
  # used for setting reciprocals for one_to_many associations.
  #
  # source://sequel//lib/sequel/model/associations.rb#3743
  def reciprocal_map; end

  # Hash with table alias symbol keys and subhash values mapping primary key symbols (or array of symbols)
  # to model instances.  Used so that only a single model instance is created for each object.
  #
  # source://sequel//lib/sequel/model/associations.rb#3747
  def records_map; end

  # Hash with table alias symbol keys and AssociationReflection values
  #
  # source://sequel//lib/sequel/model/associations.rb#3750
  def reflection_map; end

  # Hash with table alias symbol keys and callable values used to create model instances
  #
  # source://sequel//lib/sequel/model/associations.rb#3753
  def row_procs; end

  # Hash with table alias symbol keys and true/false values, where true means the
  # association represented by the table alias uses an array of values instead of
  # a single value (i.e. true => *_many, false => *_to_one).
  #
  # source://sequel//lib/sequel/model/associations.rb#3758
  def type_map; end

  private

  # Recursive method that creates associated model objects and associates them to the current model object.
  #
  # source://sequel//lib/sequel/model/associations.rb#3910
  def _load(dependency_map, current, h); end

  # Return the subhash for the specific table alias +ta+ by parsing the values out of the main hash +h+
  #
  # source://sequel//lib/sequel/model/associations.rb#3953
  def hfor(ta, h); end

  # Return a suitable hash key for any subhash +h+, which is an array of values by column order.
  # This is only used if the primary key cannot be used.
  #
  # source://sequel//lib/sequel/model/associations.rb#3961
  def hkey(h); end

  # Return the subhash for the master table by parsing the values out of the main hash +h+
  #
  # source://sequel//lib/sequel/model/associations.rb#3966
  def master_hfor(h); end

  # Return a primary key value for the master table by parsing it out of the main hash +h+.
  #
  # source://sequel//lib/sequel/model/associations.rb#3973
  def master_pk(h); end

  # Return a primary key value for the given table alias by parsing it out of the main hash +h+.
  #
  # source://sequel//lib/sequel/model/associations.rb#3986
  def pk(ta, h); end

  # If the result set is the result of a cartesian product, then it is possible that
  # there are multiple records for each association when there should only be one.
  # In that case, for each object in all associations loaded via +eager_graph+, run
  # uniq! on the association to make sure no duplicate records show up.
  # Note that this can cause legitimate duplicate records to be removed.
  #
  # source://sequel//lib/sequel/model/associations.rb#4003
  def post_process(records, dependency_map); end
end

# Instance methods used to implement the associations support.
#
# source://sequel//lib/sequel/model/associations.rb#2493
module Sequel::Model::Associations::InstanceMethods
  # The currently cached associations.  A hash with the keys being the
  # association name symbols and the values being the associated object
  # or nil (many_to_one), or the array of associated objects (*_to_many).
  #
  # source://sequel//lib/sequel/model/associations.rb#2497
  def associations; end

  # Freeze the associations cache when freezing the object.  Note that
  # retrieving associations after freezing will still work in most cases,
  # but the associations will not be cached in the association cache.
  #
  # source://sequel//lib/sequel/model/associations.rb#2504
  def freeze; end

  private

  # Apply the association options such as :order and :limit to the given dataset, returning a modified dataset.
  #
  # source://sequel//lib/sequel/model/associations.rb#2514
  def _apply_association_options(opts, ds); end

  # Return a dataset for the association after applying any dynamic callback.
  #
  # source://sequel//lib/sequel/model/associations.rb#2526
  def _associated_dataset(opts, dynamic_opts); end

  # A placeholder literalizer that can be used to load the association, or nil to not use one.
  #
  # source://sequel//lib/sequel/model/associations.rb#2535
  def _associated_object_loader(opts, dynamic_opts); end

  # Return an association dataset for the given association reflection
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2542
  def _dataset(opts); end

  # Dataset for the join table of the given many to many association reflection
  #
  # source://sequel//lib/sequel/model/associations.rb#2554
  def _join_table_dataset(opts); end

  # Return the associated single object for the given association reflection and dynamic options
  # (or nil if no associated object).
  #
  # source://sequel//lib/sequel/model/associations.rb#2561
  def _load_associated_object(opts, dynamic_opts); end

  # Load the associated objects for the given association reflection and dynamic options
  # as an array.
  #
  # source://sequel//lib/sequel/model/associations.rb#2572
  def _load_associated_object_array(opts, dynamic_opts); end

  # Return the associated single object using a primary key lookup on the associated class.
  #
  # source://sequel//lib/sequel/model/associations.rb#2566
  def _load_associated_object_via_primary_key(opts); end

  # Return the associated objects from the dataset, without association callbacks, reciprocals, and caching.
  # Still apply the dynamic callback if present.
  #
  # source://sequel//lib/sequel/model/associations.rb#2587
  def _load_associated_objects(opts, dynamic_opts = T.unsafe(nil)); end

  # Clear the associations cache when refreshing
  #
  # source://sequel//lib/sequel/model/associations.rb#2602
  def _refresh_set_values(hash); end

  # Set the given object as the associated object for the given *_to_one association reflection
  #
  # source://sequel//lib/sequel/model/associations.rb#2844
  def _set_associated_object(opts, o); end

  # Add the given associated object to the given association
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2608
  def add_associated_object(opts, o, *args, **_arg3); end

  # Add/Set the current object to/as the given object's reciprocal association.
  #
  # source://sequel//lib/sequel/model/associations.rb#2627
  def add_reciprocal_object(opts, o); end

  # Call uniq! on the given array. This is used by the :uniq option,
  # and is an actual method for memory reasons.
  #
  # source://sequel//lib/sequel/model/associations.rb#2641
  def array_uniq!(a); end

  # If a foreign key column value changes, clear the related
  # cached associations.
  #
  # source://sequel//lib/sequel/model/associations.rb#2647
  def change_column_value(column, value); end

  # Save the associated object if the associated object needs a primary key
  # and the associated object is new and does not have one.  Raise an error if
  # the object still does not have a primary key
  #
  # source://sequel//lib/sequel/model/associations.rb#2682
  def ensure_associated_primary_key(opts, o, *args); end

  # Duplicate the associations hash when duplicating the object.
  #
  # source://sequel//lib/sequel/model/associations.rb#2690
  def initialize_copy(other); end

  # Load the associated objects using the dataset, handling callbacks, reciprocals, and caching.
  #
  # source://sequel//lib/sequel/model/associations.rb#2707
  def load_associated_objects(opts, dynamic_opts, &block); end

  # If a block is given, assign it as the :callback option in the hash, and return the hash.
  #
  # source://sequel//lib/sequel/model/associations.rb#2697
  def load_association_objects_options(dynamic_opts, &block); end

  # Whether to use a simple primary key lookup on the associated class when loading.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#2733
  def load_with_primary_key_lookup?(opts, dynamic_opts); end

  # Convert the input of the add_* association method into an associated object. For
  # hashes, this creates a new object using the hash.  For integers, strings, and arrays,
  # assume the value specifies a primary key, and lookup an existing object with that primary key.
  # Otherwise, if the object is not already an instance of the class, raise an exception.
  #
  # source://sequel//lib/sequel/model/associations.rb#2743
  def make_add_associated_object(opts, o); end

  # Remove all associated objects from the given association
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2759
  def remove_all_associated_objects(opts, *args, **_arg2); end

  # Remove the given associated object from the given association
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2772
  def remove_associated_object(opts, o, *args, **_arg3); end

  # Check that the object from the associated table specified by the primary key
  # is currently associated to the receiver.  If it is associated, return the object, otherwise
  # raise an error.
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2798
  def remove_check_existing_object_from_pk(opts, o, *args); end

  # Remove/unset the current object from/as the given object's reciprocal association.
  #
  # source://sequel//lib/sequel/model/associations.rb#2806
  def remove_reciprocal_object(opts, o); end

  # Run the callback for the association with the object.
  #
  # source://sequel//lib/sequel/model/associations.rb#2818
  def run_association_callbacks(reflection, callback_type, object); end

  # Set the given object as the associated object for the given many_to_one association reflection
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2877
  def set_associated_object(opts, o); end

  # Whether run the associated object setter code if passed the same object as the one already
  # cached in the association.  Usually not set (so nil), can be set on a per-object basis
  # if necessary.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#2872
  def set_associated_object_if_same?; end

  # Set the given object as the associated object for the given one_through_one association reflection
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2883
  def set_one_through_one_associated_object(opts, o); end

  # Set the given object as the associated object for the given one_to_one association reflection
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/associations.rb#2890
  def set_one_to_one_associated_object(opts, o); end
end

# source://sequel//lib/sequel/model/associations.rb#1220
class Sequel::Model::Associations::ManyToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  # The alias to use for the associated key when eagerly loading
  #
  # source://sequel//lib/sequel/model/associations.rb#1224
  def associated_key_alias; end

  # Array of associated keys used when eagerly loading.
  #
  # source://sequel//lib/sequel/model/associations.rb#1229
  def associated_key_array; end

  # The column to use for the associated key when eagerly loading
  #
  # source://sequel//lib/sequel/model/associations.rb#1240
  def associated_key_column; end

  # The join table itself, unless it is aliased, in which case this
  # is the alias.
  #
  # source://sequel//lib/sequel/model/associations.rb#1356
  def associated_key_table; end

  # Alias of right_primary_keys
  #
  # source://sequel//lib/sequel/model/associations.rb#1245
  def associated_object_keys; end

  # many_to_many associations can only have associated objects if none of
  # the :left_primary_keys options have a nil value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1251
  def can_have_associated_objects?(obj); end

  # one_through_one and many_to_many associations can be clones
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1256
  def cloneable?(ref); end

  # The default associated key alias(es) to use when eager loading
  # associations via eager.
  #
  # source://sequel//lib/sequel/model/associations.rb#1262
  def default_associated_key_alias; end

  # The default eager loader used if the user doesn't override it.  Extracted
  # to a method so the code can be shared with the many_through_many plugin.
  #
  # source://sequel//lib/sequel/model/associations.rb#1268
  def default_eager_loader(eo); end

  # Default name symbol for the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1299
  def default_join_table; end

  # Default foreign key name symbol for key in join table that points to
  # current table's primary key (or :left_primary_key column).
  #
  # source://sequel//lib/sequel/model/associations.rb#1305
  def default_left_key; end

  # Default foreign key name symbol for foreign key in join table that points to
  # the association's table's primary key (or :right_primary_key column).
  #
  # source://sequel//lib/sequel/model/associations.rb#1311
  def default_right_key; end

  # many_to_many associations need to select a key in an associated table to eagerly load
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1344
  def eager_loading_use_associated_key?; end

  # source://sequel//lib/sequel/model/associations.rb#1327
  def finalize_settings; end

  # The join table itself, unless it is aliased, in which case this
  # is the alias.
  #
  # source://sequel//lib/sequel/model/associations.rb#1356
  def join_table_alias; end

  # The source of the join table.  This is the join table itself, unless it
  # is aliased, in which case it is the unaliased part.
  #
  # source://sequel//lib/sequel/model/associations.rb#1350
  def join_table_source; end

  # Whether the associated object needs a primary key to be added/removed,
  # true for many_to_many associations.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1366
  def need_associated_primary_key?; end

  # The hash key to use for the eager loading predicate (left side of IN (1, 2, 3)).
  # The left key qualified by the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1333
  def predicate_key; end

  # The hash key to use for the eager loading predicate (left side of IN (1, 2, 3)).
  # The left key qualified by the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1333
  def qualified_left_key; end

  # The right key qualified by the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1339
  def qualified_right_key; end

  # #right_primary_key qualified by the associated table
  #
  # source://sequel//lib/sequel/model/associations.rb#1371
  def qualified_right_primary_key; end

  # The primary key column(s) to use in the associated table (can be symbol or array).
  #
  # source://sequel//lib/sequel/model/associations.rb#1376
  def right_primary_key; end

  # The method symbol or array of method symbols to call on the associated objects
  # to get the foreign key values for the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1387
  def right_primary_key_method; end

  # The array of method symbols to call on the associated objects
  # to get the foreign key values for the join table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1393
  def right_primary_key_methods; end

  # The primary key columns to use in the associated table (always array).
  #
  # source://sequel//lib/sequel/model/associations.rb#1381
  def right_primary_keys; end

  # The columns to select when loading the association, associated_class.table_name.* by default.
  #
  # source://sequel//lib/sequel/model/associations.rb#1398
  def select; end

  # Whether a separate query should be used for the join table.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1403
  def separate_query_per_table?; end

  private

  # Join to the the join table, unless using a separate query per table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1410
  def _associated_dataset; end

  # The default selection for associations that require joins.  These do not use the default
  # model selection unless all entries in the select are explicitly qualified identifiers, as
  # other it can include unqualified columns which would be made ambiguous by joining.
  #
  # source://sequel//lib/sequel/model/associations.rb#1431
  def default_select; end

  # Use the right_keys from the eager loading options if
  # using a separate query per table.
  #
  # source://sequel//lib/sequel/model/associations.rb#1420
  def eager_loading_set_predicate_condition(ds, eo); end

  # source://sequel//lib/sequel/model/associations.rb#1439
  def filter_by_associations_conditions_associated_keys; end

  # source://sequel//lib/sequel/model/associations.rb#1443
  def filter_by_associations_conditions_key; end

  # source://sequel//lib/sequel/model/associations.rb#1447
  def filter_by_associations_limit_alias_key; end

  # source://sequel//lib/sequel/model/associations.rb#1452
  def filter_by_associations_limit_aliases; end

  # source://sequel//lib/sequel/model/associations.rb#1456
  def filter_by_associations_limit_key; end

  # source://sequel//lib/sequel/model/associations.rb#1460
  def predicate_key_methods; end

  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1464
  def reciprocal_association?(assoc_reflect); end

  # source://sequel//lib/sequel/model/associations.rb#1472
  def reciprocal_type; end

  # Whether the given expression represents a qualified identifier.  Used to determine if it is
  # OK to use directly when joining.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1478
  def selection_is_qualified?(c); end

  # Split the join table into source and alias parts.
  #
  # source://sequel//lib/sequel/model/associations.rb#1492
  def split_join_table_alias; end
end

# source://sequel//lib/sequel/model/associations.rb#1315
Sequel::Model::Associations::ManyToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/model/associations.rb#839
class Sequel::Model::Associations::ManyToOneAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  # The columns in the associated table that the key in the current table references (always an array).
  #
  # source://sequel//lib/sequel/model/associations.rb#903
  def associated_object_keys; end

  # many_to_one associations can only have associated objects if none of
  # the :keys options have a nil value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#844
  def can_have_associated_objects?(obj); end

  # Whether the dataset needs a primary key to function, false for many_to_one associations.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#849
  def dataset_need_primary_key?; end

  # Default foreign key name symbol for foreign key in current model's table that points to
  # the given association's table's primary key.
  #
  # source://sequel//lib/sequel/model/associations.rb#855
  def default_key; end

  # Whether to eagerly graph a lazy dataset, true for many_to_one associations
  # only if the key is nil.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#861
  def eager_graph_lazy_dataset?; end

  # many_to_one associations don't need an eager_graph limit strategy
  #
  # source://sequel//lib/sequel/model/associations.rb#866
  def eager_graph_limit_strategy(_); end

  # many_to_one associations don't need an eager limit strategy
  #
  # source://sequel//lib/sequel/model/associations.rb#871
  def eager_limit_strategy; end

  # many_to_one associations don't need a filter by associations limit strategy
  #
  # source://sequel//lib/sequel/model/associations.rb#876
  def filter_by_associations_limit_strategy; end

  # source://sequel//lib/sequel/model/associations.rb#888
  def finalize_settings; end

  # The expression to use on the left hand side of the IN lookup when eager loading
  #
  # source://sequel//lib/sequel/model/associations.rb#893
  def predicate_key; end

  # The column(s) in the associated table that the key in the current table references (either a symbol or an array).
  #
  # source://sequel//lib/sequel/model/associations.rb#898
  def primary_key; end

  # The method symbol or array of method symbols to call on the associated object
  # to get the value to use for the foreign keys.
  #
  # source://sequel//lib/sequel/model/associations.rb#910
  def primary_key_method; end

  # The array of method symbols to call on the associated object
  # to get the value to use for the foreign keys.
  #
  # source://sequel//lib/sequel/model/associations.rb#916
  def primary_key_methods; end

  # The columns in the associated table that the key in the current table references (always an array).
  #
  # source://sequel//lib/sequel/model/associations.rb#903
  def primary_keys; end

  # #primary_key qualified by the associated table
  #
  # source://sequel//lib/sequel/model/associations.rb#921
  def qualified_primary_key; end

  # True only if the reciprocal is a one_to_many association.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#926
  def reciprocal_array?; end

  # Whether this association returns an array of objects instead of a single object,
  # false for a many_to_one association.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#932
  def returns_array?; end

  # True only if the reciprocal is a one_to_one association.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#937
  def set_reciprocal_to_self?; end

  private

  # Reciprocals of many_to_one associations could be either one_to_many or one_to_one,
  # and which is not known in advance.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#946
  def ambiguous_reciprocal_type?; end

  # source://sequel//lib/sequel/model/associations.rb#950
  def filter_by_associations_conditions_associated_keys; end

  # source://sequel//lib/sequel/model/associations.rb#954
  def filter_by_associations_conditions_key; end

  # many_to_one associations do not need to be limited to a single row if they
  # explicitly do not have a key.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#960
  def limit_to_single_row?; end

  # The reciprocal type of a many_to_one association is either
  # a one_to_many or a one_to_one association.
  #
  # source://sequel//lib/sequel/model/associations.rb#970
  def possible_reciprocal_types; end

  # source://sequel//lib/sequel/model/associations.rb#964
  def predicate_key_methods; end

  # Whether the given association reflection is possible reciprocal
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#975
  def reciprocal_association?(assoc_reflect); end

  # The reciprocal type of a many_to_one association is either
  # a one_to_many or a one_to_one association, look in the associated class
  # to try to figure out which.
  #
  # source://sequel//lib/sequel/model/associations.rb#982
  def reciprocal_type; end
end

# source://sequel//lib/sequel/model/associations.rb#880
Sequel::Model::Associations::ManyToOneAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/model/associations.rb#1497
class Sequel::Model::Associations::OneThroughOneAssociationReflection < ::Sequel::Model::Associations::ManyToManyAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection

  # one_through_one associations should not singularize the association name when
  # creating the foreign key.
  #
  # source://sequel//lib/sequel/model/associations.rb#1503
  def default_right_key; end

  # one_through_one associations have no reciprocals
  #
  # source://sequel//lib/sequel/model/associations.rb#1508
  def reciprocal; end
end

# source://sequel//lib/sequel/model/associations.rb#1001
class Sequel::Model::Associations::OneToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  # Support a correlated subquery limit strategy when using eager_graph.
  #
  # source://sequel//lib/sequel/model/associations.rb#1005
  def apply_eager_graph_limit_strategy(strategy, ds); end

  # The keys in the associated model's table related to this association
  #
  # source://sequel//lib/sequel/model/associations.rb#1015
  def associated_object_keys; end

  # one_to_many associations can only have associated objects if none of
  # the :keys options have a nil value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1021
  def can_have_associated_objects?(obj); end

  # one_to_many and one_to_one associations can be clones
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1026
  def cloneable?(ref); end

  # Default foreign key name symbol for key in associated table that points to
  # current table's primary key.
  #
  # source://sequel//lib/sequel/model/associations.rb#1032
  def default_key; end

  # source://sequel//lib/sequel/model/associations.rb#1039
  def finalize_settings; end

  # Handle silent failure of add/remove methods if raise_on_save_failure is false.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1044
  def handle_silent_modification_failure?; end

  # The hash key to use for the eager loading predicate (left side of IN (1, 2, 3))
  #
  # source://sequel//lib/sequel/model/associations.rb#1049
  def predicate_key; end

  # The column in the current table that the key in the associated table references.
  #
  # source://sequel//lib/sequel/model/associations.rb#1055
  def primary_key; end

  # The hash key to use for the eager loading predicate (left side of IN (1, 2, 3))
  #
  # source://sequel//lib/sequel/model/associations.rb#1049
  def qualified_key; end

  # #primary_key qualified by the current table
  #
  # source://sequel//lib/sequel/model/associations.rb#1060
  def qualified_primary_key; end

  # Whether the reciprocal of this association returns an array of objects instead of a single object,
  # false for a one_to_many association.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1066
  def reciprocal_array?; end

  # Destroying one_to_many associated objects automatically deletes the foreign key.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1071
  def remove_before_destroy?; end

  # The one_to_many association needs to check that an object to be removed already is associated.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1076
  def remove_should_check_existing?; end

  # One to many associations set the reciprocal to self when loading associated records.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1081
  def set_reciprocal_to_self?; end

  private

  # Use a correlated subquery to limit the dataset.  Note that this will not
  # work correctly if the associated dataset uses qualified identifers in the WHERE clause,
  # as they would reference the containing query instead of the subquery.
  #
  # source://sequel//lib/sequel/model/associations.rb#1090
  def apply_correlated_subquery_limit_strategy(ds); end

  # Support correlated subquery strategy when filtering by limited associations.
  #
  # source://sequel//lib/sequel/model/associations.rb#1105
  def apply_filter_by_associations_limit_strategy(ds); end

  # source://sequel//lib/sequel/model/associations.rb#1114
  def filter_by_associations_conditions_associated_keys; end

  # source://sequel//lib/sequel/model/associations.rb#1118
  def filter_by_associations_conditions_key; end

  # source://sequel//lib/sequel/model/associations.rb#1122
  def filter_by_associations_limit_alias_key; end

  # source://sequel//lib/sequel/model/associations.rb#1126
  def filter_by_associations_limit_aliases; end

  # source://sequel//lib/sequel/model/associations.rb#1130
  def filter_by_associations_limit_key; end

  # source://sequel//lib/sequel/model/associations.rb#1134
  def predicate_key_methods; end

  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1138
  def reciprocal_association?(assoc_reflect); end

  # The reciprocal type of a one_to_many association is a many_to_one association.
  #
  # source://sequel//lib/sequel/model/associations.rb#1143
  def reciprocal_type; end

  # Support automatic use of correlated subqueries if :ruby option is best available option,
  # the database supports them, and either the associated class has a non-composite primary key
  # or the database supports multiple columns in IN.
  #
  # source://sequel//lib/sequel/model/associations.rb#1150
  def true_eager_graph_limit_strategy; end
end

# source://sequel//lib/sequel/model/associations.rb#1036
Sequel::Model::Associations::OneToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/model/associations.rb#1215
class Sequel::Model::Associations::OneToOneAssociationReflection < ::Sequel::Model::Associations::OneToManyAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection
end

# Methods that turn an association that returns multiple objects into an association that
# returns a single object.
#
# source://sequel//lib/sequel/model/associations.rb#1163
module Sequel::Model::Associations::SingularAssociationReflection
  # Singular associations do not assign singular if they are using the ruby eager limit strategy
  # and have a slice range, since they need to store the array of associated objects in order to
  # pick the correct one with an offset.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1167
  def assign_singular?; end

  # Add conditions when filtering by singular associations with orders, since the
  # underlying relationship is probably not one-to-one.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1173
  def filter_by_associations_add_conditions?; end

  # Make sure singular associations always have 1 as the limit
  #
  # source://sequel//lib/sequel/model/associations.rb#1178
  def limit_and_offset; end

  # Singular associations always return a single object, not an array.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/associations.rb#1188
  def returns_array?; end

  private

  # Only use a eager limit strategy by default if there is an offset or an order.
  #
  # source://sequel//lib/sequel/model/associations.rb#1195
  def default_eager_limit_strategy; end

  # Use a strategy for filtering by associations if there is an order or an offset,
  # or a specific limiting strategy has been specified.
  #
  # source://sequel//lib/sequel/model/associations.rb#1201
  def filter_by_associations_limit_strategy; end

  # Use the DISTINCT ON eager limit strategy for true if the database supports it.
  #
  # source://sequel//lib/sequel/model/associations.rb#1206
  def true_eager_graph_limit_strategy; end
end

# Class methods for Sequel::Model that implement basic model functionality.
#
# * All of the following methods have class methods created that send the method
#   to the model's dataset: all, as_hash, avg, count, cross_join, distinct, each,
#   each_server, empty?, except, exclude, exclude_having, fetch_rows,
#   filter, first, first!, for_update, from, from_self, full_join, full_outer_join,
#   get, graph, grep, group, group_and_count, group_append, group_by, having, import,
#   inner_join, insert, intersect, invert, join, join_table, last, left_join,
#   left_outer_join, limit, lock_style, map, max, min, multi_insert, naked, natural_full_join,
#   natural_join, natural_left_join, natural_right_join, offset, order, order_append, order_by,
#   order_more, order_prepend, paged_each, qualify, reverse, reverse_order, right_join,
#   right_outer_join, select, select_all, select_append, select_group, select_hash,
#   select_hash_groups, select_map, select_more, select_order_map, server,
#   single_record, single_record!, single_value, single_value!, sum, to_hash, to_hash_groups,
#   truncate, unfiltered, ungraphed, ungrouped, union, unlimited, unordered, where, where_all,
#   where_each, where_single_value, with, with_recursive, with_sql
#
# source://sequel//lib/sequel/model/base.rb#24
module Sequel::Model::ClassMethods
  # Lets you create a Model subclass with its dataset already set.
  # +source+ should be an instance of one of the following classes:
  #
  # Database :: Sets the database for this model to +source+.
  #             Generally only useful when subclassing directly
  #             from the returned class, where the name of the
  #             subclass sets the table name (which is combined
  #             with the +Database+ in +source+ to create the
  #             dataset to use)
  # Dataset :: Sets the dataset for this model to +source+.
  # other :: Sets the table name for this model to +source+. The
  #          class will use the default database for model
  #          classes in order to create the dataset.
  #
  # The purpose of this method is to set the dataset/database automatically
  # for a model class, if the table name doesn't match the default table
  # name that Sequel would use.
  #
  # When creating subclasses of Sequel::Model itself, this method is usually
  # called on Sequel itself, using <tt>Sequel::Model(:something)</tt>.
  #
  #   # Using a symbol
  #   class Comment < Sequel::Model(:something)
  #     table_name # => :something
  #   end
  #
  #   # Using a dataset
  #   class Comment < Sequel::Model(DB1[:something])
  #     dataset # => DB1[:something]
  #   end
  #
  #   # Using a database
  #   class Comment < Sequel::Model(DB1)
  #     dataset # => DB1[:comments]
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#179
  def Model(source); end

  # Returns the first record from the database matching the conditions.
  # If a hash is given, it is used as the conditions.  If another
  # object is given, it finds the first record whose primary key(s) match
  # the given argument(s).  If no object is returned by the dataset, returns nil.
  #
  #   Artist[1] # SELECT * FROM artists WHERE id = 1
  #   # => #<Artist {:id=>1, ...}>
  #
  #   Artist[name: 'Bob'] # SELECT * FROM artists WHERE (name = 'Bob') LIMIT 1
  #   # => #<Artist {:name=>'Bob', ...}>
  #
  # source://sequel//lib/sequel/model/base.rb#212
  def [](*args); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def all(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def as_hash(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def avg(*args, **_arg1, &block); end

  # Whether to cache the anonymous models created by Sequel::Model(), true by default.  This is
  # required for reloading them correctly (avoiding the superclass mismatch).
  #
  # source://sequel//lib/sequel/model/base.rb#27
  def cache_anonymous_models; end

  # Whether to cache the anonymous models created by Sequel::Model(), true by default.  This is
  # required for reloading them correctly (avoiding the superclass mismatch).
  #
  # source://sequel//lib/sequel/model/base.rb#27
  def cache_anonymous_models=(_arg0); end

  # Initializes a model instance as an existing record. This constructor is
  # used by Sequel to initialize model instances when fetching records.
  # Requires that values be a hash where all keys are symbols. It
  # probably should not be used by external code.
  #
  # source://sequel//lib/sequel/model/base.rb#221
  def call(values); end

  # Clear the setter_methods cache
  #
  # source://sequel//lib/sequel/model/base.rb#228
  def clear_setter_methods_cache; end

  # Returns the columns in the result set in their original order.
  # Generally, this will use the columns determined via the database
  # schema, but in certain cases (e.g. models that are based on a joined
  # dataset) it will use <tt>Dataset#columns</tt> to find the columns.
  #
  #   Artist.columns
  #   # => [:id, :name]
  #
  # source://sequel//lib/sequel/model/base.rb#239
  def columns; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def count(*args, **_arg1, &block); end

  # Creates instance using new with the given values and block, and saves it.
  #
  #   Artist.create(name: 'Bob')
  #   # INSERT INTO artists (name) VALUES ('Bob')
  #
  #   Artist.create do |a|
  #     a.name = 'Jim'
  #   end # INSERT INTO artists (name) VALUES ('Jim')
  #
  # source://sequel//lib/sequel/model/base.rb#253
  def create(values = T.unsafe(nil), &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def cross_join(*args, **_arg1, &block); end

  # Returns the dataset associated with the Model class.  Raises
  # an +Error+ if there is no associated dataset for this class.
  # In most cases, you don't need to call this directly, as Model
  # proxies many dataset methods to the underlying dataset.
  #
  #   Artist.dataset.all # SELECT * FROM artists
  #
  # source://sequel//lib/sequel/model/base.rb#263
  def dataset; end

  # Alias of set_dataset
  #
  # source://sequel//lib/sequel/model/base.rb#268
  def dataset=(ds); end

  # Array of modules that extend this model's dataset.  Stored
  # so that if the model's dataset is changed, it will be extended
  # with all of these modules.
  #
  # source://sequel//lib/sequel/model/base.rb#32
  def dataset_method_modules; end

  # Extend the dataset with a module, similar to adding
  # a plugin with the methods defined in DatasetMethods.
  # This is the recommended way to add methods to model datasets.
  #
  # If given an argument, it should be a module, and is used to extend
  # the underlying dataset.  Otherwise an anonymous module is created, and
  # if a block is given, it is module_evaled, allowing you do define
  # dataset methods directly using the standard ruby def syntax.
  # Returns the module given or the anonymous module created.
  #
  #   # Usage with existing module
  #   Album.dataset_module Sequel::ColumnsIntrospection
  #
  #   # Usage with anonymous module
  #   Album.dataset_module do
  #     def foo
  #       :bar
  #     end
  #   end
  #   Album.dataset.foo
  #   # => :bar
  #   Album.foo
  #   # => :bar
  #
  # Any anonymous modules created are actually instances of Sequel::Model::DatasetModule
  # (a Module subclass), which allows you to call the subset method on them, which
  # defines a dataset method that adds a filter.  There are also a number of other
  # methods with the same names as the dataset methods, which can use to define
  # named dataset methods:
  #
  #   Album.dataset_module do
  #     where(:released, Sequel[:release_date] <= Sequel::CURRENT_DATE)
  #     order :by_release_date, :release_date
  #     select :for_select_options, :id, :name, :release_date
  #   end
  #   Album.released.sql
  #   # => "SELECT * FROM artists WHERE (release_date <= CURRENT_DATE)"
  #   Album.by_release_date.sql
  #   # => "SELECT * FROM artists ORDER BY release_date"
  #   Album.for_select_options.sql
  #   # => "SELECT id, name, release_date FROM artists"
  #   Album.released.by_release_date.for_select_options.sql
  #   # => "SELECT id, name, release_date FROM artists WHERE (release_date <= CURRENT_DATE) ORDER BY release_date"
  #
  # The following methods are supported: distinct, eager, exclude, exclude_having, grep, group, group_and_count,
  # group_append, having, limit, offset, order, order_append, order_prepend, select, select_all,
  # select_append, select_group, where, and server.
  #
  # The advantage of using these DatasetModule methods to define your dataset
  # methods is that they can take advantage of dataset caching to improve
  # performance.
  #
  # Any public methods in the dataset module will have class methods created that
  # call the method on the dataset, assuming that the class method is not already
  # defined.
  #
  # source://sequel//lib/sequel/model/base.rb#327
  def dataset_module(mod = T.unsafe(nil), &block); end

  # The Module subclass to use for dataset_module blocks.
  #
  # source://sequel//lib/sequel/model/base.rb#35
  def dataset_module_class; end

  # Returns the database associated with the Model class.
  # If this model doesn't have a database associated with it,
  # assumes the superclass's database, or the first object in
  # Sequel::DATABASES.  If no Sequel::Database object has
  # been created, raises an error.
  #
  #   Artist.db.transaction do # BEGIN
  #     Artist.create(name: 'Bob')
  #     # INSERT INTO artists (name) VALUES ('Bob')
  #   end # COMMIT
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/base.rb#350
  def db; end

  # Sets the database associated with the Model class.
  # Should only be used if the Model class currently does not
  # have a dataset defined.
  #
  # This can be used directly on Sequel::Model to set the default database to be used
  # by subclasses, or to override the database used for specific models:
  #
  #   Sequel::Model.db = DB1
  #   Artist = Class.new(Sequel::Model)
  #   Artist.db = DB2
  #
  # Note that you should not use this to change the model's database
  # at runtime.  If you have that need, you should look into Sequel's
  # sharding support, or consider using separate model classes per Database.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/base.rb#371
  def db=(db); end

  # Returns the cached schema information if available or gets it
  # from the database.  This is a hash where keys are column symbols
  # and values are hashes of information related to the column.  See
  # <tt>Database#schema</tt>.
  #
  #   Artist.db_schema
  #   # {:id=>{:type=>:integer, :primary_key=>true, ...},
  #   #  :name=>{:type=>:string, :primary_key=>false, ...}}
  #
  # source://sequel//lib/sequel/model/base.rb#384
  def db_schema; end

  # Define a Model method on the given module that calls the Model
  # method on the receiver.  This is how the Sequel::Model() method is
  # defined, and allows you to define Model() methods on other modules,
  # making it easier to have custom model settings for all models under
  # a namespace.  Example:
  #
  #   module Foo
  #     Model = Class.new(Sequel::Model)
  #     Model.def_Model(self)
  #     DB = Model.db = Sequel.connect(ENV['FOO_DATABASE_URL'])
  #     Model.plugin :prepared_statements
  #
  #     class Bar < Model
  #       # Uses Foo::DB[:bars]
  #     end
  #
  #     class Baz < Model(:my_baz)
  #       # Uses Foo::DB[:my_baz]
  #     end
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#137
  def def_Model(mod); end

  # Create a column alias, where the column methods have one name, but the underlying storage uses a
  # different name.
  #
  # source://sequel//lib/sequel/model/base.rb#392
  def def_column_alias(meth, column); end

  # The default options to use for Model#set_fields.  These are merged with
  # the options given to set_fields.
  #
  # source://sequel//lib/sequel/model/base.rb#39
  def default_set_fields_options; end

  # The default options to use for Model#set_fields.  These are merged with
  # the options given to set_fields.
  #
  # source://sequel//lib/sequel/model/base.rb#39
  def default_set_fields_options=(_arg0); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def distinct(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def each(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def each_server(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def empty?(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def except(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def exclude(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def exclude_having(*args, **_arg1, &block); end

  # SQL string fragment used for faster DELETE statement creation when deleting/destroying
  # model instances, or nil if the optimization should not be used. For internal use only.
  #
  # source://sequel//lib/sequel/model/base.rb#43
  def fast_instance_delete_sql; end

  # SQL string fragment used for faster lookups by primary key, or nil if the optimization
  # should not be used. For internal use only.
  #
  # source://sequel//lib/sequel/model/base.rb#47
  def fast_pk_lookup_sql; end

  # Returns a copy of the model's dataset with custom SQL
  #
  #   Artist.fetch("SELECT * FROM artists WHERE name LIKE 'A%'")
  #   Artist.fetch("SELECT * FROM artists WHERE id = ?", 1)
  #
  # source://sequel//lib/sequel/model/plugins.rb#33
  def fetch(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def fetch_rows(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def filter(*args, **_arg1, &block); end

  # Finds a single record according to the supplied filter.
  # You are encouraged to use Model.[] or Model.first instead of this method.
  #
  #   Artist.find(name: 'Bob')
  #   # SELECT * FROM artists WHERE (name = 'Bob') LIMIT 1
  #
  #   Artist.find{name > 'M'}
  #   # SELECT * FROM artists WHERE (name > 'M') LIMIT 1
  #
  # source://sequel//lib/sequel/model/base.rb#408
  def find(*args, &block); end

  # Like +find+ but invokes create with given conditions when record does not
  # exist.  Unlike +find+ in that the block used in this method is not passed
  # to +find+, but instead is passed to +create+ only if +find+ does not
  # return an object.
  #
  #   Artist.find_or_create(name: 'Bob')
  #   # SELECT * FROM artists WHERE (name = 'Bob') LIMIT 1
  #   # INSERT INTO artists (name) VALUES ('Bob')
  #
  #   Artist.find_or_create(name: 'Jim'){|a| a.hometown = 'Sactown'}
  #   # SELECT * FROM artists WHERE (name = 'Jim') LIMIT 1
  #   # INSERT INTO artists (name, hometown) VALUES ('Jim', 'Sactown')
  #
  # source://sequel//lib/sequel/model/base.rb#424
  def find_or_create(cond, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def first(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def first!(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def for_update(*args, **_arg1, &block); end

  # Freeze a model class, disallowing any further changes to it.
  #
  # source://sequel//lib/sequel/model/base.rb#429
  def freeze; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def from(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def from_self(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def full_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def full_outer_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def get(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def graph(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def grep(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def group(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def group_and_count(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def group_append(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def group_by(*args, **_arg1, &block); end

  # Whether the model has a dataset.  True for most model classes,
  # but can be false if the model class is an abstract model class
  # designed for subclassing, such as Sequel::Model itself.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#452
  def has_dataset?; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def having(*args, **_arg1, &block); end

  # Returns the implicit table name for the model class, which is the demodulized,
  # underscored, pluralized name of the class.
  #
  #   Artist.implicit_table_name # => :artists
  #   Foo::ArtistAlias.implicit_table_name # => :artist_aliases
  #
  # source://sequel//lib/sequel/model/base.rb#468
  def implicit_table_name; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def import(*args, **_arg1, &block); end

  # Clear the setter_methods cache when a module is included, as it
  # may contain setter methods.
  #
  # source://sequel//lib/sequel/model/base.rb#458
  def include(*mods); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def inner_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def insert(*args, **_arg1, &block); end

  # The dataset that instance datasets (#this) are based on.  Generally a naked version of
  # the model's dataset limited to one row.  For internal use only.
  #
  # source://sequel//lib/sequel/model/base.rb#51
  def instance_dataset; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def intersect(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def invert(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def join_table(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def last(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def left_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def left_outer_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def limit(*args, **_arg1, &block); end

  # Calls #call with the values hash.
  #
  # source://sequel//lib/sequel/model/base.rb#473
  def load(values); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def lock_style(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def map(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def max(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def min(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def multi_insert(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def naked(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def natural_full_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def natural_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def natural_left_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def natural_right_join(*args, **_arg1, &block); end

  # Mark the model as not having a primary key. Not having a primary key
  # can cause issues, among which is that you won't be able to update records.
  #
  #   Artist.primary_key # => :id
  #   Artist.no_primary_key
  #   Artist.primary_key # => nil
  #
  # source://sequel//lib/sequel/model/base.rb#483
  def no_primary_key; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def offset(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def order(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def order_append(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def order_by(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def order_more(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def order_prepend(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def paged_each(*args, **_arg1, &block); end

  # Loads a plugin for use with the model class, passing optional arguments
  # to the plugin.  If the plugin is a module, load it directly.  Otherwise,
  # require the plugin from sequel/plugins/#{plugin} and then attempt to load
  # the module using a the camelized plugin name under Sequel::Plugins.
  #
  # source://sequel//lib/sequel/model/base.rb#492
  def plugin(plugin, *args, **_arg2, &block); end

  # Array of plugin modules loaded by this class
  #
  #   Sequel::Model.plugins
  #   # => [Sequel::Model, Sequel::Model::Associations]
  #
  # source://sequel//lib/sequel/model/base.rb#57
  def plugins; end

  # The primary key for the class.  Sequel can determine this automatically for
  # many databases, but not all, so you may need to set it manually.  If not
  # determined automatically, the default is :id.
  #
  # source://sequel//lib/sequel/model/base.rb#62
  def primary_key; end

  # Returns primary key attribute hash.  If using a composite primary key
  # value such be an array with values for each primary key in the correct
  # order.  For a standard primary key, value should be an object with a
  # compatible type for the key.  If the model does not have a primary key,
  # raises an +Error+.
  #
  #   Artist.primary_key_hash(1) # => {:id=>1}
  #   Artist.primary_key_hash([1, 2]) # => {:id1=>1, :id2=>2}
  #
  # source://sequel//lib/sequel/model/base.rb#523
  def primary_key_hash(value); end

  # Return a hash where the keys are qualified column references.  Uses the given
  # qualifier if provided, or the table_name otherwise. This is useful if you
  # plan to join other tables to this table and you want the column references
  # to be qualified.
  #
  #   Artist.where(Artist.qualified_primary_key_hash(1))
  #   # SELECT * FROM artists WHERE (artists.id = 1)
  #
  # source://sequel//lib/sequel/model/base.rb#543
  def qualified_primary_key_hash(value, qualifier = T.unsafe(nil)); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def qualify(*args, **_arg1, &block); end

  # Whether to raise an error instead of returning nil on a failure
  # to save/create/save_changes/update/destroy due to a validation failure or
  # a before_* hook returning false (default: true).
  #
  # source://sequel//lib/sequel/model/base.rb#67
  def raise_on_save_failure; end

  # Whether to raise an error instead of returning nil on a failure
  # to save/create/save_changes/update/destroy due to a validation failure or
  # a before_* hook returning false (default: true).
  #
  # source://sequel//lib/sequel/model/base.rb#67
  def raise_on_save_failure=(_arg0); end

  # Whether to raise an error when unable to typecast data for a column
  # (default: false).  This should be set to true if you want to have model
  # setter methods raise errors if the argument cannot be typecast properly.
  #
  # source://sequel//lib/sequel/model/base.rb#72
  def raise_on_typecast_failure; end

  # Whether to raise an error when unable to typecast data for a column
  # (default: false).  This should be set to true if you want to have model
  # setter methods raise errors if the argument cannot be typecast properly.
  #
  # source://sequel//lib/sequel/model/base.rb#72
  def raise_on_typecast_failure=(_arg0); end

  # Whether to raise an error if an UPDATE or DELETE query related to
  # a model instance does not modify exactly 1 row.  If set to false,
  # Sequel will not check the number of rows modified (default: true).
  #
  # source://sequel//lib/sequel/model/base.rb#77
  def require_modification; end

  # Whether to raise an error if an UPDATE or DELETE query related to
  # a model instance does not modify exactly 1 row.  If set to false,
  # Sequel will not check the number of rows modified (default: true).
  #
  # source://sequel//lib/sequel/model/base.rb#77
  def require_modification=(_arg0); end

  # If true (the default), requires that all models have valid tables,
  # raising exceptions if creating a model without a valid table backing it.
  # Setting this to false will allow the creation of model classes where the
  # underlying table doesn't exist.
  #
  # source://sequel//lib/sequel/model/base.rb#83
  def require_valid_table; end

  # If true (the default), requires that all models have valid tables,
  # raising exceptions if creating a model without a valid table backing it.
  # Setting this to false will allow the creation of model classes where the
  # underlying table doesn't exist.
  #
  # source://sequel//lib/sequel/model/base.rb#83
  def require_valid_table=(_arg0); end

  # Restrict the setting of the primary key(s) when using mass assignment (e.g. +set+).  Because
  # this is the default, this only make sense to use in a subclass where the
  # parent class has used +unrestrict_primary_key+.
  #
  # source://sequel//lib/sequel/model/base.rb#559
  def restrict_primary_key; end

  # Whether or not setting the primary key(s) when using mass assignment (e.g. +set+) is
  # restricted, true by default.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#566
  def restrict_primary_key?; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def reverse(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def reverse_order(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def right_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def right_outer_join(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_all(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_append(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_group(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_hash(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_hash_groups(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_map(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_more(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def select_order_map(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def server(*args, **_arg1, &block); end

  # Sets the dataset associated with the Model class. +ds+ can be a +Symbol+,
  # +LiteralString+, <tt>SQL::Identifier</tt>, <tt>SQL::QualifiedIdentifier</tt>,
  # <tt>SQL::AliasedExpression</tt>
  # (all specifying a table name in the current database), or a +Dataset+.
  # If a dataset is used, the model's database is changed to the database of the given
  # dataset.  If a dataset is not used, a dataset is created from the current
  # database with the table name given. Other arguments raise an +Error+.
  # Returns self.
  #
  # It also attempts to determine the database schema for the model,
  # based on the given dataset.
  #
  # Note that you should not use this to change the model's dataset
  # at runtime.  If you have that need, you should look into Sequel's
  # sharding support, or creating a separate Model class per dataset
  #
  # You should avoid calling this method directly if possible.  Instead you should
  # set the table name or dataset when creating the model class:
  #
  #   # table name
  #   class Artist < Sequel::Model(:tbl_artists)
  #   end
  #
  #   # dataset
  #   class Artist < Sequel::Model(DB[:tbl_artists])
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#596
  def set_dataset(ds, opts = T.unsafe(nil)); end

  # Sets the primary key for this model. You can use either a regular
  # or a composite primary key.  To not use a primary key, set to nil
  # or use +no_primary_key+. On most adapters, Sequel can automatically
  # determine the primary key to use, so this method is not needed often.
  #
  #   class Person < Sequel::Model
  #     # regular key
  #     set_primary_key :person_id
  #   end
  #
  #   class Tagging < Sequel::Model
  #     # composite key
  #     set_primary_key [:taggable_id, :tag_id]
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#628
  def set_primary_key(key); end

  # Cache of setter methods to allow by default, in order to speed up mass assignment.
  #
  # source://sequel//lib/sequel/model/base.rb#644
  def setter_methods; end

  # Should be the literal primary key column name if this Model's table has a simple primary key, or
  # nil if the model has a compound primary key or no primary key.
  #
  # source://sequel//lib/sequel/model/base.rb#87
  def simple_pk; end

  # Should be the literal table name if this Model's dataset is a simple table (no select, order, join, etc.),
  # or nil otherwise.  This and simple_pk are used for an optimization in Model.[].
  #
  # source://sequel//lib/sequel/model/base.rb#91
  def simple_table; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def single_record(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def single_record!(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def single_value(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def single_value!(*args, **_arg1, &block); end

  # Whether mass assigning via .create/.new/#set/#update should raise an error
  # if an invalid key is used.  A key is invalid if no setter method exists
  # for that key or the access to the setter method is restricted (e.g. due to it
  # being a primary key field).  If set to false, silently skip
  # any key where the setter method doesn't exist or access to it is restricted.
  #
  # source://sequel//lib/sequel/model/base.rb#98
  def strict_param_setting; end

  # Whether mass assigning via .create/.new/#set/#update should raise an error
  # if an invalid key is used.  A key is invalid if no setter method exists
  # for that key or the access to the setter method is restricted (e.g. due to it
  # being a primary key field).  If set to false, silently skip
  # any key where the setter method doesn't exist or access to it is restricted.
  #
  # source://sequel//lib/sequel/model/base.rb#98
  def strict_param_setting=(_arg0); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def sum(*args, **_arg1, &block); end

  # Returns name of primary table for the dataset. If the table for the dataset
  # is aliased, returns the aliased name.
  #
  #   Artist.table_name # => :artists
  #   Sequel::Model(:foo).table_name # => :foo
  #   Sequel::Model(Sequel[:foo].as(:bar)).table_name # => :bar
  #
  # source://sequel//lib/sequel/model/base.rb#654
  def table_name; end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def to_hash(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def to_hash_groups(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def truncate(*args, **_arg1, &block); end

  # Whether to typecast the empty string ('') to nil for columns that
  # are not string or blob.  In most cases the empty string would be the
  # way to specify a NULL SQL value in string form (nil.to_s == ''),
  # and an empty string would not usually be typecast correctly for other
  # types, so the default is true.
  #
  # source://sequel//lib/sequel/model/base.rb#105
  def typecast_empty_string_to_nil; end

  # Whether to typecast the empty string ('') to nil for columns that
  # are not string or blob.  In most cases the empty string would be the
  # way to specify a NULL SQL value in string form (nil.to_s == ''),
  # and an empty string would not usually be typecast correctly for other
  # types, so the default is true.
  #
  # source://sequel//lib/sequel/model/base.rb#105
  def typecast_empty_string_to_nil=(_arg0); end

  # Whether to typecast attribute values on assignment (default: true).
  # If set to false, no typecasting is done, so it will be left up to the
  # database to typecast the value correctly.
  #
  # source://sequel//lib/sequel/model/base.rb#110
  def typecast_on_assignment; end

  # Whether to typecast attribute values on assignment (default: true).
  # If set to false, no typecasting is done, so it will be left up to the
  # database to typecast the value correctly.
  #
  # source://sequel//lib/sequel/model/base.rb#110
  def typecast_on_assignment=(_arg0); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def unfiltered(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def ungraphed(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def ungrouped(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def union(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def unlimited(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def unordered(*args, **_arg1, &block); end

  # Allow the setting of the primary key(s) when using the mass assignment methods.
  # Using this method can open up security issues, be very careful before using it.
  #
  #   Artist.set(id: 1) # Error
  #   Artist.unrestrict_primary_key
  #   Artist.set(id: 1) # No Error
  #
  # source://sequel//lib/sequel/model/base.rb#664
  def unrestrict_primary_key; end

  # Whether to use a transaction by default when saving/deleting records (default: true).
  # If you are sending database queries in before_* or after_* hooks, you shouldn't change
  # the default setting without a good reason.
  #
  # source://sequel//lib/sequel/model/base.rb#115
  def use_transactions; end

  # Whether to use a transaction by default when saving/deleting records (default: true).
  # If you are sending database queries in before_* or after_* hooks, you shouldn't change
  # the default setting without a good reason.
  #
  # source://sequel//lib/sequel/model/base.rb#115
  def use_transactions=(_arg0); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def where(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def where_all(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def where_each(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def where_single_value(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def with(*args, **_arg1, &block); end

  # Return the model instance with the primary key, or nil if there is no matching record.
  #
  # source://sequel//lib/sequel/model/base.rb#670
  def with_pk(pk); end

  # Return the model instance with the primary key, or raise NoMatchingRow if there is no matching record.
  #
  # source://sequel//lib/sequel/model/base.rb#675
  def with_pk!(pk); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def with_recursive(*args, **_arg1, &block); end

  # source://sequel//lib/sequel/model/plugins.rb#33
  def with_sql(*args, **_arg1, &block); end

  private

  # Yield to the passed block and if do_raise is false, swallow Sequel::Errors other than DatabaseConnectionError
  # and DatabaseDisconnectError.
  #
  # source://sequel//lib/sequel/model/base.rb#686
  def check_non_connection_error(do_raise = T.unsafe(nil)); end

  # Convert the given object to a Dataset that should be used as
  # this model's dataset.
  #
  # source://sequel//lib/sequel/model/base.rb#696
  def convert_input_dataset(ds); end

  # Add the module to the class's dataset_method_modules.  Extend the dataset with the
  # module if the model has a dataset.  Add dataset methods to the class for all
  # public dataset methods.
  #
  # source://sequel//lib/sequel/model/base.rb#721
  def dataset_extend(mod, opts = T.unsafe(nil)); end

  # Create a column accessor for a column with a method name that is hard to use in ruby code.
  #
  # source://sequel//lib/sequel/model/base.rb#731
  def def_bad_column_accessor(column); end

  # Create the column accessors.  For columns that can be used as method names directly in ruby code,
  # use a string to define the method for speed.  For other columns names, use a block.
  #
  # source://sequel//lib/sequel/model/base.rb#748
  def def_column_accessor(*columns); end

  # Define a model method that calls the dataset method with the same name,
  # only used for methods with names that can't be represented directly in
  # ruby code.
  #
  # source://sequel//lib/sequel/model/base.rb#769
  def def_model_dataset_method(meth); end

  # Get the schema from the database, fall back on checking the columns
  # via the database if that will return inaccurate results or if
  # it raises an error.
  #
  # source://sequel//lib/sequel/model/base.rb#786
  def get_db_schema(reload = T.unsafe(nil)); end

  # Get the array of schema information for the dataset.  Returns nil if
  # the schema information cannot be determined.
  #
  # source://sequel//lib/sequel/model/base.rb#831
  def get_db_schema_array(reload); end

  # Uncached version of setter_methods, to be overridden by plugins
  # that want to modify the methods used.
  #
  # source://sequel//lib/sequel/model/base.rb#837
  def get_setter_methods; end

  # If possible, set the dataset for the model subclass as soon as it
  # is created.  Also, make sure the inherited class instance variables
  # are copied into the subclass.
  #
  # Sequel queries the database to get schema information as soon as
  # a model class is created:
  #
  #   class Artist < Sequel::Model # Causes schema query
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#852
  def inherited(subclass); end

  # A hash of instance variables to automatically set up in subclasses.
  # Keys are instance variable symbols, values should be:
  # nil :: Assign directly from superclass to subclass (frozen objects)
  # :dup :: Dup object when assigning from superclass to subclass (mutable objects)
  # :hash_dup :: Assign hash with same keys, but dup all the values
  # Proc :: Call with subclass to do the assignment
  #
  # source://sequel//lib/sequel/model/base.rb#889
  def inherited_instance_variables; end

  # For the given opts hash and default name or :class option, add a
  # :class_name option unless already present which contains the name
  # of the class to use as a string.  The purpose is to allow late
  # binding to the class later using constantize.
  #
  # source://sequel//lib/sequel/model/base.rb#919
  def late_binding_class_option(opts, default); end

  # Clear the setter_methods cache when a setter method is added.
  #
  # source://sequel//lib/sequel/model/base.rb#938
  def method_added(meth); end

  # Module that the class includes that holds methods the class adds for column accessors and
  # associations so that the methods can be overridden with +super+.
  #
  # source://sequel//lib/sequel/model/base.rb#945
  def overridable_methods_module; end

  # Returns the module for the specified plugin. If the module is not
  # defined, the corresponding plugin required.
  #
  # source://sequel//lib/sequel/model/base.rb#952
  def plugin_module(plugin); end

  # Find the row in the dataset that matches the primary key.  Uses
  # a static SQL optimization if the table and primary key are simple.
  #
  # This method should not be called with a nil primary key, in case
  # it is overridden by plugins which assume that the passed argument
  # is valid.
  #
  # source://sequel//lib/sequel/model/base.rb#966
  def primary_key_lookup(pk); end

  # Whether to reload the database schema by default, ignoring any cached value.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#979
  def reload_db_schema?; end

  # Reset the cached fast primary lookup SQL if a simple table and primary key
  # are used, or set it to nil if not used.
  #
  # source://sequel//lib/sequel/model/base.rb#985
  def reset_fast_pk_lookup_sql; end

  # Reset the instance dataset to a modified copy of the current dataset,
  # should be used whenever the model's dataset is modified.
  #
  # source://sequel//lib/sequel/model/base.rb#996
  def reset_instance_dataset; end

  # Set the columns for this model and create accessor methods for each column.
  #
  # source://sequel//lib/sequel/model/base.rb#1001
  def set_columns(new_columns); end

  # Set the dataset's row_proc to the current model.
  #
  # source://sequel//lib/sequel/model/base.rb#1008
  def set_dataset_row_proc(ds); end

  # Reset the fast primary key lookup SQL when the simple_pk value changes.
  #
  # source://sequel//lib/sequel/model/base.rb#1013
  def simple_pk=(pk); end

  # Reset the fast primary key lookup SQL when the simple_table value changes.
  #
  # source://sequel//lib/sequel/model/base.rb#1019
  def simple_table=(t); end
end

# DatasetMethods contains methods that all model datasets have.
#
# source://sequel//lib/sequel/model/base.rb#2120
module Sequel::Model::DatasetMethods
  # Assume if a single integer is given that it is a lookup by primary
  # key, and call with_pk with the argument.
  #
  #   Artist.dataset[1] # SELECT * FROM artists WHERE (id = 1) LIMIT 1
  #
  # source://sequel//lib/sequel/model/base.rb#2132
  def [](*args); end

  # This allows you to call +as_hash+ without any arguments, which will
  # result in a hash with the primary key value being the key and the
  # model object being the value.
  #
  #   Artist.dataset.as_hash # SELECT * FROM artists
  #   # => {1=>#<Artist {:id=>1, ...}>,
  #   #     2=>#<Artist {:id=>2, ...}>,
  #   #     ...}
  #
  # source://sequel//lib/sequel/model/base.rb#2191
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Destroy each row in the dataset by instantiating it and then calling
  # destroy on the resulting model object.  This isn't as fast as deleting
  # the dataset, which does a single SQL call, but this runs any destroy
  # hooks on each object in the dataset.
  #
  #   Artist.dataset.destroy
  #   # DELETE FROM artists WHERE (id = 1)
  #   # DELETE FROM artists WHERE (id = 2)
  #   # ...
  #
  # source://sequel//lib/sequel/model/base.rb#2149
  def destroy; end

  # If there is no order already defined on this dataset, order it by
  # the primary key and call last.
  #
  #   Album.last
  #   # SELECT * FROM albums ORDER BY id DESC LIMIT 1
  #
  # source://sequel//lib/sequel/model/base.rb#2159
  def last(*a, &block); end

  # The model class associated with this dataset
  #
  #   Artist.dataset.model # => Artist
  #
  # source://sequel//lib/sequel/model/base.rb#2124
  def model; end

  # If there is no order already defined on this dataset, order it by
  # the primary key and call paged_each.
  #
  #   Album.paged_each{|row| }
  #   # SELECT * FROM albums ORDER BY id LIMIT 1000 OFFSET 0
  #   # SELECT * FROM albums ORDER BY id LIMIT 1000 OFFSET 1000
  #   # SELECT * FROM albums ORDER BY id LIMIT 1000 OFFSET 2000
  #   # ...
  #
  # source://sequel//lib/sequel/model/base.rb#2175
  def paged_each(*a, &block); end

  # Alias of as_hash for backwards compatibility.
  #
  # source://sequel//lib/sequel/model/base.rb#2201
  def to_hash(*a); end

  # Given a primary key value, return the first record in the dataset with that primary key
  # value.  If no records matches, returns nil.
  #
  #   # Single primary key
  #   Artist.dataset.with_pk(1)
  #   # SELECT * FROM artists WHERE (artists.id = 1) LIMIT 1
  #
  #   # Composite primary key
  #   Artist.dataset.with_pk([1, 2])
  #   # SELECT * FROM artists WHERE ((artists.id1 = 1) AND (artists.id2 = 2)) LIMIT 1
  #
  # source://sequel//lib/sequel/model/base.rb#2215
  def with_pk(pk); end

  # Same as with_pk, but raises NoMatchingRow instead of returning nil if no
  # row matches.
  #
  # source://sequel//lib/sequel/model/base.rb#2225
  def with_pk!(pk); end

  private

  # If the dataset is not already ordered, and the model has a primary key,
  # return a clone ordered by the primary key.
  #
  # source://sequel//lib/sequel/model/base.rb#2233
  def _primary_key_order; end

  # A cached placeholder literalizer, if one exists for the current dataset.
  #
  # source://sequel//lib/sequel/model/base.rb#2240
  def _with_pk_loader; end

  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#2256
  def non_sql_option?(key); end
end

# This Module subclass is used by Model.dataset_module
# to add dataset methods to classes.  In addition to the
# methods offered by Dataset::DatasetModule, it also
# automatically creates class methods for public dataset
# methods.
#
# source://sequel//lib/sequel/model/dataset_module.rb#10
class Sequel::Model::DatasetModule < ::Sequel::Dataset::DatasetModule
  # Store the model related to this dataset module.
  #
  # @return [DatasetModule] a new instance of DatasetModule
  #
  # source://sequel//lib/sequel/model/dataset_module.rb#15
  def initialize(model); end

  # The model class related to this dataset module.
  #
  # source://sequel//lib/sequel/model/dataset_module.rb#12
  def model; end

  # Alias for where.
  #
  # source://sequel//lib/sequel/model/dataset_module.rb#20
  def subset(name, *args, &block); end

  private

  # Add a class method to the related model that
  # calls the dataset method of the same name.
  #
  # source://sequel//lib/sequel/model/dataset_module.rb#28
  def method_added(meth); end
end

# Errors represents validation errors, a simple hash subclass
# with a few convenience methods.
#
# source://sequel//lib/sequel/model/errors.rb#7
class Sequel::Model::Errors < ::Hash
  # Adds an error for the given attribute.
  #
  #   errors.add(:name, 'is not valid') if name == 'invalid'
  #
  # source://sequel//lib/sequel/model/errors.rb#11
  def add(att, msg); end

  # Return the total number of error messages.
  #
  #   errors.count # => 3
  #
  # source://sequel//lib/sequel/model/errors.rb#18
  def count; end

  # Return true if there are no error messages, false otherwise.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/errors.rb#23
  def empty?; end

  # Returns an array of fully-formatted error messages.
  #
  #   errors.full_messages
  #   # => ['name is not valid',
  #   #     'hometown is not at least 2 letters']
  #
  # If the message is a Sequel::LiteralString, it will be used literally, without the column name:
  #
  #   errors.add(:name, Sequel.lit("Album name is not valid"))
  #   errors.full_messages
  #   # => ['Album name is not valid']
  #
  # source://sequel//lib/sequel/model/errors.rb#38
  def full_messages; end

  # Returns the array of errors for the given attribute, or nil
  # if there are no errors for the attribute.
  #
  #   errors.on(:name) # => ['name is not valid']
  #   errors.on(:id) # => nil
  #
  # source://sequel//lib/sequel/model/errors.rb#51
  def on(att); end

  private

  # Create full error message to use for the given attribute (or array of attributes)
  # and error message. This can be overridden for easier internalization.
  #
  # source://sequel//lib/sequel/model/errors.rb#61
  def full_message(att, error_msg); end
end

# Empty instance methods to create that the user can override.
# Just like any other method defined by Sequel, if you override one of these, you should
# call +super+ to get the default behavior (while empty by default, they are often overridden
# by plugins).  See the {"Model Hooks" guide}[rdoc-ref:doc/model_hooks.rdoc] for
# more detail on hooks.
#
# source://sequel//lib/sequel/model.rb#28
Sequel::Model::HOOKS = T.let(T.unsafe(nil), Array)

# Sequel::Model instance methods that implement basic model functionality.
#
# * All of the model before/after/around hooks are implemented as instance methods that are called
#   by Sequel when the appropriate action occurs.  For example, when destroying
#   a model object, Sequel will call +around_destroy+, which will call +before_destroy+, do
#   the destroy, and then call +after_destroy+.
# * The following instance_methods all call the class method of the same
#   name: columns, db, primary_key, db_schema.
# * The following accessor methods are defined via metaprogramming:
#   raise_on_save_failure, raise_on_typecast_failure, require_modification,
#   strict_param_setting, typecast_empty_string_to_nil, typecast_on_assignment,
#   and use_transactions.  The setter methods will change the setting for the
#   instance, and the getter methods will check for an instance setting, then
#   try the class setting if no instance setting has been set.
#
# source://sequel//lib/sequel/model/base.rb#1045
module Sequel::Model::InstanceMethods
  # Creates new instance and passes the given values to set.
  # If a block is given, yield the instance to the block.
  #
  # Arguments:
  # values :: should be a hash to pass to set.
  #
  #   Artist.new(name: 'Bob')
  #
  #   Artist.new do |a|
  #     a.name = 'Bob'
  #   end
  #
  # @yield [_self]
  # @yieldparam _self [Sequel::Model::InstanceMethods] the object that the method was called on
  #
  # source://sequel//lib/sequel/model/base.rb#1099
  def initialize(values = T.unsafe(nil)); end

  # Alias of eql?
  #
  # source://sequel//lib/sequel/model/base.rb#1136
  def ==(obj); end

  # Case equality.  By default, checks equality of the primary key value, see
  # pk_equal?.
  #
  #   Artist[1] === Artist[1] # => true
  #   Artist.new === Artist.new # => false
  #   Artist[1].set(name: 'Bob') === Artist[1] # => true
  #
  # source://sequel//lib/sequel/model/base.rb#1146
  def ===(obj); end

  # Returns value of the column's attribute.
  #
  #   Artist[1][:id] #=> 1
  #
  # source://sequel//lib/sequel/model/base.rb#1111
  def [](column); end

  # Sets the value for the given column.  If typecasting is enabled for
  # this object, typecast the value based on the column's type.
  # If this is a new record or the typecasted value isn't the same
  # as the current value for the column, mark the column as changed.
  #
  #   a = Artist.new
  #   a[:name] = 'Bob'
  #   a.values #=> {:name=>'Bob'}
  #
  # source://sequel//lib/sequel/model/base.rb#1123
  def []=(column, value); end

  # source://sequel//lib/sequel/model/base.rb#1046
  def after_create; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def after_destroy; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def after_save; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def after_update; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def after_validation; end

  # source://sequel//lib/sequel/model/base.rb#1047
  def around_create; end

  # source://sequel//lib/sequel/model/base.rb#1047
  def around_destroy; end

  # source://sequel//lib/sequel/model/base.rb#1047
  def around_save; end

  # source://sequel//lib/sequel/model/base.rb#1047
  def around_update; end

  # source://sequel//lib/sequel/model/base.rb#1047
  def around_validation; end

  # The autoincrementing primary key for this model object. Should be
  # overridden if you have a composite primary key with one part of it
  # being autoincrementing.
  #
  # source://sequel//lib/sequel/model/base.rb#1178
  def autoincrementing_primary_key; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def before_create; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def before_destroy; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def before_save; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def before_update; end

  # source://sequel//lib/sequel/model/base.rb#1046
  def before_validation; end

  # Cancel the current action.  Should be called in before hooks to halt
  # the processing of the action.  If a +msg+ argument is given and
  # the model instance is configured to raise exceptions on failure,
  # sets the message to use for the raised HookFailed exception.
  #
  # source://sequel//lib/sequel/model/base.rb#1186
  def cancel_action(msg = T.unsafe(nil)); end

  # The columns that have been updated.  This isn't completely accurate,
  # as it could contain columns whose values have not changed.
  #
  #   a = Artist[1]
  #   a.changed_columns # => []
  #   a.name = 'Bob'
  #   a.changed_columns # => [:name]
  #
  # source://sequel//lib/sequel/model/base.rb#1197
  def changed_columns; end

  # source://sequel//lib/sequel/model/base.rb#1053
  def columns; end

  # source://sequel//lib/sequel/model/base.rb#1053
  def db; end

  # source://sequel//lib/sequel/model/base.rb#1053
  def db_schema; end

  # Deletes and returns +self+.  Does not run destroy hooks.
  # Look into using +destroy+ instead.
  #
  #   Artist[1].delete # DELETE FROM artists WHERE (id = 1)
  #   # => #<Artist {:id=>1, ...}>
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1206
  def delete; end

  # Like delete but runs hooks before and after delete.
  # Uses a transaction if use_transactions is true or if the
  # :transaction option is given and true.
  #
  #   Artist[1].destroy # BEGIN; DELETE FROM artists WHERE (id = 1); COMMIT;
  #   # => #<Artist {:id=>1, ...}>
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1218
  def destroy(opts = T.unsafe(nil)); end

  # Iterates through all of the current values using each.
  #
  #  Album[1].each{|k, v| puts "#{k} => #{v}"}
  #  # id => 1
  #  # name => 'Bob'
  #
  # source://sequel//lib/sequel/model/base.rb#1228
  def each(&block); end

  # Compares model instances by values.
  #
  #   Artist[1] == Artist[1] # => true
  #   Artist.new == Artist.new # => true
  #   Artist[1].set(name: 'Bob') == Artist[1] # => false
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1237
  def eql?(obj); end

  # Returns the validation errors associated with this object.
  # See +Errors+.
  #
  # source://sequel//lib/sequel/model/base.rb#1243
  def errors; end

  # Returns true when current instance exists, false otherwise.
  # Generally an object that isn't new will exist unless it has
  # been deleted.  Uses a database query to check for existence,
  # unless the model object is new, in which case this is always
  # false.
  #
  #   Artist[1].exists? # SELECT 1 FROM artists WHERE (id = 1)
  #   # => true
  #   Artist.new.exists?
  #   # => false
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1257
  def exists?; end

  # Ignore the model's setter method cache when this instances extends a module, as the
  # module may contain setter methods.
  #
  # source://sequel//lib/sequel/model/base.rb#1263
  def extend(mod); end

  # Freeze the object in such a way that it is still usable but not modifiable.
  # Once an object is frozen, you cannot modify it's values, changed_columns,
  # errors, or dataset.
  #
  # source://sequel//lib/sequel/model/base.rb#1271
  def freeze; end

  # Get the value of the column.  Takes a single symbol or string argument.
  # By default it calls send with the argument to get the value.  This can
  # be overridden if you have columns that conflict with existing
  # method names.
  def get_column_value(*_arg0); end

  # Value that should be unique for objects with the same class and pk (if pk is not nil), or
  # the same class and values (if pk is nil).
  #
  #   Artist[1].hash == Artist[1].hash # true
  #   Artist[1].set(name: 'Bob').hash == Artist[1].hash # true
  #   Artist.new.hash == Artist.new.hash # true
  #   Artist.new(name: 'Bob').hash == Artist.new.hash # false
  #
  # source://sequel//lib/sequel/model/base.rb#1289
  def hash; end

  # Returns value for the :id attribute, even if the primary key is
  # not id. To get the primary key value, use +pk+.
  #
  #   Artist[1].id # => 1
  #
  # source://sequel//lib/sequel/model/base.rb#1304
  def id; end

  # Returns a string representation of the model instance including
  # the class name and values.
  #
  # source://sequel//lib/sequel/model/base.rb#1310
  def inspect; end

  # Returns the keys in +values+.  May not include all column names.
  #
  #   Artist.new.keys # => []
  #   Artist.new(name: 'Bob').keys # => [:name]
  #   Artist[1].keys # => [:id, :name]
  #
  # source://sequel//lib/sequel/model/base.rb#1319
  def keys; end

  # Refresh this record using +for_update+ (by default, or the specified style when given)
  # unless this is a new record.  Returns self. This can be used to make sure no other
  # process is updating the record at the same time.
  #
  # If style is a string, it will be used directly. You should never pass a string
  # to this method that is derived from user input, as that can lead to
  # SQL injection.
  #
  # A symbol may be used for database independent locking behavior, but
  # all supported symbols have separate methods (e.g. for_update).
  #
  #
  #   a = Artist[1]
  #   Artist.db.transaction do
  #     a.lock!
  #     a.update(name: 'A')
  #   end
  #
  #   a = Artist[2]
  #   Artist.db.transaction do
  #     a.lock!('FOR NO KEY UPDATE')
  #     a.update(name: 'B')
  #   end
  #
  # source://sequel//lib/sequel/model/base.rb#1346
  def lock!(style = T.unsafe(nil)); end

  # Remove elements of the model object that make marshalling fail. Returns self.
  #
  #   a = Artist[1]
  #   a.marshallable!
  #   Marshal.dump(a)
  #
  # source://sequel//lib/sequel/model/base.rb#1356
  def marshallable!; end

  # class is defined in Object, but it is also a keyword,
  # and since a lot of instance methods call class methods,
  # this alias makes it so you can use model instead of
  # self.class.
  #
  #   Artist.new.model # => Artist
  def model; end

  # Explicitly mark the object as modified, so +save_changes+/+update+ will
  # run callbacks even if no columns have changed.
  #
  #   a = Artist[1]
  #   a.save_changes # No callbacks run, as no changes
  #   a.modified!
  #   a.save_changes # Callbacks run, even though no changes made
  #
  # If a column is given, specifically marked that column as modified,
  # so that +save_changes+/+update+ will include that column in the
  # update. This should be used if you plan on mutating the column
  # value instead of assigning a new column value:
  #
  #   a.modified!(:name)
  #   a.name.gsub!(/[aeou]/, 'i')
  #
  # source://sequel//lib/sequel/model/base.rb#1376
  def modified!(column = T.unsafe(nil)); end

  # Whether this object has been modified since last saved, used by
  # save_changes to determine whether changes should be saved.  New
  # values are always considered modified.
  #
  #   a = Artist[1]
  #   a.modified? # => false
  #   a.set(name: 'Jim')
  #   a.modified? # => true
  #
  # If a column is given, specifically check if the given column has
  # been modified:
  #
  #   a.modified?(:num_albums) # => false
  #   a.num_albums = 10
  #   a.modified?(:num_albums) # => true
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1396
  def modified?(column = T.unsafe(nil)); end

  # Returns true if the current instance represents a new record.
  #
  #   Artist.new.new? # => true
  #   Artist[1].new? # => false
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1408
  def new?; end

  # Returns the primary key value identifying the model instance.
  # Raises an +Error+ if this model does not have a primary key.
  # If the model has a composite primary key, returns an array of values.
  #
  #   Artist[1].pk # => 1
  #   Artist[[1, 2]].pk # => [1, 2]
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1418
  def pk; end

  # Case equality.  By default, checks equality of the primary key value, see
  # pk_equal?.
  #
  #   Artist[1] === Artist[1] # => true
  #   Artist.new === Artist.new # => false
  #   Artist[1].set(name: 'Bob') === Artist[1] # => true
  # If the receiver has a primary key value, returns true if the objects have
  # the same class and primary key value.
  # If the receiver's primary key value is nil or is an array containing
  # nil, returns false.
  #
  #   Artist[1].pk_equal?(Artist[1]) # => true
  #   Artist.new.pk_equal?(Artist.new) # => false
  #   Artist[1].set(name: 'Bob').pk_equal?(Artist[1]) # => true
  #
  # source://sequel//lib/sequel/model/base.rb#1146
  def pk_equal?(obj); end

  # Returns a hash mapping the receivers primary key column(s) to their values.
  #
  #   Artist[1].pk_hash # => {:id=>1}
  #   Artist[[1, 2]].pk_hash # => {:id1=>1, :id2=>2}
  #
  # source://sequel//lib/sequel/model/base.rb#1432
  def pk_hash; end

  # source://sequel//lib/sequel/model/base.rb#1053
  def primary_key; end

  # Returns a hash mapping the receivers qualified primary key column(s) to their values.
  #
  #   Artist[1].qualified_pk_hash
  #   # => {Sequel[:artists][:id]=>1}
  #   Artist[[1, 2]].qualified_pk_hash
  #   # => {Sequel[:artists][:id1]=>1, Sequel[:artists][:id2]=>2}
  #
  # source://sequel//lib/sequel/model/base.rb#1442
  def qualified_pk_hash(qualifier = T.unsafe(nil)); end

  # source://sequel//lib/sequel/model/base.rb#1060
  def raise_on_save_failure; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def raise_on_save_failure=(_arg0); end

  # source://sequel//lib/sequel/model/base.rb#1060
  def raise_on_typecast_failure; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def raise_on_typecast_failure=(_arg0); end

  # Reloads attributes from database and returns self. Also clears all
  # changed_columns information.  Raises an +Error+ if the record no longer
  # exists in the database.
  #
  #   a = Artist[1]
  #   a.name = 'Jim'
  #   a.refresh
  #   a.name # => 'Bob'
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1454
  def refresh; end

  # Alias of refresh, but not aliased directly to make overriding in a plugin easier.
  #
  # source://sequel//lib/sequel/model/base.rb#1461
  def reload; end

  # source://sequel//lib/sequel/model/base.rb#1060
  def require_modification; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def require_modification=(_arg0); end

  # Creates or updates the record, after making sure the record
  # is valid and before hooks execute successfully. Fails if:
  #
  # * the record is not valid, or
  # * before_save calls cancel_action, or
  # * the record is new and before_create calls cancel_action, or
  # * the record is not new and before_update calls cancel_action.
  #
  # If +save+ fails and either raise_on_save_failure or the
  # :raise_on_failure option is true, it raises ValidationFailed
  # or HookFailed. Otherwise it returns nil.
  #
  # If it succeeds, it returns self.
  #
  # Takes the following options:
  #
  # :changed :: save all changed columns, instead of all columns or the columns given
  # :columns :: array of specific columns that should be saved.
  # :raise_on_failure :: set to true or false to override the current
  #                      +raise_on_save_failure+ setting
  # :server :: set the server/shard on the object before saving, and use that
  #            server/shard in any transaction.
  # :transaction :: set to true or false to override the current
  #                 +use_transactions+ setting
  # :validate :: set to false to skip validation
  #
  # @raise [Sequel::Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1490
  def save(opts = T.unsafe(nil)); end

  # Saves only changed columns if the object has been modified.
  # If the object has not been modified, returns nil.  If unable to
  # save, returns false unless +raise_on_save_failure+ is true.
  #
  #   a = Artist[1]
  #   a.save_changes # => nil
  #   a.name = 'Jim'
  #   a.save_changes # UPDATE artists SET name = 'Bob' WHERE (id = 1)
  #   # => #<Artist {:id=>1, :name=>'Jim', ...}
  #
  # source://sequel//lib/sequel/model/base.rb#1509
  def save_changes(opts = T.unsafe(nil)); end

  # Updates the instance with the supplied values with support for virtual
  # attributes, raising an exception if a value is used that doesn't have
  # a setter method (or ignoring it if <tt>strict_param_setting = false</tt>).
  # Does not save the record.
  #
  #   artist.set(name: 'Jim')
  #   artist.name # => 'Jim'
  #
  # source://sequel//lib/sequel/model/base.rb#1520
  def set(hash); end

  # Set the value of the column.  Takes two arguments.  The first is a
  # symbol or string argument for the column name, suffixed with =.  The
  # second is the value to set for the column.  By default it calls send
  # with the argument to set the value.  This can be overridden if you have
  # columns that conflict with existing method names (unlikely for setter
  # methods, but possible).
  def set_column_value(*_arg0); end

  # For each of the fields in the given array +fields+, call the setter
  # method with the value of that +hash+ entry for the field. Returns self.
  #
  # You can provide an options hash, with the following options currently respected:
  # :missing :: Can be set to :skip to skip missing entries or :raise to raise an
  #             Error for missing entries.  The default behavior is not to check for
  #             missing entries, in which case the default value is used.  To be
  #             friendly with most web frameworks, the missing check will also check
  #             for the string version of the argument in the hash if given a symbol.
  #
  # Examples:
  #
  #   artist.set_fields({name: 'Jim'}, [:name])
  #   artist.name # => 'Jim'
  #
  #   artist.set_fields({hometown: 'LA'}, [:name])
  #   artist.name # => nil
  #   artist.hometown # => 'Sac'
  #
  #   artist.name # => 'Jim'
  #   artist.set_fields({}, [:name], missing: :skip)
  #   artist.name # => 'Jim'
  #
  #   artist.name # => 'Jim'
  #   artist.set_fields({}, [:name], missing: :raise)
  #   # Sequel::Error raised
  #
  # source://sequel//lib/sequel/model/base.rb#1550
  def set_fields(hash, fields, opts = T.unsafe(nil)); end

  # Set the shard that this object is tied to.  Returns self.
  #
  # source://sequel//lib/sequel/model/base.rb#1576
  def set_server(s); end

  # Clear the setter_methods cache when a method is added
  #
  # source://sequel//lib/sequel/model/base.rb#1583
  def singleton_method_added(meth); end

  # Skip all validation of the object on the next call to #save,
  # including the running of validation hooks. This is designed for
  # and should only be used in cases where #valid? is called before
  # saving and the <tt>validate: false</tt> option cannot be passed to
  # #save.
  #
  # source://sequel//lib/sequel/model/base.rb#1593
  def skip_validation_on_next_save!; end

  # source://sequel//lib/sequel/model/base.rb#1060
  def strict_param_setting; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def strict_param_setting=(_arg0); end

  # Returns (naked) dataset that should return only this instance.
  #
  #   Artist[1].this
  #   # SELECT * FROM artists WHERE (id = 1) LIMIT 1
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/model/base.rb#1601
  def this; end

  # The hash of attribute values.  Keys are symbols with the names of the
  # underlying database columns. The returned hash is a reference to the
  # receiver's values hash, and modifying it will also modify the receiver's
  # values.
  #
  #   Artist.new(name: 'Bob').values # => {:name=>'Bob'}
  #   Artist[1].values # => {:id=>1, :name=>'Jim', ...}
  def to_hash; end

  # source://sequel//lib/sequel/model/base.rb#1060
  def typecast_empty_string_to_nil; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def typecast_empty_string_to_nil=(_arg0); end

  # source://sequel//lib/sequel/model/base.rb#1060
  def typecast_on_assignment; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def typecast_on_assignment=(_arg0); end

  # Runs #set with the passed hash and then runs save_changes.
  #
  #   artist.update(name: 'Jim') # UPDATE artists SET name = 'Jim' WHERE (id = 1)
  #
  # source://sequel//lib/sequel/model/base.rb#1610
  def update(hash); end

  # Update the instance's values by calling set_fields with the arguments, then
  # calls save_changes.
  #
  #   artist.update_fields({name: 'Jim'}, [:name])
  #   # UPDATE artists SET name = 'Jim' WHERE (id = 1)
  #
  #   artist.update_fields({hometown: 'LA'}, [:name])
  #   # UPDATE artists SET name = NULL WHERE (id = 1)
  #
  # source://sequel//lib/sequel/model/base.rb#1622
  def update_fields(hash, fields, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/model/base.rb#1060
  def use_transactions; end

  # source://sequel//lib/sequel/model/base.rb#1061
  def use_transactions=(_arg0); end

  # Validates the object and returns true if no errors are reported.
  #
  #   artist.set(name: 'Valid').valid? # => true
  #   artist.set(name: 'Invalid').valid? # => false
  #   artist.errors.full_messages # => ['name cannot be Invalid']
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1641
  def valid?(opts = T.unsafe(nil)); end

  # Validates the object.  If the object is invalid, errors should be added
  # to the errors attribute.  By default, does nothing, as all models
  # are valid by default.  See the {"Model Validations" guide}[rdoc-ref:doc/validations.rdoc].
  # for details about validation.  Should not be called directly by
  # user code, call <tt>valid?</tt> instead to check if an object
  # is valid.
  #
  # source://sequel//lib/sequel/model/base.rb#1633
  def validate; end

  # The hash of attribute values.  Keys are symbols with the names of the
  # underlying database columns. The returned hash is a reference to the
  # receiver's values hash, and modifying it will also modify the receiver's
  # values.
  #
  #   Artist.new(name: 'Bob').values # => {:name=>'Bob'}
  #   Artist[1].values # => {:id=>1, :name=>'Jim', ...}
  #
  # source://sequel//lib/sequel/model/base.rb#1071
  def values; end

  private

  # Add a column as a changed column.
  #
  # source://sequel//lib/sequel/model/base.rb#1650
  def _add_changed_column(column); end

  # Internal changed_columns method that just returns stored array.
  #
  # source://sequel//lib/sequel/model/base.rb#1656
  def _changed_columns; end

  # Clear the changed columns. Reason is the reason for clearing
  # the columns, and should be one of: :initialize, :refresh, :create
  # or :update.
  #
  # source://sequel//lib/sequel/model/base.rb#1663
  def _clear_changed_columns(_reason); end

  # Do the deletion of the object's dataset, and check that the row
  # was actually deleted.
  #
  # @raise [NoExistingObject]
  #
  # source://sequel//lib/sequel/model/base.rb#1669
  def _delete; end

  # The dataset to use when deleting the object.  The same as the object's
  # dataset by default.
  #
  # source://sequel//lib/sequel/model/base.rb#1677
  def _delete_dataset; end

  # Actually do the deletion of the object's dataset.  Return the
  # number of rows modified.
  #
  # source://sequel//lib/sequel/model/base.rb#1683
  def _delete_without_checking; end

  # Internal destroy method, separted from destroy to
  # allow running inside a transaction
  #
  # source://sequel//lib/sequel/model/base.rb#1696
  def _destroy(opts); end

  # Internal delete method to call when destroying an object,
  # separated from delete to allow you to override destroy's version
  # without affecting delete.
  #
  # source://sequel//lib/sequel/model/base.rb#1711
  def _destroy_delete; end

  # Insert the record into the database, returning the primary key if
  # the record should be refreshed from the database.
  #
  # source://sequel//lib/sequel/model/base.rb#1717
  def _insert; end

  # The dataset to use when inserting a new object.   The same as the model's
  # dataset by default.
  #
  # source://sequel//lib/sequel/model/base.rb#1735
  def _insert_dataset; end

  # Insert into the given dataset and return the primary key created (if any).
  #
  # source://sequel//lib/sequel/model/base.rb#1740
  def _insert_raw(ds); end

  # Insert into the given dataset and return the hash of column values.
  #
  # source://sequel//lib/sequel/model/base.rb#1745
  def _insert_select_raw(ds); end

  # The hash of attribute values.  Keys are symbols with the names of the
  # underlying database columns. The returned hash is a reference to the
  # receiver's values hash, and modifying it will also modify the receiver's
  # values.
  #
  #   Artist.new(name: 'Bob').values # => {:name=>'Bob'}
  #   Artist[1].values # => {:id=>1, :name=>'Jim', ...}
  # The values hash to use when inserting a new record.
  def _insert_values; end

  # Refresh using a particular dataset, used inside save to make sure the same server
  # is used for reading newly inserted values from the database
  #
  # source://sequel//lib/sequel/model/base.rb#1755
  def _refresh(dataset); end

  # Get the row of column data from the database.
  #
  # source://sequel//lib/sequel/model/base.rb#1761
  def _refresh_get(dataset); end

  # Set the values to the given hash after refreshing.
  #
  # source://sequel//lib/sequel/model/base.rb#1773
  def _refresh_set_values(h); end

  # Internal version of save, split from save to allow running inside
  # it's own transaction.
  #
  # source://sequel//lib/sequel/model/base.rb#1779
  def _save(opts); end

  # Refresh the object after saving it, used to get
  # default values of all columns.  Separated from _save so it
  # can be overridden to avoid the refresh.
  #
  # source://sequel//lib/sequel/model/base.rb#1835
  def _save_refresh; end

  # Set values to the provided hash.  Called after a create,
  # to set the full values from the database in the model instance.
  #
  # source://sequel//lib/sequel/model/base.rb#1842
  def _save_set_values(h); end

  # Return a hash of values used when saving all columns of an
  # existing object (i.e. not passing specific columns to save
  # or using update/save_changes).  Defaults to all of the
  # object's values except unmodified primary key columns, as some
  # databases don't like you setting primary key values even
  # to their existing values.
  #
  # source://sequel//lib/sequel/model/base.rb#1852
  def _save_update_all_columns_hash; end

  # Return a hash of values used when saving changed columns of an
  # existing object.  Defaults to all of the objects current values
  # that are recorded as modified.
  #
  # source://sequel//lib/sequel/model/base.rb#1862
  def _save_update_changed_colums_hash; end

  # Validate the object if validating on save. Skips validation
  # completely (including validation hooks) if
  # skip_validation_on_save! has been called on the object,
  # resetting the flag so that future saves will validate.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1871
  def _save_valid?(opts); end

  # Update this instance's dataset with the supplied column hash,
  # checking that only a single row was modified.
  #
  # @raise [NoExistingObject]
  #
  # source://sequel//lib/sequel/model/base.rb#1889
  def _update(columns); end

  # Call _update with the given columns, if any are present.
  # Plugins can override this method in order to update with
  # additional columns, even when the column hash is initially empty.
  #
  # source://sequel//lib/sequel/model/base.rb#1883
  def _update_columns(columns); end

  # The dataset to use when updating an object.  The same as the object's
  # dataset by default.
  #
  # source://sequel//lib/sequel/model/base.rb#1897
  def _update_dataset; end

  # Update this instances dataset with the supplied column hash.
  #
  # source://sequel//lib/sequel/model/base.rb#1902
  def _update_without_checking(columns); end

  # Whether to use insert_select when inserting a new row.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1907
  def _use_insert_select?(ds); end

  # Internal validation method, running validation hooks.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#1912
  def _valid?(opts); end

  # Change the value of the column to given value, recording the change.
  #
  # source://sequel//lib/sequel/model/base.rb#1953
  def change_column_value(column, value); end

  # If not raising on failure, check for HookFailed
  # being raised by yielding and swallow it.
  #
  # source://sequel//lib/sequel/model/base.rb#1935
  def checked_save_failure(opts); end

  # If transactions should be used, wrap the yield in a transaction block.
  #
  # source://sequel//lib/sequel/model/base.rb#1948
  def checked_transaction(opts = T.unsafe(nil)); end

  # Default error class used for errors.
  #
  # source://sequel//lib/sequel/model/base.rb#1959
  def errors_class; end

  # A HookFailed exception for the given message tied to the current instance.
  #
  # source://sequel//lib/sequel/model/base.rb#1964
  def hook_failed_error(msg); end

  # Clone constructor -- freeze internal data structures if the original's
  # are frozen.
  #
  # source://sequel//lib/sequel/model/base.rb#1970
  def initialize_clone(other); end

  # Copy constructor -- Duplicate internal data structures.
  #
  # source://sequel//lib/sequel/model/base.rb#1977
  def initialize_copy(other); end

  # Set the columns with the given hash.  By default, the same as +set+, but
  # exists so it can be overridden.  This is called only for new records, before
  # changed_columns is cleared.
  #
  # source://sequel//lib/sequel/model/base.rb#1988
  def initialize_set(h); end

  # Default inspection output for the values hash, overwrite to change what #inspect displays.
  #
  # source://sequel//lib/sequel/model/base.rb#1993
  def inspect_values; end

  # Raise an error appropriate to the hook type. May be swallowed by
  # checked_save_failure depending on the raise_on_failure? setting.
  #
  # source://sequel//lib/sequel/model/base.rb#2007
  def raise_hook_failure(type = T.unsafe(nil)); end

  # Whether to raise or return false if this action fails. If the
  # :raise_on_failure option is present in the hash, use that, otherwise,
  # fallback to the object's raise_on_save_failure (if set), or
  # class's default (if not).
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#2001
  def raise_on_failure?(opts); end

  # Get the ruby class or classes related to the given column's type.
  #
  # source://sequel//lib/sequel/model/base.rb#2021
  def schema_type_class(column); end

  # Call setter methods based on keys in hash, with the appropriate values.
  # Restrict which methods can be called based on the provided type.
  #
  # source://sequel//lib/sequel/model/base.rb#2029
  def set_restricted(hash, type); end

  # Returns all methods that can be used for attribute assignment (those that end with =),
  # depending on the type:
  #
  # :default :: Use the default methods allowed in the model class.
  # :all :: Allow setting all setters, except those specifically restricted (such as ==).
  # Array :: Only allow setting of columns in the given array.
  #
  # source://sequel//lib/sequel/model/base.rb#2059
  def setter_methods(type); end

  # The server/shard that the model object's dataset uses, or :default if the
  # model object's dataset does not have an associated shard.
  #
  # source://sequel//lib/sequel/model/base.rb#2071
  def this_server; end

  # Typecast the value to the column's type if typecasting.  Calls the database's
  # typecast_value method, so database adapters can override/augment the handling
  # for database specific column types.
  #
  # @raise [InvalidValue]
  #
  # source://sequel//lib/sequel/model/base.rb#2084
  def typecast_value(column, value); end

  # Set the columns, filtered by the only and except arrays.
  #
  # source://sequel//lib/sequel/model/base.rb#2096
  def update_restricted(hash, type); end

  # Set the given dataset to use the current object's shard.
  #
  # source://sequel//lib/sequel/model/base.rb#2102
  def use_server(ds); end

  # Whether to use a transaction for this action.  If the :transaction
  # option is present in the hash, use that, otherwise, fallback to the
  # object's default (if set), or class's default (if not).
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/model/base.rb#2109
  def use_transaction?(opts = T.unsafe(nil)); end

  # An ValidationFailed exception instance to raise for this instance.
  #
  # source://sequel//lib/sequel/model/base.rb#2114
  def validation_failed_error; end
end

# source://sequel//lib/sequel/model.rb#21
Sequel::Model::OPTS = T.let(T.unsafe(nil), Hash)

# The setter methods (methods ending with =) that are never allowed
# to be called automatically via +set+/+update+/+new+/etc.
#
# source://sequel//lib/sequel/model.rb#83
Sequel::Model::RESTRICTED_SETTER_METHODS = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/model/exceptions.rb#19
class Sequel::NoExistingObject < ::Sequel::Error; end

# Error raised when the user requests a record via the first! or similar
# method, and the dataset does not yield any rows.
#
# source://sequel//lib/sequel/exceptions.rb#98
class Sequel::NoMatchingRow < ::Sequel::Error
  # If the first argument is a Sequel::Dataset, set the dataset related to
  # the exception to that argument, instead of assuming it is the exception message.
  #
  # @return [NoMatchingRow] a new instance of NoMatchingRow
  #
  # source://sequel//lib/sequel/exceptions.rb#104
  def initialize(msg = T.unsafe(nil)); end

  # The dataset that raised this NoMatchingRow exception.
  #
  # source://sequel//lib/sequel/exceptions.rb#100
  def dataset; end

  # The dataset that raised this NoMatchingRow exception.
  #
  # source://sequel//lib/sequel/exceptions.rb#100
  def dataset=(_arg0); end
end

# source://sequel//lib/sequel/exceptions.rb#65
class Sequel::NotNullConstraintViolation < ::Sequel::ConstraintViolation; end

# Frozen hash used as the default options hash for most options.
#
# source://sequel//lib/sequel/core.rb#37
Sequel::OPTS = T.let(T.unsafe(nil), Hash)

# Empty namespace that plugins should use to store themselves,
# so they can be loaded via Model.plugin.
#
# Plugins should be modules with one of the following conditions:
# * A singleton method named apply, which takes a model,
#   additional arguments, and an optional block.  This is called
#   the first time the plugin is loaded for this model (unless it was
#   already loaded by an ancestor class), before including/extending
#   any modules, with the arguments
#   and block provided to the call to Model.plugin.
# * A module inside the plugin module named ClassMethods,
#   which will extend the model class.
# * A module inside the plugin module named InstanceMethods,
#   which will be included in the model class.
# * A module inside the plugin module named DatasetMethods,
#   which will extend the model's dataset.
# * A singleton method named configure, which takes a model,
#   additional arguments, and an optional block.  This is called
#   every time the Model.plugin method is called, after including/extending
#   any modules.
#
# source://sequel//lib/sequel/model/plugins.rb#24
module Sequel::Plugins
  class << self
    # Add method to +mod+ that overrides set_dataset to call the method afterward.
    #
    # source://sequel//lib/sequel/model/plugins.rb#50
    def after_set_dataset(mod, meth); end

    # In the given module +mod+, define methods that are call the same method
    # on the dataset.  This is designed for plugins to define dataset methods
    # inside ClassMethods that call the implementations in DatasetMethods.
    #
    # This should not be called with untrusted input or method names that
    # can't be used literally, since it uses class_eval.
    #
    # source://sequel//lib/sequel/model/plugins.rb#31
    def def_dataset_methods(mod, meths); end

    # Define a private instance method using the block with the provided name and
    # expected arity.  If the name is given as a Symbol, it is used directly.
    # If the name is given as a String, a unique name will be generated using
    # that string.  The expected_arity should be either 0 (no arguments) or
    # 1 (single argument).
    #
    # If a block with an arity that does not match the expected arity is used,
    # a deprecation warning will be issued. The method defined should still
    # work, though it will be slower than a method with the expected arity.
    #
    # Sequel only checks arity for regular blocks, not lambdas.  Lambdas were
    # already strict in regards to arity, so there is no need to try to fix
    # arity to keep backwards compatibility for lambdas.
    #
    # Blocks with required keyword arguments are not supported by this method.
    #
    # source://sequel//lib/sequel/model/plugins.rb#81
    def def_sequel_method(model, meth, expected_arity, &block); end

    # Add method to +mod+ that overrides inherited_instance_variables to include the
    # values in this hash.
    #
    # source://sequel//lib/sequel/model/plugins.rb#42
    def inherited_instance_variables(mod, hash); end

    private

    # Return the number of required argument, optional arguments,
    # whether the callable accepts any additional arguments,
    # and whether the callable accepts keyword arguments (true, false
    # or :required).
    #
    # source://sequel//lib/sequel/model/plugins.rb#133
    def _define_sequel_method_arg_numbers(callable); end
  end
end

# Return a unique method name symbol for the given suffix.
#
# source://sequel//lib/sequel/model/plugins.rb#62
Sequel::Plugins::SEQUEL_METHOD_NAME = T.let(T.unsafe(nil), Proc)

# source://sequel//lib/sequel/exceptions.rb#116
class Sequel::PoolTimeout < ::Sequel::Error; end

# Handles qualifying existing datasets, so that unqualified columns
# in the dataset are qualified with a given table name.
#
# source://sequel//lib/sequel/ast_transformer.rb#97
class Sequel::Qualifier < ::Sequel::ASTTransformer
  # Set the table used to qualify unqualified columns
  #
  # @return [Qualifier] a new instance of Qualifier
  #
  # source://sequel//lib/sequel/ast_transformer.rb#99
  def initialize(table); end

  private

  # Turn <tt>SQL::Identifier</tt>s and symbols that aren't implicitly
  # qualified into <tt>SQL::QualifiedIdentifier</tt>s.  For symbols that
  # are not implicitly qualified by are implicitly aliased, return an
  # <tt>SQL::AliasedExpression</tt>s with a qualified version of the symbol.
  #
  # source://sequel//lib/sequel/ast_transformer.rb#109
  def v(o); end
end

# source://sequel//lib/sequel/exceptions.rb#123
class Sequel::Rollback < ::Sequel::Error; end

# Hash of shared adapters that have been registered.  The key is the
# adapter scheme symbol, and the value is the Sequel module containing
# the shared adapter.
#
# source://sequel//lib/sequel/database.rb#11
Sequel::SHARED_ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

# source://sequel//lib/sequel/core.rb#39
Sequel::SPLIT_SYMBOL_CACHE = T.let(T.unsafe(nil), Hash)

# The SQL module holds classes whose instances represent SQL fragments.
# It also holds modules that are used by these classes.
#
# source://sequel//lib/sequel/sql.rb#78
module Sequel::SQL; end

# Includes an +as+ method that creates an SQL alias.
#
# source://sequel//lib/sequel/sql.rb#255
module Sequel::SQL::AliasMethods
  # Create an SQL alias (+AliasedExpression+) of the receiving column or expression to the given alias.
  #
  #   Sequel.function(:func).as(:alias) # func() AS "alias"
  #   Sequel.function(:func).as(:alias, [:col_alias1, :col_alias2]) # func() AS "alias"("col_alias1", "col_alias2")
  #
  # source://sequel//lib/sequel/sql.rb#260
  def as(aliaz, columns = T.unsafe(nil)); end
end

# Represents an aliasing of an expression to a given alias.
#
# source://sequel//lib/sequel/sql.rb#996
class Sequel::SQL::AliasedExpression < ::Sequel::SQL::Expression
  # Create an object with the given expression, alias, and optional column aliases.
  #
  # @return [AliasedExpression] a new instance of AliasedExpression
  #
  # source://sequel//lib/sequel/sql.rb#1008
  def initialize(expression, aliaz, columns = T.unsafe(nil)); end

  # The alias to use for the expression.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def alias; end

  # The columns aliases (derived column list) to use, for when the aliased expression is
  # a record or set of records (such as a dataset).
  #
  # source://sequel//lib/sequel/sql.rb#93
  def columns; end

  # The expression to alias
  #
  # source://sequel//lib/sequel/sql.rb#93
  def expression; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# This defines the bitwise methods: &, |, ^, ~, <<, and >>.  Because these
# methods overlap with the standard +BooleanMethods methods+, and they only
# make sense for integers, they are only included in +NumericExpression+.
#
#   Sequel[:a].sql_number & :b # "a" & "b"
#   Sequel[:a].sql_number | :b # "a" | "b"
#   Sequel[:a].sql_number ^ :b # "a" ^ "b"
#   Sequel[:a].sql_number << :b # "a" << "b"
#   Sequel[:a].sql_number >> :b # "a" >> "b"
#   ~Sequel[:a].sql_number # ~"a"
#
# source://sequel//lib/sequel/sql.rb#275
module Sequel::SQL::BitwiseMethods
  # source://sequel//lib/sequel/sql.rb#277
  def %(o); end

  # source://sequel//lib/sequel/sql.rb#277
  def &(o); end

  # source://sequel//lib/sequel/sql.rb#277
  def <<(o); end

  # source://sequel//lib/sequel/sql.rb#277
  def >>(o); end

  # source://sequel//lib/sequel/sql.rb#277
  def ^(o); end

  # source://sequel//lib/sequel/sql.rb#277
  def |(o); end

  # Do the bitwise compliment of the self
  #
  #   ~(Sequel[:a].sql_number) # ~"a"
  #
  # source://sequel//lib/sequel/sql.rb#283
  def ~; end
end

# +Blob+ is used to represent binary data in the Ruby environment that is
# stored as a blob type in the database. Sequel represents binary data as a Blob object because
# most database engines require binary data to be escaped differently than regular strings.
#
# source://sequel//lib/sequel/sql.rb#1021
class Sequel::SQL::Blob < ::String
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods

  # Return a string showing that this is a blob, the size, and the some or all of the content,
  # depending on the size.
  #
  # source://sequel//lib/sequel/sql.rb#1038
  def inspect; end

  # Return a LiteralString with the same content if no args are given, otherwise
  # return a SQL::PlaceholderLiteralString with the current string and the given args.
  #
  # source://sequel//lib/sequel/sql.rb#1032
  def lit(*args); end

  # Returns +self+, since it is already a blob.
  #
  # source://sequel//lib/sequel/sql.rb#1051
  def to_sequel_blob; end

  class << self
    # Alias new to call for usage in conversion procs
    def call(*_arg0); end
  end
end

# Represents boolean constants such as +NULL+, +TRUE+, and +FALSE+.
#
# source://sequel//lib/sequel/sql.rb#1302
class Sequel::SQL::BooleanConstant < ::Sequel::SQL::Constant
  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Subclass of +ComplexExpression+ where the expression results
# in a boolean value in SQL.
#
# source://sequel//lib/sequel/sql.rb#1058
class Sequel::SQL::BooleanExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::BooleanMethods

  # Always use an AND operator for & on BooleanExpressions
  #
  # source://sequel//lib/sequel/sql.rb#1172
  def &(ce); end

  # Return self instead of creating a new object to save on memory.
  #
  # source://sequel//lib/sequel/sql.rb#1182
  def sql_boolean; end

  # Always use an OR operator for | on BooleanExpressions
  #
  # source://sequel//lib/sequel/sql.rb#1177
  def |(ce); end

  class << self
    # Take pairs of values (e.g. a hash or array of two element arrays)
    # and converts it to a +BooleanExpression+.  The operator and args
    # used depends on the case of the right (2nd) argument:
    #
    # 0..10 :: left >= 0 AND left <= 10
    # [1,2] :: left IN (1,2)
    # nil :: left IS NULL
    # true :: left IS TRUE
    # false :: left IS FALSE
    # /as/ :: left ~ 'as'
    # :blah :: left = blah
    # 'blah' :: left = 'blah'
    #
    # If multiple arguments are given, they are joined with the op given (AND
    # by default, OR possible).  If negate is set to true,
    # all subexpressions are inverted before used.  Therefore, the following
    # expressions are equivalent:
    #
    #   ~from_value_pairs(hash)
    #   from_value_pairs(hash, :OR, true)
    #
    # source://sequel//lib/sequel/sql.rb#1081
    def from_value_pairs(pairs, op = T.unsafe(nil), negate = T.unsafe(nil)); end

    # Invert the expression, if possible.  If the expression cannot
    # be inverted, raise an error.  An inverted expression should match everything that the
    # uninverted expression did not match, and vice-versa, except for possible issues with
    # SQL NULL (i.e. 1 == NULL is NULL and 1 != NULL is also NULL).
    #
    #   BooleanExpression.invert(:a) # NOT "a"
    #
    # source://sequel//lib/sequel/sql.rb#1140
    def invert(ce); end

    private

    # Return a BooleanExpression based on the right side of the pair.
    #
    # source://sequel//lib/sequel/sql.rb#1088
    def from_value_pair(l, r); end
  end
end

# This module includes the boolean/logical AND (&), OR (|) and NOT (~) operators
# that are defined on objects that can be used in a boolean context in SQL.
#
#   Sequel[:a] & Sequel[:b] # "a" AND "b"
#   Sequel[:a] | Sequel[:b] # "a" OR "b"
#   ~Sequel[:a] # NOT "a"
#
# One exception to this is when a NumericExpression or Integer is the argument
# to & or |, in which case a bitwise method will be used:
#
#   Sequel[:a] & 1 # "a" & 1
#   Sequel[:a] | (Sequel[:b] + 1) # "a" | ("b" + 1)
#
# source://sequel//lib/sequel/sql.rb#300
module Sequel::SQL::BooleanMethods
  # source://sequel//lib/sequel/sql.rb#303
  def &(o); end

  # source://sequel//lib/sequel/sql.rb#303
  def |(o); end

  # Create a new BooleanExpression with NOT, representing the inversion of whatever self represents.
  #
  #   ~Sequel[:a] # NOT :a
  #
  # source://sequel//lib/sequel/sql.rb#317
  def ~; end
end

# These methods make it easier to create Sequel expressions without
# using the core extensions.
#
# source://sequel//lib/sequel/sql.rb#324
module Sequel::SQL::Builders
  # Create an SQL::AliasedExpression for the given expression and alias.
  #
  #   Sequel.as(:column, :alias) # "column" AS "alias"
  #   Sequel.as(:column, :alias, [:col_alias1, :col_alias2]) # "column" AS "alias"("col_alias1", "col_alias2")
  #
  # source://sequel//lib/sequel/sql.rb#329
  def as(exp, aliaz, columns = T.unsafe(nil)); end

  # Order the given argument ascending.
  # Options:
  #
  # :nulls :: Set to :first to use NULLS FIRST (so NULL values are ordered
  #           before other values), or :last to use NULLS LAST (so NULL values
  #           are ordered after other values).
  #
  #   Sequel.asc(:a) # a ASC
  #   Sequel.asc(:b, nulls: :last) # b ASC NULLS LAST
  #
  # source://sequel//lib/sequel/sql.rb#342
  def asc(arg, opts = T.unsafe(nil)); end

  # Return an <tt>SQL::Blob</tt> that holds the same data as this string.
  # Blobs provide proper escaping of binary data.  If given a blob, returns it
  # directly.
  #
  # source://sequel//lib/sequel/sql.rb#349
  def blob(s); end

  # Return an <tt>SQL::CaseExpression</tt> created with the given arguments.
  # The first argument are the <tt>WHEN</tt>/<tt>THEN</tt> conditions,
  # specified as an array or a hash.  The second argument is the
  # <tt>ELSE</tt> default value.  The third optional argument is the
  # <tt>CASE</tt> expression.
  #
  #   Sequel.case({a: 1}, 0) # SQL: CASE WHEN a THEN 1 ELSE 0 END
  #   Sequel.case({a: 1}, 0, :b) # SQL: CASE b WHEN a THEN 1 ELSE 0 END
  #   Sequel.case({{a: [2,3]} => 1}, 0) # SQL: CASE WHEN a IN (2, 3) THEN 1 ELSE 0 END
  #   Sequel.case([[{a: [2,3]}, 1]], 0) # SQL: CASE WHEN a IN (2, 3) THEN 1 ELSE 0 END
  #
  # source://sequel//lib/sequel/sql.rb#367
  def case(*args); end

  # Cast the reciever to the given SQL type.  You can specify a ruby class as a type,
  # and it is handled similarly to using a database independent type in the schema methods.
  #
  #   Sequel.cast(:a, :integer) # CAST(a AS integer)
  #   Sequel.cast(:a, String) # CAST(a AS varchar(255))
  #
  # source://sequel//lib/sequel/sql.rb#376
  def cast(arg, sql_type); end

  # Cast the reciever to the given SQL type (or the database's default Integer type if none given),
  # and return the result as a +NumericExpression+, so you can use the bitwise operators
  # on the result.
  #
  #   Sequel.cast_numeric(:a) # CAST(a AS integer)
  #   Sequel.cast_numeric(:a, Float) # CAST(a AS double precision)
  #
  # source://sequel//lib/sequel/sql.rb#386
  def cast_numeric(arg, sql_type = T.unsafe(nil)); end

  # Cast the reciever to the given SQL type (or the database's default String type if none given),
  # and return the result as a +StringExpression+, so you can use +
  # directly on the result for SQL string concatenation.
  #
  #   Sequel.cast_string(:a) # CAST(a AS varchar(255))
  #   Sequel.cast_string(:a, :text) # CAST(a AS text)
  #
  # source://sequel//lib/sequel/sql.rb#396
  def cast_string(arg, sql_type = T.unsafe(nil)); end

  # Return an emulated function call for getting the number of characters
  # in the argument:
  #
  #   Sequel.char_length(:a) # char_length(a) -- Most databases
  #   Sequel.char_length(:a) # length(a) -- SQLite
  #
  # source://sequel//lib/sequel/sql.rb#405
  def char_length(arg); end

  # Do a deep qualification of the argument using the qualifier.  This recurses into
  # nested structures.
  #
  #   Sequel.deep_qualify(:table, :column) # "table"."column"
  #   Sequel.deep_qualify(:table, Sequel[:column] + 1) # "table"."column" + 1
  #   Sequel.deep_qualify(:table, Sequel[:a].like('b')) # "table"."a" LIKE 'b' ESCAPE '\'
  #
  # source://sequel//lib/sequel/sql.rb#415
  def deep_qualify(qualifier, expr); end

  # Return a delayed evaluation that uses the passed block. This is used
  # to delay evaluations of the code to runtime.  For example, with
  # the following code:
  #
  #   ds = DB[:table].where{column > Time.now}
  #
  # The filter is fixed to the time that where was called. Unless you are
  # only using the dataset once immediately after creating it, that's
  # probably not desired.  If you just want to set it to the time when the
  # query is sent to the database, you can wrap it in Sequel.delay:
  #
  #   ds = DB[:table].where{column > Sequel.delay{Time.now}}
  #
  # Note that for dates and timestamps, you are probably better off using
  # Sequel::CURRENT_DATE and Sequel::CURRENT_TIMESTAMP instead of this
  # generic delayed evaluation facility.
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/sql.rb#435
  def delay(&block); end

  # Order the given argument descending.
  # Options:
  #
  # :nulls :: Set to :first to use NULLS FIRST (so NULL values are ordered
  #           before other values), or :last to use NULLS LAST (so NULL values
  #           are ordered after other values).
  #
  #   Sequel.desc(:a) # b DESC
  #   Sequel.desc(:b, nulls: :first) # b DESC NULLS FIRST
  #
  # source://sequel//lib/sequel/sql.rb#449
  def desc(arg, opts = T.unsafe(nil)); end

  # Wraps the given object in an appropriate Sequel wrapper.
  # If the given object is already a Sequel object, return it directly.
  # For condition specifiers (hashes and arrays of two pairs), true, and false,
  # return a boolean expressions.  For numeric objects, return a numeric
  # expression.  For strings, return a string expression.  For procs or when
  # the method is passed a block, evaluate it as a virtual row and wrap it
  # appropriately.  In all other cases, use a generic wrapper.
  #
  # This method allows you to construct SQL expressions that are difficult
  # to construct via other methods.  For example:
  #
  #   Sequel.expr(1) - :a # SQL: (1 - a)
  #
  # On the Sequel module, this is aliased as #[], for easier use:
  #
  #   Sequel[1] - :a # SQL: (1 - a)
  #
  # source://sequel//lib/sequel/sql.rb#469
  def expr(arg = T.unsafe(nil), &block); end

  # Extract a datetime_part (e.g. year, month) from the given
  # expression:
  #
  #   Sequel.extract(:year, :date) # extract(year FROM "date")
  #
  # source://sequel//lib/sequel/sql.rb#522
  def extract(datetime_part, exp); end

  # Returns a <tt>Sequel::SQL::Function</tt> with the function name
  # and the given arguments.
  #
  #   Sequel.function(:now) # SQL: now()
  #   Sequel.function(:substr, :a, 1) # SQL: substr(a, 1)
  #
  # source://sequel//lib/sequel/sql.rb#531
  def function(name, *args); end

  # Return the argument wrapped as an <tt>SQL::Identifier</tt>.
  #
  #   Sequel.identifier(:a) # "a"
  #
  # source://sequel//lib/sequel/sql.rb#538
  def identifier(name); end

  # Create a <tt>BooleanExpression</tt> case insensitive (if the database supports it) pattern match of the receiver with
  # the given patterns.  See <tt>SQL::StringExpression.like</tt>.
  #
  #   Sequel.ilike(:a, 'A%') # "a" ILIKE 'A%' ESCAPE '\'
  #
  # source://sequel//lib/sequel/sql.rb#575
  def ilike(*args); end

  # Return a <tt>Sequel::SQL::StringExpression</tt> representing an SQL string made up of the
  # concatenation of the given array's elements.  If an argument is passed,
  # it is used in between each element of the array in the SQL
  # concatenation.
  #
  #   Sequel.join([:a]) # SQL: a
  #   Sequel.join([:a, :b]) # SQL: a || b
  #   Sequel.join([:a, 'b']) # SQL: a || 'b'
  #   Sequel.join(['a', :b], ' ') # SQL: 'a' || ' ' || b
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/sql.rb#551
  def join(args, joiner = T.unsafe(nil)); end

  # Create a <tt>SQL::BooleanExpression</tt> case sensitive (if the database supports it) pattern match of the receiver with
  # the given patterns.  See <tt>SQL::StringExpression.like</tt>.
  #
  #   Sequel.like(:a, 'A%') # "a" LIKE 'A%' ESCAPE '\'
  #
  # source://sequel//lib/sequel/sql.rb#583
  def like(*args); end

  # Converts a string into a <tt>Sequel::LiteralString</tt>, in order to override string
  # literalization, e.g.:
  #
  #   DB[:items].where(abc: 'def').sql #=>
  #     "SELECT * FROM items WHERE (abc = 'def')"
  #
  #   DB[:items].where(abc: Sequel.lit('def')).sql #=>
  #     "SELECT * FROM items WHERE (abc = def)"
  #
  # You can also provide arguments, to create a <tt>Sequel::SQL::PlaceholderLiteralString</tt>:
  #
  #    DB[:items].select{|o| o.count(Sequel.lit('DISTINCT ?', :a))}.sql #=>
  #      "SELECT count(DISTINCT a) FROM items"
  #
  # source://sequel//lib/sequel/sql.rb#600
  def lit(s, *args); end

  # Return a <tt>Sequel::SQL::BooleanExpression</tt> created from the condition
  # specifier, matching none of the conditions.
  #
  #   Sequel.negate(a: true) # SQL: a IS NOT TRUE
  #   Sequel.negate([[:a, true]]) # SQL: a IS NOT TRUE
  #   Sequel.negate([[:a, 1], [:b, 2]]) # SQL: ((a != 1) AND (b != 2))
  #
  # source://sequel//lib/sequel/sql.rb#618
  def negate(arg); end

  # Return a <tt>Sequel::SQL::BooleanExpression</tt> created from the condition
  # specifier, matching any of the conditions.
  #
  #   Sequel.or(a: true) # SQL: a IS TRUE
  #   Sequel.or([[:a, true]]) # SQL: a IS TRUE
  #   Sequel.or([[:a, 1], [:b, 2]]) # SQL: ((a = 1) OR (b = 2))
  #
  # source://sequel//lib/sequel/sql.rb#632
  def or(arg); end

  # Create a qualified identifier with the given qualifier and identifier
  #
  #   Sequel.qualify(:table, :column) # "table"."column"
  #   Sequel.qualify(:schema, :table) # "schema"."table"
  #   Sequel.qualify(:table, :column).qualify(:schema) # "schema"."table"."column"
  #
  # source://sequel//lib/sequel/sql.rb#645
  def qualify(qualifier, identifier); end

  # Return an <tt>SQL::Subscript</tt> with the given arguments, representing an
  # SQL array access.
  #
  #   Sequel.subscript(:array, 1) # array[1]
  #   Sequel.subscript(:array, 1, 2) # array[1, 2]
  #   Sequel.subscript(:array, [1, 2]) # array[1, 2]
  #   Sequel.subscript(:array, 1..2) # array[1:2]
  #   Sequel.subscript(:array, 1...3) # array[1:2]
  #
  # source://sequel//lib/sequel/sql.rb#657
  def subscript(exp, *subs); end

  # Return an emulated function call for trimming a string of spaces from
  # both sides (similar to ruby's String#strip).
  #
  #   Sequel.trim(:a) # trim(a) -- Most databases
  #   Sequel.trim(:a) # ltrim(rtrim(a)) -- Microsoft SQL Server
  #
  # source://sequel//lib/sequel/sql.rb#666
  def trim(arg); end

  # Return a <tt>SQL::ValueList</tt> created from the given array.  Used if the array contains
  # all two element arrays and you want it treated as an SQL value list (IN predicate)
  # instead of as a conditions specifier (similar to a hash).  This is not necessary if you are using
  # this array as a value in a filter, but may be necessary if you are using it as a
  # value with placeholder SQL:
  #
  #   DB[:a].where([:a, :b]=>[[1, 2], [3, 4]]) # SQL: (a, b) IN ((1, 2), (3, 4))
  #   DB[:a].where('(a, b) IN ?', [[1, 2], [3, 4]]) # SQL: (a, b) IN ((1 = 2) AND (3 = 4))
  #   DB[:a].where('(a, b) IN ?', Sequel.value_list([[1, 2], [3, 4]])) # SQL: (a, b) IN ((1, 2), (3, 4))
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/sql.rb#679
  def value_list(arg); end
end

# Represents an SQL CASE expression, used for conditional branching in SQL.
#
# source://sequel//lib/sequel/sql.rb#1188
class Sequel::SQL::CaseExpression < ::Sequel::SQL::GenericExpression
  # Create an object with the given conditions and
  # default value, and optional expression.  An expression can be provided to
  # test each condition against, instead of having
  # all conditions represent their own boolean expression.
  #
  # @raise [Sequel::Error]
  # @return [CaseExpression] a new instance of CaseExpression
  #
  # source://sequel//lib/sequel/sql.rb#1204
  def initialize(conditions, default, expression = T.unsafe(nil)); end

  # An array of all two pairs with the first element specifying the
  # condition and the second element specifying the result if the
  # condition matches.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def conditions; end

  # The default value if no conditions match.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def default; end

  # An optional expression to test the conditions against
  #
  # source://sequel//lib/sequel/sql.rb#93
  def expression; end

  # Whether to use an expression for this CASE expression.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/sql.rb#1214
  def expression?; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # Merge the CASE expression into the conditions, useful for databases that
  # don't support CASE expressions.
  #
  # source://sequel//lib/sequel/sql.rb#1220
  def with_merged_expression; end
end

# Represents a cast of an SQL expression to a specific type.
#
# source://sequel//lib/sequel/sql.rb#1233
class Sequel::SQL::Cast < ::Sequel::SQL::GenericExpression
  # Set the expression and type for the cast
  #
  # @return [Cast] a new instance of Cast
  #
  # source://sequel//lib/sequel/sql.rb#1241
  def initialize(expr, type); end

  # The expression to cast
  #
  # source://sequel//lib/sequel/sql.rb#93
  def expr; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # The type to which to cast the expression
  #
  # source://sequel//lib/sequel/sql.rb#93
  def type; end
end

# Holds methods that are used to cast objects to different SQL types.
#
# source://sequel//lib/sequel/sql.rb#686
module Sequel::SQL::CastMethods
  # Cast the reciever to the given SQL type.  You can specify a ruby class as a type,
  # and it is handled similarly to using a database independent type in the schema methods.
  #
  #   Sequel.function(:func).cast(:integer) # CAST(func() AS integer)
  #   Sequel.function(:func).cast(String) # CAST(func() AS varchar(255))
  #
  # source://sequel//lib/sequel/sql.rb#692
  def cast(sql_type); end

  # Cast the reciever to the given SQL type (or the database's default Integer type if none given),
  # and return the result as a +NumericExpression+, so you can use the bitwise operators
  # on the result.
  #
  #   Sequel.function(:func).cast_numeric # CAST(func() AS integer)
  #   Sequel.function(:func).cast_numeric(Float) # CAST(func() AS double precision)
  #
  # source://sequel//lib/sequel/sql.rb#702
  def cast_numeric(sql_type = T.unsafe(nil)); end

  # Cast the reciever to the given SQL type (or the database's default String type if none given),
  # and return the result as a +StringExpression+, so you can use +
  # directly on the result for SQL string concatenation.
  #
  #   Sequel.function(:func).cast_string # CAST(func() AS varchar(255))
  #   Sequel.function(:func).cast_string(:text) # CAST(func() AS text)
  #
  # source://sequel//lib/sequel/sql.rb#712
  def cast_string(sql_type = T.unsafe(nil)); end
end

# Represents all columns in a given table, table.* in SQL
#
# source://sequel//lib/sequel/sql.rb#1251
class Sequel::SQL::ColumnAll < ::Sequel::SQL::Expression
  # Create an object with the given table
  #
  # @return [ColumnAll] a new instance of ColumnAll
  #
  # source://sequel//lib/sequel/sql.rb#1256
  def initialize(table); end

  # The table containing the columns being selected
  #
  # source://sequel//lib/sequel/sql.rb#93
  def table; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Represents a SQL expression, with a given operator and one
# or more attributes (which may also be ComplexExpressions, forming
# a tree).  This class is the backbone of Sequel's ruby expression DSL.
#
# This is an abstract class that is not that useful by itself.  The
# subclasses +BooleanExpression+, +NumericExpression+, and +StringExpression+
# define the behavior of the DSL via operators.
#
# source://sequel//lib/sequel/sql.rb#153
class Sequel::SQL::ComplexExpression < ::Sequel::SQL::Expression
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::SubscriptMethods

  # Set the operator symbol and arguments for this object to the ones given.
  # Convert all args that are hashes or arrays of two element arrays to +BooleanExpressions+,
  # other than the second arg for an IN/NOT IN operator.
  # Raise an +Error+ if the operator doesn't allow boolean input and a boolean argument is given.
  # Raise an +Error+ if the wrong number of arguments for a given operator is used.
  #
  # @return [ComplexExpression] a new instance of ComplexExpression
  #
  # source://sequel//lib/sequel/sql.rb#216
  def initialize(op, *args); end

  # An array of args for this object
  #
  # source://sequel//lib/sequel/sql.rb#93
  def args; end

  # The operator symbol for this object
  #
  # source://sequel//lib/sequel/sql.rb#93
  def op; end

  # Return a BooleanExpression with the same op and args.
  #
  # source://sequel//lib/sequel/sql.rb#1272
  def sql_boolean; end

  # Return a NumericExpression with the same op and args.
  #
  # source://sequel//lib/sequel/sql.rb#1277
  def sql_number; end

  # Return a StringExpression with the same op and args.
  #
  # source://sequel//lib/sequel/sql.rb#1282
  def sql_string; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Operator symbols that are associative
#
# source://sequel//lib/sequel/sql.rb#197
Sequel::SQL::ComplexExpression::ASSOCIATIVE_OPERATORS = T.let(T.unsafe(nil), Array)

# Bitwise mathematical operators used in +BitwiseMethods+
#
# source://sequel//lib/sequel/sql.rb#167
Sequel::SQL::ComplexExpression::BITWISE_OPERATORS = T.let(T.unsafe(nil), Array)

# Hash of ruby operator symbols to SQL operators, used in +BooleanMethods+
#
# source://sequel//lib/sequel/sql.rb#176
Sequel::SQL::ComplexExpression::BOOLEAN_OPERATOR_METHODS = T.let(T.unsafe(nil), Hash)

# A hash of the opposite for each constant, used for inverting constants.
#
# source://sequel//lib/sequel/sql.rb#1329
Sequel::SQL::ComplexExpression::CONSTANT_INVERSIONS = T.let(T.unsafe(nil), Hash)

# Custom expressions that may have different syntax on different databases
#
# source://sequel//lib/sequel/sql.rb#203
Sequel::SQL::ComplexExpression::CUSTOM_EXPRESSIONS = T.let(T.unsafe(nil), Array)

# Operators that check for equality
#
# source://sequel//lib/sequel/sql.rb#170
Sequel::SQL::ComplexExpression::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

# Inequality operators used in +InequalityMethods+
#
# source://sequel//lib/sequel/sql.rb#173
Sequel::SQL::ComplexExpression::INEQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

# Operators that use IN/NOT IN for inclusion/exclusion
#
# source://sequel//lib/sequel/sql.rb#179
Sequel::SQL::ComplexExpression::IN_OPERATORS = T.let(T.unsafe(nil), Array)

# Operators that use IS, used for special casing to override literal true/false values
#
# source://sequel//lib/sequel/sql.rb#182
Sequel::SQL::ComplexExpression::IS_OPERATORS = T.let(T.unsafe(nil), Array)

# Operators that do pattern matching via LIKE
#
# source://sequel//lib/sequel/sql.rb#188
Sequel::SQL::ComplexExpression::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)

# Standard mathematical operators used in +NumericMethods+
#
# source://sequel//lib/sequel/sql.rb#164
Sequel::SQL::ComplexExpression::MATHEMATICAL_OPERATORS = T.let(T.unsafe(nil), Array)

# Operator symbols that take one or more arguments
#
# source://sequel//lib/sequel/sql.rb#194
Sequel::SQL::ComplexExpression::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

# Operator symbols that take only a single argument
#
# source://sequel//lib/sequel/sql.rb#200
Sequel::SQL::ComplexExpression::ONE_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

# A hash of the opposite for each operator symbol, used for inverting
# objects.
#
# source://sequel//lib/sequel/sql.rb#156
Sequel::SQL::ComplexExpression::OPERTATOR_INVERSIONS = T.let(T.unsafe(nil), Hash)

# Operators that do pattern matching via regular expressions
#
# source://sequel//lib/sequel/sql.rb#185
Sequel::SQL::ComplexExpression::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)

# Operator symbols that take exactly two arguments
#
# source://sequel//lib/sequel/sql.rb#191
Sequel::SQL::ComplexExpression::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

# Adds methods that allow you to treat an object as an instance of a specific
# +ComplexExpression+ subclass.
#
# source://sequel//lib/sequel/sql.rb#719
module Sequel::SQL::ComplexExpressionMethods
  # Extract a datetime part (e.g. year, month) from self:
  #
  #   Sequel[:date].extract(:year) # extract(year FROM "date")
  #
  # Also has the benefit of returning the result as a
  # NumericExpression instead of a generic ComplexExpression.
  #
  # source://sequel//lib/sequel/sql.rb#726
  def extract(datetime_part); end

  # Return a BooleanExpression representation of +self+.
  #
  # source://sequel//lib/sequel/sql.rb#731
  def sql_boolean; end

  # Return a NumericExpression representation of +self+.
  #
  #   ~Sequel[:a] # NOT "a"
  #   ~(Sequel[:a].sql_number) # ~"a"
  #
  # source://sequel//lib/sequel/sql.rb#739
  def sql_number; end

  # Return a StringExpression representation of +self+.
  #
  #   Sequel[:a] + :b # "a" + "b"
  #   Sequel[:a].sql_string + :b # "a" || "b"
  #
  # source://sequel//lib/sequel/sql.rb#747
  def sql_string; end
end

# Represents constants or psuedo-constants (e.g. +CURRENT_DATE+) in SQL.
#
# source://sequel//lib/sequel/sql.rb#1288
class Sequel::SQL::Constant < ::Sequel::SQL::GenericExpression
  # Create a constant with the given value
  #
  # @return [Constant] a new instance of Constant
  #
  # source://sequel//lib/sequel/sql.rb#1293
  def initialize(constant); end

  # The underlying constant related to this object.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def constant; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Holds default generic constants that can be referenced.  These
# are included in the Sequel top level module and are also available
# in this module which can be required at the top level to get
# direct access to the constants.
#
# source://sequel//lib/sequel/sql.rb#1316
module Sequel::SQL::Constants; end

# source://sequel//lib/sequel/sql.rb#1317
Sequel::SQL::Constants::CURRENT_DATE = T.let(T.unsafe(nil), Sequel::SQL::Constant)

# source://sequel//lib/sequel/sql.rb#1318
Sequel::SQL::Constants::CURRENT_TIME = T.let(T.unsafe(nil), Sequel::SQL::Constant)

# source://sequel//lib/sequel/sql.rb#1319
Sequel::SQL::Constants::CURRENT_TIMESTAMP = T.let(T.unsafe(nil), Sequel::SQL::Constant)

# source://sequel//lib/sequel/sql.rb#1320
Sequel::SQL::Constants::DEFAULT = T.let(T.unsafe(nil), Sequel::SQL::Constant)

# source://sequel//lib/sequel/sql.rb#1322
Sequel::SQL::Constants::FALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

# source://sequel//lib/sequel/sql.rb#1324
Sequel::SQL::Constants::NOTNULL = T.let(T.unsafe(nil), Sequel::SQL::NegativeBooleanConstant)

# source://sequel//lib/sequel/sql.rb#1323
Sequel::SQL::Constants::NULL = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

# source://sequel//lib/sequel/sql.rb#1322
Sequel::SQL::Constants::SQLFALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

# source://sequel//lib/sequel/sql.rb#1321
Sequel::SQL::Constants::SQLTRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

# source://sequel//lib/sequel/sql.rb#1321
Sequel::SQL::Constants::TRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

# Represents a delayed evaluation, encapsulating a callable
# object which returns the value to use when called.
#
# source://sequel//lib/sequel/sql.rb#1335
class Sequel::SQL::DelayedEvaluation < ::Sequel::SQL::GenericExpression
  # Set the callable object
  #
  # @return [DelayedEvaluation] a new instance of DelayedEvaluation
  #
  # source://sequel//lib/sequel/sql.rb#1341
  def initialize(callable); end

  # Call the underlying callable and return the result.  If the
  # underlying callable only accepts a single argument, call it
  # with the given dataset.
  #
  # source://sequel//lib/sequel/sql.rb#1349
  def call(ds); end

  # A callable object that returns the value of the evaluation
  # when called.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def callable; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Base class for all SQL expression objects.
#
# source://sequel//lib/sequel/sql.rb#80
class Sequel::SQL::Expression
  # Alias of <tt>eql?</tt>
  #
  # source://sequel//lib/sequel/sql.rb#125
  def ==(other); end

  # Make clone/dup return self, since Expression objects are supposed to
  # be frozen value objects
  #
  # source://sequel//lib/sequel/sql.rb#119
  def clone; end

  # Make clone/dup return self, since Expression objects are supposed to
  # be frozen value objects
  #
  # source://sequel//lib/sequel/sql.rb#119
  def dup; end

  # Returns true if the receiver is the same expression as the
  # the +other+ expression.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/sql.rb#131
  def eql?(other); end

  # Make sure that the hash value is the same if the attributes are the same.
  #
  # source://sequel//lib/sequel/sql.rb#136
  def hash; end

  # Show the class name and instance variables for the object.
  #
  # source://sequel//lib/sequel/sql.rb#141
  def inspect; end

  class << self
    # Expression objects are assumed to be value objects, where their
    # attribute values can't change after assignment.  In order to make
    # it easy to define equality and hash methods, subclass
    # instances assume that the only values that affect the results of
    # such methods are the values of the object's attributes.
    #
    # source://sequel//lib/sequel/sql.rb#92
    def attr_reader(*args); end

    # All attributes used for equality and hash methods.
    #
    # source://sequel//lib/sequel/sql.rb#85
    def comparison_attrs; end

    # Copy the comparison_attrs into the subclass.
    #
    # source://sequel//lib/sequel/sql.rb#98
    def inherited(subclass); end

    private

    # Create a to_s instance method that takes a dataset, and calls
    # the method provided on the dataset with args as the argument (self by default).
    # Used to DRY up some code.
    #
    # Do not call this method with untrusted input, as that can result in
    # arbitrary code execution.
    #
    # source://sequel//lib/sequel/sql.rb#111
    def to_s_method(meth, args = T.unsafe(nil)); end
  end
end

# Represents an SQL function call.
#
# source://sequel//lib/sequel/sql.rb#1361
class Sequel::SQL::Function < ::Sequel::SQL::GenericExpression
  # Set the name and args for the function
  #
  # @return [Function] a new instance of Function
  #
  # source://sequel//lib/sequel/sql.rb#1376
  def initialize(name, *args); end

  # If no arguments are given, return a new function with the wildcard prepended to the arguments.
  #
  #   Sequel.function(:count).*  # count(*)
  #
  # source://sequel//lib/sequel/sql.rb#1388
  def *(ce = T.unsafe(nil)); end

  # The array of arguments to pass to the function (may be blank)
  #
  # source://sequel//lib/sequel/sql.rb#93
  def args; end

  # Return a new function with DISTINCT before the method arguments.
  #
  #   Sequel.function(:count, :col).distinct # count(DISTINCT col)
  #
  # source://sequel//lib/sequel/sql.rb#1400
  def distinct; end

  # Return a new function with FILTER added to it, for filtered
  # aggregate functions:
  #
  #   Sequel.function(:foo, :col).filter(a: 1) # foo(col) FILTER (WHERE (a = 1))
  #
  # source://sequel//lib/sequel/sql.rb#1408
  def filter(*args, &block); end

  # Return a function which will use LATERAL when literalized:
  #
  #   Sequel.function(:foo, :col).lateral # LATERAL foo(col)
  #
  # source://sequel//lib/sequel/sql.rb#1421
  def lateral; end

  # The SQL function to call
  #
  # source://sequel//lib/sequel/sql.rb#93
  def name; end

  # Options for this function
  #
  # source://sequel//lib/sequel/sql.rb#93
  def opts; end

  # Return a new function where the function will be ordered.  Only useful for aggregate
  # functions that are order dependent.
  #
  #   Sequel.function(:foo, :a).order(:a, Sequel.desc(:b)) # foo(a ORDER BY a, b DESC)
  #
  # source://sequel//lib/sequel/sql.rb#1429
  def order(*args); end

  # Return a new function with an OVER clause (making it a window function).
  # See Sequel::SQL::Window for the list of options +over+ can receive.
  #
  #   Sequel.function(:row_number).over(partition: :col) # row_number() OVER (PARTITION BY col)
  #
  # @raise [Error]
  #
  # source://sequel//lib/sequel/sql.rb#1437
  def over(window = T.unsafe(nil)); end

  # Return a new function where the function name will be quoted if the database supports
  # quoted functions:
  #
  #   Sequel.function(:foo).quoted # "foo"()
  #
  # source://sequel//lib/sequel/sql.rb#1447
  def quoted; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # Return a new function where the function name will not be quoted even
  # if the database supports quoted functions:
  #
  #   Sequel[:foo][:bar].function.unquoted # foo.bar()
  #
  # source://sequel//lib/sequel/sql.rb#1455
  def unquoted; end

  # Return a new function that will use WITH ORDINALITY to also return
  # a row number for every row the function returns:
  #
  #   Sequel.function(:foo).with_ordinality # foo() WITH ORDINALITY
  #
  # source://sequel//lib/sequel/sql.rb#1463
  def with_ordinality; end

  # Return a new function that uses WITHIN GROUP ordered by the given expression,
  # useful for ordered-set and hypothetical-set aggregate functions:
  #
  #   Sequel.function(:rank, :a).within_group(:b, :c)
  #   # rank(a) WITHIN GROUP (ORDER BY b, c)
  #
  # source://sequel//lib/sequel/sql.rb#1472
  def within_group(*expressions); end

  private

  # Set name, args, and opts
  #
  # source://sequel//lib/sequel/sql.rb#1481
  def _initialize(name, args, opts); end

  # Return a new function call with the given opts merged into the current opts.
  #
  # source://sequel//lib/sequel/sql.rb#1489
  def with_opts(opts); end

  class << self
    # Set the name, args, and options, for internal use only.
    #
    # source://sequel//lib/sequel/sql.rb#1381
    def new!(name, args, opts); end
  end
end

# source://sequel//lib/sequel/sql.rb#1364
Sequel::SQL::Function::COMMA_ARRAY = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/sql.rb#1363
Sequel::SQL::Function::DISTINCT = T.let(T.unsafe(nil), Array)

# source://sequel//lib/sequel/sql.rb#1362
Sequel::SQL::Function::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)

# The base class for expressions that can be used in multiple places in
# an SQL query.
#
# source://sequel//lib/sequel/sql.rb#251
class Sequel::SQL::GenericExpression < ::Sequel::SQL::Expression
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::SubscriptMethods
end

# Represents an identifier (column, table, schema, etc.).
#
# source://sequel//lib/sequel/sql.rb#1508
class Sequel::SQL::Identifier < ::Sequel::SQL::GenericExpression
  include ::Sequel::SQL::QualifyingMethods

  # Set the identifier to the given argument
  #
  # @return [Identifier] a new instance of Identifier
  #
  # source://sequel//lib/sequel/sql.rb#1515
  def initialize(value); end

  # Create a Function using this identifier as the functions name, with
  # the given args.
  #
  # source://sequel//lib/sequel/sql.rb#1522
  def function(*args); end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # The identifier to reference
  #
  # source://sequel//lib/sequel/sql.rb#93
  def value; end
end

# This module includes the inequality methods (>, <, >=, <=) that are defined on objects that can be
# used in a numeric or string context in SQL.
#
#   Sequel[:a] > :b # a > "b"
#   Sequel[:a] < :b # a > "b"
#   Sequel[:a] >= :b # a >= "b"
#   Sequel[:a] <= :b # a <= "b"
#
# source://sequel//lib/sequel/sql.rb#759
module Sequel::SQL::InequalityMethods
  # source://sequel//lib/sequel/sql.rb#761
  def <(o); end

  # source://sequel//lib/sequel/sql.rb#761
  def <=(o); end

  # source://sequel//lib/sequel/sql.rb#761
  def >(o); end

  # source://sequel//lib/sequel/sql.rb#761
  def >=(o); end
end

# Represents an SQL JOIN clause, used for joining tables.
#
# source://sequel//lib/sequel/sql.rb#1530
class Sequel::SQL::JoinClause < ::Sequel::SQL::Expression
  # Create an object with the given join_type and table expression.
  #
  # @return [JoinClause] a new instance of JoinClause
  #
  # source://sequel//lib/sequel/sql.rb#1539
  def initialize(join_type, table_expr); end

  # The column aliases to use for the JOIN , or nil if the
  # JOIN does not use a derived column list.
  #
  # source://sequel//lib/sequel/sql.rb#1564
  def column_aliases; end

  # The type of join to do
  #
  # source://sequel//lib/sequel/sql.rb#93
  def join_type; end

  # The table/set related to the JOIN, without any alias.
  #
  # source://sequel//lib/sequel/sql.rb#1546
  def table; end

  # The table alias to use for the JOIN , or nil if the
  # JOIN does not alias the table.
  #
  # source://sequel//lib/sequel/sql.rb#1556
  def table_alias; end

  # The expression representing the table/set related to the JOIN.
  # Is an AliasedExpression if the JOIN uses an alias.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def table_expr; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Represents an SQL JOIN clause with ON conditions.
#
# source://sequel//lib/sequel/sql.rb#1574
class Sequel::SQL::JoinOnClause < ::Sequel::SQL::JoinClause
  # Create an object with the ON conditions and call super with the
  # remaining args.
  #
  # @return [JoinOnClause] a new instance of JoinOnClause
  #
  # source://sequel//lib/sequel/sql.rb#1580
  def initialize(on, *args); end

  # The conditions for the join
  #
  # source://sequel//lib/sequel/sql.rb#93
  def on; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Represents an SQL JOIN clause with USING conditions.
#
# source://sequel//lib/sequel/sql.rb#1589
class Sequel::SQL::JoinUsingClause < ::Sequel::SQL::JoinClause
  # Create an object with the given USING conditions and call super
  # with the remaining args.
  #
  # @return [JoinUsingClause] a new instance of JoinUsingClause
  #
  # source://sequel//lib/sequel/sql.rb#1596
  def initialize(cols, *args); end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # The columns that appear in both tables that should be equal
  # for the conditions to match.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def using; end
end

# Represents inverse boolean constants (currently only +NOTNULL+). A
# special class to allow for special behavior.
#
# source://sequel//lib/sequel/sql.rb#1308
class Sequel::SQL::NegativeBooleanConstant < ::Sequel::SQL::Constant
  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# Subclass of +ComplexExpression+ where the expression results
# in a numeric value in SQL.
#
# source://sequel//lib/sequel/sql.rb#1640
class Sequel::SQL::NumericExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::BitwiseMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::InequalityMethods

  # Always use + for + operator for NumericExpressions.
  #
  # source://sequel//lib/sequel/sql.rb#1646
  def +(ce); end

  # Return self instead of creating a new object to save on memory.
  #
  # source://sequel//lib/sequel/sql.rb#1651
  def sql_number; end
end

# This module includes the standard mathematical methods (+, -, *, and /)
# that are defined on objects that can be used in a numeric context in SQL
# (+Symbol+, +LiteralString+, and +SQL::GenericExpression+).
#
#   Sequel[:a] + :b # "a" + "b"
#   Sequel[:a] - :b # "a" - "b"
#   Sequel[:a] * :b # "a" * "b"
#   Sequel[:a] / :b # "a" / "b"
#
# One exception to this is if + is called with a +String+ or +StringExpression+,
# in which case the || operator is used instead of the + operator:
#
#   Sequel[:a] + 'b' # "a" || 'b'
#
# source://sequel//lib/sequel/sql.rb#778
module Sequel::SQL::NumericMethods
  # source://sequel//lib/sequel/sql.rb#780
  def *(o); end

  # source://sequel//lib/sequel/sql.rb#780
  def **(o); end

  # Use || as the operator when called with StringExpression and String instances,
  # and the + operator for LiteralStrings and all other types.
  #
  # source://sequel//lib/sequel/sql.rb#800
  def +(ce); end

  # source://sequel//lib/sequel/sql.rb#780
  def -(o); end

  # source://sequel//lib/sequel/sql.rb#780
  def /(o); end

  # If the argument given is Numeric, treat it as a NumericExpression,
  # allowing code such as:
  #
  #   1 + Sequel[:x] # SQL: (1 + x)
  #   Sequel.expr{1 - x(y)} # SQL: (1 - x(y))
  #
  # source://sequel//lib/sequel/sql.rb#788
  def coerce(other); end
end

# This adds methods to create SQL expressions using operators:
#
#   Sequel.+(1, :a)   # (1 + a)
#   Sequel.-(1, :a)   # (1 - a)
#   Sequel.*(1, :a)   # (1 * a)
#   Sequel./(1, :a)   # (1 / a)
#   Sequel.&(:b, :a)   # (b AND a)
#   Sequel.|(:b, :a)   # (b OR a)
#
# source://sequel//lib/sequel/sql.rb#848
module Sequel::SQL::OperatorBuilders
  # source://sequel//lib/sequel/sql.rb#853
  def &(*args); end

  # source://sequel//lib/sequel/sql.rb#853
  def *(*args); end

  # Return NumericExpression for the exponentiation:
  #
  #   Sequel.**(2, 3) # SQL: power(2, 3)
  #
  # source://sequel//lib/sequel/sql.rb#871
  def **(a, b); end

  # source://sequel//lib/sequel/sql.rb#853
  def +(*args); end

  # source://sequel//lib/sequel/sql.rb#853
  def -(*args); end

  # source://sequel//lib/sequel/sql.rb#853
  def /(*args); end

  # source://sequel//lib/sequel/sql.rb#853
  def |(*args); end

  # Invert the given expression.  Returns a <tt>Sequel::SQL::BooleanExpression</tt>
  # created from this argument, not matching all of the conditions.
  #
  #   Sequel.~(nil) # SQL: NOT NULL
  #   Sequel.~([[:a, true]]) # SQL: a IS NOT TRUE
  #   Sequel.~([[:a, 1], [:b, [2, 3]]]) # SQL: a != 1 OR b NOT IN (2, 3)
  #
  # source://sequel//lib/sequel/sql.rb#881
  def ~(arg); end
end

# Methods that create +OrderedExpressions+, used for sorting by columns
# or more complex expressions.
#
# source://sequel//lib/sequel/sql.rb#892
module Sequel::SQL::OrderMethods
  # Mark the receiving SQL column as sorting in an ascending fashion (generally a no-op).
  # Options:
  #
  # :nulls :: Set to :first to use NULLS FIRST (so NULL values are ordered
  #           before other values), or :last to use NULLS LAST (so NULL values
  #           are ordered after other values).
  #
  # source://sequel//lib/sequel/sql.rb#899
  def asc(opts = T.unsafe(nil)); end

  # Mark the receiving SQL column as sorting in a descending fashion.
  # Options:
  #
  # :nulls :: Set to :first to use NULLS FIRST (so NULL values are ordered
  #           before other values), or :last to use NULLS LAST (so NULL values
  #           are ordered after other values).
  #
  # source://sequel//lib/sequel/sql.rb#909
  def desc(opts = T.unsafe(nil)); end
end

# Represents a column/expression to order the result set by.
#
# source://sequel//lib/sequel/sql.rb#1657
class Sequel::SQL::OrderedExpression < ::Sequel::SQL::Expression
  # Set the expression and descending attributes to the given values.
  # Options:
  #
  # :nulls :: Can be :first/:last for NULLS FIRST/LAST.
  #
  # @return [OrderedExpression] a new instance of OrderedExpression
  #
  # source://sequel//lib/sequel/sql.rb#1673
  def initialize(expression, descending = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Return a copy that is ordered ASC
  #
  # source://sequel//lib/sequel/sql.rb#1681
  def asc; end

  # Return a copy that is ordered DESC
  #
  # source://sequel//lib/sequel/sql.rb#1686
  def desc; end

  # Whether the expression should order the result set in a descending manner
  #
  # source://sequel//lib/sequel/sql.rb#93
  def descending; end

  # The expression to order the result set by.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def expression; end

  # Return an inverted expression, changing ASC to DESC and NULLS FIRST to NULLS LAST.
  #
  # source://sequel//lib/sequel/sql.rb#1691
  def invert; end

  # Whether to sort NULLS FIRST/LAST
  #
  # source://sequel//lib/sequel/sql.rb#93
  def nulls; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# source://sequel//lib/sequel/sql.rb#1658
Sequel::SQL::OrderedExpression::INVERT_NULLS = T.let(T.unsafe(nil), Hash)

# This module includes methods for overriding the =~ method for SQL equality,
# inclusion, and pattern matching.  It returns the same result that Sequel would
# return when using a hash with a single entry, where the receiver was the key
# and the argument was the value. Example:
#
#   Sequel[:a] =~ 1 # (a = 1)
#   Sequel[:a] =~ [1, 2] # (a IN [1, 2])
#   Sequel[:a] =~ nil # (a IS NULL)
#
# This also adds the !~ method, for easily setting up not equals,
# exclusion, and inverse pattern matching.  This is the same as as inverting the
# result of the =~ method
#
#   Sequel[:a] !~ 1 # (a != 1)
#   Sequel[:a] !~ [1, 2] # (a NOT IN [1, 2])
#   Sequel[:a] !~ nil # (a IS NOT NULL)
#
# source://sequel//lib/sequel/sql.rb#828
module Sequel::SQL::PatternMatchMethods
  # source://sequel//lib/sequel/sql.rb#835
  def !~(other); end

  # Set up an equality, inclusion, or pattern match operation, based on the type
  # of the argument.
  #
  # source://sequel//lib/sequel/sql.rb#831
  def =~(other); end
end

# Represents a literal string with placeholders and arguments.
# This is necessary to ensure delayed literalization of the arguments
# required for the prepared statement support and for database-specific
# literalization.
#
# source://sequel//lib/sequel/sql.rb#1608
class Sequel::SQL::PlaceholderLiteralString < ::Sequel::SQL::GenericExpression
  # Create an object with the given string, placeholder arguments, and parens flag.
  #
  # @return [PlaceholderLiteralString] a new instance of PlaceholderLiteralString
  #
  # source://sequel//lib/sequel/sql.rb#1623
  def initialize(str, args, parens = T.unsafe(nil)); end

  # The arguments that will be subsituted into the placeholders.
  # Either an array of unnamed placeholders (which will be substituted in
  # order for ? characters), or a hash of named placeholders (which will be
  # substituted for :key phrases).
  #
  # source://sequel//lib/sequel/sql.rb#93
  def args; end

  # Whether to surround the expression with parantheses
  #
  # source://sequel//lib/sequel/sql.rb#93
  def parens; end

  # The literal string containing placeholders.  This can also be an array
  # of strings, where each arg in args goes between the string elements.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def str; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # Return a copy of the that will be surrounded by parantheses.
  #
  # source://sequel//lib/sequel/sql.rb#1631
  def with_parens; end
end

# Represents a qualified identifier (column with table or table with schema).
#
# source://sequel//lib/sequel/sql.rb#1699
class Sequel::SQL::QualifiedIdentifier < ::Sequel::SQL::GenericExpression
  include ::Sequel::SQL::QualifyingMethods

  # Set the table and column to the given arguments
  #
  # @return [QualifiedIdentifier] a new instance of QualifiedIdentifier
  #
  # source://sequel//lib/sequel/sql.rb#1709
  def initialize(table, column); end

  # The column/table referenced
  #
  # source://sequel//lib/sequel/sql.rb#93
  def column; end

  # Create a Function using this identifier as the functions name, with
  # the given args.
  #
  # source://sequel//lib/sequel/sql.rb#1717
  def function(*args); end

  # The table/schema qualifying the reference
  #
  # source://sequel//lib/sequel/sql.rb#93
  def table; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  private

  # Automatically convert SQL::Identifiers to strings
  #
  # source://sequel//lib/sequel/sql.rb#1726
  def convert_identifier(identifier); end
end

# Includes a +qualify+ and <tt>[]</tt> methods that create <tt>QualifiedIdentifier</tt>s, used for qualifying column
# names with a table or table names with a schema, and the * method for returning all columns in
# the identifier if no arguments are given.
#
# source://sequel//lib/sequel/sql.rb#917
module Sequel::SQL::QualifyingMethods
  # If no arguments are given, return an SQL::ColumnAll:
  #
  #   Sequel[:a].*  # a.*
  #
  # source://sequel//lib/sequel/sql.rb#921
  def *(ce = T.unsafe(nil)); end

  # Qualify the receiver with the given +qualifier+ (table for column/schema for table).
  #
  #   Sequel[:table][:column]          # "table"."column"
  #   Sequel[:schema][:table]          # "schema"."table"
  #   Sequel[:schema][:table][:column] # "schema"."table"."column"
  #
  # source://sequel//lib/sequel/sql.rb#943
  def [](identifier); end

  # Qualify the receiver with the given +qualifier+ (table for column/schema for table).
  #
  #   Sequel[:column].qualify(:table)                  # "table"."column"
  #   Sequel[:table].qualify(:schema)                  # "schema"."table"
  #   Sequel.qualify(:table, :column).qualify(:schema) # "schema"."table"."column"
  #
  # source://sequel//lib/sequel/sql.rb#934
  def qualify(qualifier); end
end

# This module includes the <tt>+</tt> method.  It is included in +StringExpression+ and can be included elsewhere
# to allow the use of the + operator to represent concatenation of SQL Strings:
#
# source://sequel//lib/sequel/sql.rb#970
module Sequel::SQL::StringConcatenationMethods
  # Return a +StringExpression+ representing the concatenation of the receiver
  # with the given argument.
  #
  #   Sequel[:x].sql_string + :y # => "x" || "y"
  #
  # source://sequel//lib/sequel/sql.rb#975
  def +(ce); end
end

# Subclass of +ComplexExpression+ where the expression results
# in a text/string/varchar value in SQL.
#
# source://sequel//lib/sequel/sql.rb#1738
class Sequel::SQL::StringExpression < ::Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::StringConcatenationMethods
  include ::Sequel::SQL::InequalityMethods

  # Return self instead of creating a new object to save on memory.
  #
  # source://sequel//lib/sequel/sql.rb#1793
  def sql_string; end

  class << self
    # Creates a SQL pattern match exprssion. left (l) is the SQL string we
    # are matching against, and ces are the patterns we are matching.
    # The match succeeds if any of the patterns match (SQL OR).
    #
    # If a regular expression is used as a pattern, an SQL regular expression will be
    # used, which is currently only supported on some databases.  Be aware
    # that SQL regular expression syntax is similar to ruby
    # regular expression syntax, but it not exactly the same, especially for
    # advanced regular expression features.  Sequel just uses the source of the
    # ruby regular expression verbatim as the SQL regular expression string.
    #
    # If any other object is used as a regular expression, the SQL LIKE operator will
    # be used, and should be supported by most databases.
    #
    # The pattern match will be case insensitive if the last argument is a hash
    # with a key of :case_insensitive that is not false or nil. Also,
    # if a case insensitive regular expression is used (//i), that particular
    # pattern which will always be case insensitive.
    #
    #   StringExpression.like(:a, 'a%') # ("a" LIKE 'a%' ESCAPE '\')
    #   StringExpression.like(:a, 'a%', case_insensitive: true) # ("a" ILIKE 'a%' ESCAPE '\')
    #   StringExpression.like(:a, 'a%', /^a/i) # (("a" LIKE 'a%' ESCAPE '\') OR ("a" ~* '^a'))
    #
    # source://sequel//lib/sequel/sql.rb#1769
    def like(l, *ces); end

    private

    # Returns a three element array, made up of:
    # * The object to use
    # * Whether it is a regular expression
    # * Whether it is case insensitive
    #
    # source://sequel//lib/sequel/sql.rb#1783
    def like_element(re); end
  end
end

# Map of [regexp, case_insenstive] to +ComplexExpression+ operator symbol
#
# source://sequel//lib/sequel/sql.rb#1744
Sequel::SQL::StringExpression::LIKE_MAP = T.let(T.unsafe(nil), Hash)

# This module includes the +like+ and +ilike+ methods used for pattern matching that are defined on objects that can be
# used in a string context in SQL (+Symbol+, +LiteralString+, <tt>SQL::GenericExpression</tt>).
#
# source://sequel//lib/sequel/sql.rb#950
module Sequel::SQL::StringMethods
  # Create a +BooleanExpression+ case insensitive pattern match of the receiver
  # with the given patterns.  See <tt>StringExpression.like</tt>.
  #
  #   Sequel[:a].ilike('A%') # "a" ILIKE 'A%' ESCAPE '\'
  #
  # source://sequel//lib/sequel/sql.rb#955
  def ilike(*ces); end

  # Create a +BooleanExpression+ case sensitive (if the database supports it) pattern match of the receiver with
  # the given patterns.  See <tt>StringExpression.like</tt>.
  #
  #   Sequel[:a].like('A%') # "a" LIKE 'A%' ESCAPE '\'
  #
  # source://sequel//lib/sequel/sql.rb#963
  def like(*ces); end
end

# Represents an SQL array access, with multiple possible arguments.
#
# source://sequel//lib/sequel/sql.rb#1799
class Sequel::SQL::Subscript < ::Sequel::SQL::GenericExpression
  # Set the array column and subscripts to the given arguments
  #
  # @return [Subscript] a new instance of Subscript
  #
  # source://sequel//lib/sequel/sql.rb#1808
  def initialize(expression, sub); end

  # Create a new +Subscript+ by accessing a subarray of a multidimensional
  # array.
  #
  #   Sequel[:a].sql_subscript(2) # a[2]
  #   Sequel[:a].sql_subscript(2)[1] # a[2][1]
  #
  # source://sequel//lib/sequel/sql.rb#1828
  def [](sub); end

  # The SQL array column
  #
  # source://sequel//lib/sequel/sql.rb#93
  def expression; end

  # The SQL array column
  #
  # source://sequel//lib/sequel/sql.rb#93
  def f; end

  # The array of subscripts to use (should be an array of numbers)
  #
  # source://sequel//lib/sequel/sql.rb#93
  def sub; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # Create a new +Subscript+ appending the given subscript(s)
  # to the current array of subscripts.
  #
  #   Sequel[:a].sql_subscript(2) # a[2]
  #   Sequel[:a].sql_subscript(2) | 1 # a[2, 1]
  #
  # source://sequel//lib/sequel/sql.rb#1819
  def |(sub); end
end

# This module includes the +sql_subscript+ method, representing SQL array accesses.
#
# source://sequel//lib/sequel/sql.rb#981
module Sequel::SQL::SubscriptMethods
  # Return a <tt>Subscript</tt> with the given arguments, representing an
  # SQL array access.
  #
  #   Sequel[:array].sql_subscript(1) # array[1]
  #   Sequel[:array].sql_subscript(1, 2) # array[1, 2]
  #   Sequel[:array].sql_subscript([1, 2]) # array[1, 2]
  #   Sequel[:array].sql_subscript(1..2) # array[1:2]
  #   Sequel[:array].sql_subscript(1...3) # array[1:2]
  #
  # source://sequel//lib/sequel/sql.rb#990
  def sql_subscript(*sub); end
end

# Represents an SQL value list (IN/NOT IN predicate value).  Added so it is possible to deal with a
# ruby array of two element arrays as an SQL value list instead of an ordered
# hash-like conditions specifier.
#
# source://sequel//lib/sequel/sql.rb#1838
class Sequel::SQL::ValueList < ::Array
  # Show that this is a value list and not just an array
  #
  # source://sequel//lib/sequel/sql.rb#1840
  def inspect; end
end

# The purpose of the +VirtualRow+ class is to allow the easy creation of SQL identifiers and functions,
# in a way that leads to more compact code.
#
# An instance of this class is yielded to the block supplied to <tt>Dataset#where</tt>, <tt>Dataset#order</tt>, and <tt>Dataset#select</tt>
# (and the other methods that accept a block and pass it to one of those methods).
# If the block doesn't take an argument, the block is instance_execed in the context of
# an instance of this class.
#
# +VirtualRow+ uses +method_missing+ to return either an +Identifier+, +Function+
# depending on how it is called.
#
# +Function+ :: Returned if any arguments are supplied, using the method name
#               as the function name, and the arguments as the function arguments.
# +Identifier+ :: Returned otherwise, using the method name.
#
# If splitting symbols has been enabled (not the default), then method calls without
# arguments will return +QualifiedIdentifier+ instances if the method call includes a
# double underscore.
#
# Examples:
#
#   ds = DB[:t]
#
#   # Argument yielded to block
#   ds.where{|r| r.name < 2} # SELECT * FROM t WHERE (name < 2)
#
#   # Block without argument (instance_exec)
#   ds.where{name < 2} # SELECT * FROM t WHERE (name < 2)
#
#   # Functions
#   ds.where{is_active(1, 'arg2')} # SELECT * FROM t WHERE is_active(1, 'arg2')
#   ds.select{version.function} # SELECT version() FROM t
#   ds.select{count.function.*} # SELECT count(*) FROM t
#   ds.select{count(col1).distinct} # SELECT count(DISTINCT col1) FROM t
#
#   # Math Operators
#   ds.select{|o| o.+(1, :a).as(:b)} # SELECT (1 + a) AS b FROM t
#   ds.select{|o| o.-(2, :a).as(:b)} # SELECT (2 - a) AS b FROM t
#   ds.select{|o| o.*(3, :a).as(:b)} # SELECT (3 * a) AS b FROM t
#   ds.select{|o| o./(4, :a).as(:b)} # SELECT (4 / a) AS b FROM t
#
#   # Boolean Operators
#   ds.where{|o| o.&({a: 1}, :b)}    # SELECT * FROM t WHERE ((a = 1) AND b)
#   ds.where{|o| o.|({a: 1}, :b)}    # SELECT * FROM t WHERE ((a = 1) OR b)
#   ds.where{|o| o.~(a: 1)}        # SELECT * FROM t WHERE (a != 1)
#   ds.where{|o| o.~(a: 1, b: 2)} # SELECT * FROM t WHERE ((a != 1) OR (b != 2))
#
#   # Inequality Operators
#   ds.where{|o| o.>(1, :a)}  # SELECT * FROM t WHERE (1 > a)
#   ds.where{|o| o.<(2, :a)}  # SELECT * FROM t WHERE (2 < a)
#   ds.where{|o| o.>=(3, :a)} # SELECT * FROM t WHERE (3 >= a)
#   ds.where{|o| o.<=(4, :a)} # SELECT * FROM t WHERE (4 <= a)
#
# For a more detailed explanation, see the {Virtual Rows guide}[rdoc-ref:doc/virtual_rows.rdoc].
#
# source://sequel//lib/sequel/sql.rb#1899
class Sequel::SQL::VirtualRow < ::Sequel::BasicObject
  include ::Sequel::SQL::OperatorBuilders

  # @return [VirtualRow] a new instance of VirtualRow
  #
  # source://sequel//lib/sequel/sql.rb#1910
  def initialize; end

  # source://sequel//lib/sequel/sql.rb#1904
  def <(*args); end

  # source://sequel//lib/sequel/sql.rb#1904
  def <=(*args); end

  # source://sequel//lib/sequel/sql.rb#1904
  def >(*args); end

  # source://sequel//lib/sequel/sql.rb#1904
  def >=(*args); end
end

Sequel::SQL::VirtualRow::Sequel = Sequel

# A +Window+ is part of a window function specifying the window over which a window function operates.
#
#   Sequel::SQL::Window.new(partition: :col1)
#   # (PARTITION BY col1)
#   Sequel::SQL::Window.new(partition: [:col2, :col3])
#   # (PARTITION BY col2, col3)
#
#   Sequel::SQL::Window.new(order: :col4)
#   # (ORDER BY col4)
#   Sequel::SQL::Window.new(order: [:col5, Sequel.desc(:col6)])
#   # (ORDER BY col5, col6 DESC)
#
#   Sequel::SQL::Window.new(partition: :col7, frame: :all)
#   # (PARTITION BY col7 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
#   Sequel::SQL::Window.new(partition: :col7, frame: :rows)
#   # (PARTITION BY col7 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
#   Sequel::SQL::Window.new(partition: :col7, frame: {type: :range, start: current})
#   # (PARTITION BY col7 RANGE CURRENT ROW)
#   Sequel::SQL::Window.new(partition: :col7, frame: {type: :range, start: 1, end: 1})
#   # (PARTITION BY col7 RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING)
#   Sequel::SQL::Window.new(partition: :col7, frame: {type: :range, start: 2, end: [1, :preceding]})
#   # (PARTITION BY col7 RANGE BETWEEN 2 PRECEDING AND 1 PRECEDING)
#   Sequel::SQL::Window.new(partition: :col7, frame: {type: :range, start: 1, end: [2, :following]})
#   # (PARTITION BY col7 RANGE BETWEEN 1 FOLLOWING AND 2 FOLLOWING)
#   Sequel::SQL::Window.new(partition: :col7, frame: {type: :range, start: :preceding, exclude: :current})
#   # (PARTITION BY col7 RANGE UNBOUNDED PRECEDING EXCLUDE CURRENT ROW)
#
#   Sequel::SQL::Window.new(window: :named_window) # you can create a named window with Dataset#window
#   # (named_window)
#
# source://sequel//lib/sequel/sql.rb#1965
class Sequel::SQL::Window < ::Sequel::SQL::Expression
  # Set the options to the options given
  #
  # @return [Window] a new instance of Window
  #
  # source://sequel//lib/sequel/sql.rb#1992
  def initialize(opts = T.unsafe(nil)); end

  # The options for this window.  Options currently supported:
  # :frame :: if specified, should be :all, :rows, :range, :groups, a String, or a Hash.
  #           :all :: Always operates over all rows in the partition
  #           :rows :: Includes rows in the partition up to and including the current row
  #           :range, :groups :: Includes rows in the partition up to and including the current group
  #           String :: Used as literal SQL code, try to avoid
  #           Hash :: Hash of options for the frame:
  #                   :type :: The type of frame, must be :rows, :range, or :groups (required)
  #                   :start :: The start of the frame (required).  Possible values:
  #                             :preceding :: UNBOUNDED PRECEDING
  #                             :following :: UNBOUNDED FOLLOWING
  #                             :current :: CURRENT ROW
  #                             String, Numeric, or Cast :: Used as the offset of rows/values preceding
  #                             Array :: Must have two elements, with first element being String, Numeric, or
  #                                      Cast and second element being :preceding or :following
  #                   :end :: The end of the frame.  Can be left out.  If present, takes the same values as
  #                           :start, except that when a String, Numeric, or Hash, it is used as the offset
  #                           for rows following
  #                   :exclude :: Which rows to exclude.  Possible values are :current, :ties, :group
  #                               :no_others.
  # :order :: order on the column(s) given
  # :partition :: partition/group on the column(s) given
  # :window :: base results on a previously specified named window
  #
  # source://sequel//lib/sequel/sql.rb#93
  def opts; end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end
end

# A +Wrapper+ is a simple way to wrap an existing object so that it supports
# the Sequel DSL.
#
# source://sequel//lib/sequel/sql.rb#2002
class Sequel::SQL::Wrapper < ::Sequel::SQL::GenericExpression
  # Set the value wrapped by the object.
  #
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://sequel//lib/sequel/sql.rb#2007
  def initialize(value); end

  # source://sequel//lib/sequel/sql.rb#112
  def to_s_append(ds, sql); end

  # The underlying value wrapped by this object.
  #
  # source://sequel//lib/sequel/sql.rb#93
  def value; end
end

# Time subclass that gets literalized with only the time value, so it operates
# like a standard SQL time type.  This type does not support timezones, by design,
# so it will not work correctly with <tt>time with time zone</tt> types.
#
# source://sequel//lib/sequel/sql.rb#23
class Sequel::SQLTime < ::Time
  # Show that this is an SQLTime, and the time represented
  #
  # source://sequel//lib/sequel/sql.rb#60
  def inspect; end

  # Return a string in HH:MM:SS format representing the time.
  #
  # source://sequel//lib/sequel/sql.rb#65
  def to_s(*args); end

  class << self
    # Create a new SQLTime instance given an hour, minute, second, and usec.
    #
    # source://sequel//lib/sequel/sql.rb#52
    def create(hour, minute, second, usec = T.unsafe(nil)); end

    # Use the date explicitly set, or the current date if there is not a
    # date set.
    #
    # source://sequel//lib/sequel/sql.rb#32
    def date; end

    # Set the date used for SQLTime instances.
    #
    # source://sequel//lib/sequel/sql.rb#28
    def date=(_arg0); end

    # Set the correct date and timezone when parsing times.
    #
    # source://sequel//lib/sequel/sql.rb#37
    def parse(*_arg0); end
  end
end

# The Schema module holds the schema generators.
#
# source://sequel//lib/sequel/database/schema_generator.rb#5
module Sequel::Schema; end

# Schema::AlterTableGenerator is an internal class that the user is not expected
# to instantiate directly.  Instances are created by Database#alter_table.
# It is used to specify table alteration parameters.  It takes a Database
# object and a block of operations to perform on the table, and
# gives the Database an array of table altering operations, which the database uses to
# alter a table's description.
#
# For more information on Sequel's support for schema modification, see
# the {"Schema Modification" guide}[link:files/doc/schema_modification_rdoc.html].
#
# source://sequel//lib/sequel/database/schema_generator.rb#381
class Sequel::Schema::AlterTableGenerator
  # Set the Database object to which to apply the changes, and evaluate the
  # block in the context of this object.
  #
  # @return [AlterTableGenerator] a new instance of AlterTableGenerator
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#387
  def initialize(db, &block); end

  # Add a column with the given name, type, and opts.
  # See CreateTableGenerator#column for the available options.
  #
  #   add_column(:name, String) # ADD COLUMN name varchar(255)
  #
  # PostgreSQL specific options:
  #
  # :if_not_exists :: Set to true to not add the column if it already exists (PostgreSQL 9.6+)
  #
  # MySQL specific options:
  #
  # :after :: The name of an existing column that the new column should be positioned after
  # :first :: Create this new column before all other existing columns
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#406
  def add_column(name, type, opts = T.unsafe(nil)); end

  # Add a constraint with the given name and args.
  # See CreateTableGenerator#constraint.
  #
  #   add_constraint(:valid_name, Sequel.like(:name, 'A%'))
  #   # ADD CONSTRAINT valid_name CHECK (name LIKE 'A%' ESCAPE '\')
  #   add_constraint({name: :valid_name, deferrable: true}, Sequel.like(:name, 'A%'))
  #   # ADD CONSTRAINT valid_name CHECK (name LIKE 'A%' ESCAPE '\') DEFERRABLE INITIALLY DEFERRED
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#421
  def add_constraint(name, *args, &block); end

  # Add a foreign key with the given name and referencing the given table.
  # See CreateTableGenerator#column for the available options.
  #
  # You can also pass an array of column names for creating composite foreign
  # keys. In this case, it will assume the columns exist and will only add
  # the constraint.  You can provide a :name option to name the constraint.
  #
  # NOTE: If you need to add a foreign key constraint to a single existing column
  # use the composite key syntax even if it is only one column.
  #
  #   add_foreign_key(:artist_id, :table) # ADD COLUMN artist_id integer REFERENCES table
  #   add_foreign_key([:name], :table) # ADD FOREIGN KEY (name) REFERENCES table
  #
  # PostgreSQL specific options:
  #
  # :not_valid :: Set to true to add the constraint with the NOT VALID syntax.
  #               This makes it so that future inserts must respect referential
  #               integrity, but allows the constraint to be added even if existing
  #               column values reference rows that do not exist.  After all the
  #               existing data has been cleaned up, validate_constraint can be used
  #               to mark the constraint as valid.  Note that this option only makes
  #               sense when using an array of columns.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#460
  def add_foreign_key(name, table, opts = T.unsafe(nil)); end

  # Add a full text index on the given columns.
  # See CreateTableGenerator#full_text_index for available options.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#467
  def add_full_text_index(columns, opts = T.unsafe(nil)); end

  # Add an index on the given columns. See
  # CreateTableGenerator#index for available options.
  #
  #   add_index(:artist_id) # CREATE INDEX table_artist_id_index ON table (artist_id)
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#475
  def add_index(columns, opts = T.unsafe(nil)); end

  # Add a primary key.  See CreateTableGenerator#column
  # for the available options.  Like +add_foreign_key+, if you specify
  # the column name as an array, it just creates a constraint:
  #
  #   add_primary_key(:id) # ADD COLUMN id serial PRIMARY KEY
  #   add_primary_key([:artist_id, :name]) # ADD PRIMARY KEY (artist_id, name)
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#486
  def add_primary_key(name, opts = T.unsafe(nil)); end

  # Add a spatial index on the given columns.
  # See CreateTableGenerator#index for available options.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#494
  def add_spatial_index(columns, opts = T.unsafe(nil)); end

  # Add a unique constraint to the given column(s)
  #
  #   add_unique_constraint(:name) # ADD UNIQUE (name)
  #   add_unique_constraint(:name, name: :unique_name) # ADD CONSTRAINT unique_name UNIQUE (name)
  #
  # Supports the same :deferrable option as CreateTableGenerator#column.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#433
  def add_unique_constraint(columns, opts = T.unsafe(nil)); end

  # Remove a column from the table.
  #
  #   drop_column(:artist_id) # DROP COLUMN artist_id
  #   drop_column(:artist_id, cascade: true) # DROP COLUMN artist_id CASCADE
  #
  # Options:
  #
  # :cascade :: CASCADE the operation, dropping other objects that depend on
  #             the dropped column.
  #
  # PostgreSQL specific options:
  # :if_exists :: Use IF EXISTS, so no error is raised if the column does not
  #               exist.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#511
  def drop_column(name, opts = T.unsafe(nil)); end

  # Remove a constraint from the table:
  #
  #   drop_constraint(:unique_name) # DROP CONSTRAINT unique_name
  #   drop_constraint(:unique_name, cascade: true) # DROP CONSTRAINT unique_name CASCADE
  #
  # MySQL/SQLite specific options:
  #
  # :type :: Set the type of constraint to drop, either :primary_key, :foreign_key,
  #          or :unique.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#525
  def drop_constraint(name, opts = T.unsafe(nil)); end

  # Remove a foreign key and the associated column from the table. General options:
  #
  # :name :: The name of the constraint to drop.  If not given, uses the same name
  #          that would be used by add_foreign_key with the same columns.
  #
  # NOTE: If you want to drop only the foreign key constraint but keep the column,
  # use the composite key syntax even if it is only one column.
  #
  #   drop_foreign_key(:artist_id) # DROP CONSTRAINT table_artist_id_fkey, DROP COLUMN artist_id
  #   drop_foreign_key([:name]) # DROP CONSTRAINT table_name_fkey
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#540
  def drop_foreign_key(name, opts = T.unsafe(nil)); end

  # Remove an index from the table. General options:
  #
  # :name :: The name of the index to drop.  If not given, uses the same name
  #          that would be used by add_index with the same columns.
  #
  # PostgreSQL specific options:
  #
  # :cascade :: Cascade the index drop to dependent objects.
  # :concurrently :: Drop the index using CONCURRENTLY, which doesn't block
  #                  operations on the table.  Supported in PostgreSQL 9.2+.
  # :if_exists :: Only drop the index if it already exists.
  #
  #   drop_index(:artist_id) # DROP INDEX table_artist_id_index
  #   drop_index([:a, :b]) # DROP INDEX table_a_b_index
  #   drop_index([:a, :b], name: :foo) # DROP INDEX foo
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#564
  def drop_index(columns, options = T.unsafe(nil)); end

  # An array of operations to perform
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#383
  def operations; end

  # Rename one of the table's columns.
  #
  #   rename_column(:name, :artist_name) # RENAME COLUMN name TO artist_name
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#572
  def rename_column(name, new_name, opts = T.unsafe(nil)); end

  # Set a given column as allowing NULL values.
  #
  #   set_column_allow_null(:artist_name) # ALTER COLUMN artist_name DROP NOT NULL
  #
  # On MySQL, make sure to use a symbol for the name of the column, as otherwise you
  # can lose the default and type for the column.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#613
  def set_column_allow_null(name, allow_null = T.unsafe(nil)); end

  # Modify the default value for one of the table's column.
  #
  #   set_column_default(:artist_name, 'a') # ALTER COLUMN artist_name SET DEFAULT 'a'
  #
  # To remove an existing default value, use +nil+ as the value:
  #
  #   set_column_default(:artist_name, nil) # ALTER COLUMN artist_name SET DEFAULT NULL
  #
  # On MySQL, make sure to use a symbol for the name of the column, as otherwise you
  # can lose the type and NULL/NOT NULL setting for the column.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#587
  def set_column_default(name, default); end

  # Set a given column as not allowing NULL values.
  #
  #   set_column_not_null(:artist_name) # ALTER COLUMN artist_name SET NOT NULL
  #
  # On MySQL, make sure to use a symbol for the name of the column, as otherwise you
  # can lose the default and type for the column.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#624
  def set_column_not_null(name); end

  # Modify the type of one of the table's column.
  #
  #   set_column_type(:artist_name, 'char(10)') # ALTER COLUMN artist_name TYPE char(10)
  #
  # PostgreSQL specific options:
  #
  # :using :: Add a USING clause that specifies how to convert existing values to new values.
  #
  # On MySQL, make sure to use a symbol for the name of the column, as otherwise you
  # can lose the default and NULL/NOT NULL setting for the column.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#602
  def set_column_type(name, type, opts = T.unsafe(nil)); end

  private

  # Add a composite foreign key constraint
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#637
  def add_composite_foreign_key(columns, table, opts); end

  # Add a composite primary key constraint
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#631
  def add_composite_primary_key(columns, opts); end

  # Drop a composite foreign key constraint
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#643
  def drop_composite_foreign_key(columns, opts); end
end

# Schema::CreateTableGenerator is an internal class that the user is not expected
# to instantiate directly.  Instances are created by Database#create_table.
# It is used to specify table creation parameters.  It takes a Database
# object and a block of column/index/constraint specifications, and
# gives the Database a table description, which the database uses to
# create a table.
#
# Schema::CreateTableGenerator has some methods but also includes method_missing,
# allowing users to specify column type as a method instead of using
# the column method, which makes for a nicer DSL.
#
# For more information on Sequel's support for schema modification, see
# the {"Schema Modification" guide}[rdoc-ref:doc/schema_modification.rdoc].
#
# source://sequel//lib/sequel/database/schema_generator.rb#19
class Sequel::Schema::CreateTableGenerator
  # Set the database in which to create the table, and evaluate the block
  # in the context of this object.
  #
  # @return [CreateTableGenerator] a new instance of CreateTableGenerator
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#34
  def initialize(db, &block); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def BigDecimal(name, opts = T.unsafe(nil)); end

  # Use custom Bignum method to use :Bignum instead of Bignum class, to work
  # correctly in cases where Bignum is the same as Integer.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#45
  def Bignum(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def Date(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def DateTime(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def FalseClass(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def File(name, opts = T.unsafe(nil)); end

  # Use custom Fixnum method to use Integer instead of Fixnum class, to avoid
  # warnings on ruby 2.4+.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#51
  def Fixnum(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def Float(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def Integer(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def Numeric(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def String(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def Time(name, opts = T.unsafe(nil)); end

  # source://sequel//lib/sequel/database/schema_generator.rb#69
  def TrueClass(name, opts = T.unsafe(nil)); end

  # Add an unnamed constraint, specified by the given block
  # or args:
  #
  #   check(num: 1..5) # CHECK num >= 1 AND num <= 5
  #   check{num > 5}   # CHECK num > 5
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#79
  def check(*args, &block); end

  # Add a column with the given name, type, and opts:
  #
  #   column :num, :integer
  #   # num INTEGER
  #
  #   column :name, String, null: false, default: 'a'
  #   # name varchar(255) NOT NULL DEFAULT 'a'
  #
  #   inet :ip
  #   # ip inet
  #
  # You can also create columns via method missing, so the following are
  # equivalent:
  #
  #   column :number, :integer
  #   integer :number
  #
  # The following options are supported:
  #
  # :collate :: The collation to use for the column.  For backwards compatibility,
  #             only symbols and string values are supported, and they are used verbatim.
  #             However, on PostgreSQL, symbols are literalized as regular identifiers,
  #             since unquoted collations are unlikely to be valid.
  # :default :: The default value for the column.
  # :deferrable :: For foreign key columns, this ensures referential integrity will work even if
  #                referencing table uses a foreign key value that does not
  #                yet exist on referenced table (but will exist before the transaction commits).
  #                Basically it adds DEFERRABLE INITIALLY DEFERRED on key creation.
  #                If you use :immediate as the value, uses DEFERRABLE INITIALLY IMMEDIATE.
  # :generated_always_as :: Specify a GENERATED ALWAYS AS column expression,
  #                         if generated columns are supported (PostgreSQL 12+, MariaDB 5.2.0+,
  #                         and MySQL 5.7.6+).
  # :index :: Create an index on this column.  If given a hash, use the hash as the
  #           options for the index.
  # :key :: For foreign key columns, the column in the associated table
  #         that this column references.  Unnecessary if this column
  #         references the primary key of the associated table, except if you are
  #         using MySQL.
  # :null :: Mark the column as allowing NULL values (if true),
  #          or not allowing NULL values (if false).  The default is to allow NULL values.
  # :on_delete :: Specify the behavior of this column when being deleted
  #               (:restrict, :cascade, :set_null, :set_default, :no_action).
  # :on_update :: Specify the behavior of this column when being updated
  #               (:restrict, :cascade, :set_null, :set_default, :no_action).
  # :primary_key :: Make the column as a single primary key column.  This should not
  #                 be used if you want a single autoincrementing primary key column
  #                 (use the primary_key method in that case).
  # :primary_key_constraint_name :: The name to give the primary key constraint
  # :primary_key_deferrable :: Similar to :deferrable, but for the primary key constraint
  #                            if :primary_key is used.
  # :type :: Overrides the type given as the argument.  Generally not used by column
  #          itself, but can be passed as an option to other methods that call column.
  # :unique :: Mark the column as unique, generally has the same effect as
  #            creating a unique index on the column.
  # :unique_constraint_name :: The name to give the unique key constraint
  # :unique_deferrable :: Similar to :deferrable, but for the unique constraint if :unique
  #                       is used.
  #
  # PostgreSQL specific options:
  #
  # :identity :: Create an identity column.
  #
  # MySQL specific options:
  #
  # :generated_type :: Set the type of column when using :generated_always_as,
  #                    should be :virtual or :stored to force a type.
  # :on_update_current_timestamp :: Use ON UPDATE CURRENT TIMESTAMP when defining the column,
  #                                 which will update the column value to CURRENT_TIMESTAMP
  #                                 on every UPDATE.
  #
  # Microsoft SQL Server specific options:
  #
  # :clustered :: When using :primary_key or :unique, marks the primary key or unique
  #               constraint as CLUSTERED (if true), or NONCLUSTERED (if false).
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#157
  def column(name, type, opts = T.unsafe(nil)); end

  # Column hashes created by this generator
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#24
  def columns; end

  # Adds a named CHECK constraint (or unnamed if name is nil),
  # with the given block or args. To provide options for the constraint, pass
  # a hash as the first argument.
  #
  #   constraint(:blah, num: 1..5)
  #   # CONSTRAINT blah CHECK num >= 1 AND num <= 5
  #   constraint({name: :blah, deferrable: true}, num: 1..5)
  #   # CONSTRAINT blah CHECK num >= 1 AND num <= 5 DEFERRABLE INITIALLY DEFERRED
  #
  # If the first argument is a hash, the following options are supported:
  #
  # Options:
  # :name :: The name of the CHECK constraint
  # :deferrable :: Whether the CHECK constraint should be marked DEFERRABLE.
  #
  # PostgreSQL specific options:
  # :not_valid :: Whether the CHECK constraint should be marked NOT VALID.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#182
  def constraint(name, *args, &block); end

  # Constraint hashes created by this generator
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#27
  def constraints; end

  # Add a foreign key in the table that references another table. See #column
  # for available options.
  #
  #   foreign_key(:artist_id) # artist_id INTEGER
  #   foreign_key(:artist_id, :artists) # artist_id INTEGER REFERENCES artists
  #   foreign_key(:artist_id, :artists, key: :id) # artist_id INTEGER REFERENCES artists(id)
  #   foreign_key(:artist_id, :artists, type: String) # artist_id varchar(255) REFERENCES artists(id)
  #
  # Additional Options:
  #
  # :foreign_key_constraint_name :: The name to give the foreign key constraint
  #
  # If you want a foreign key constraint without adding a column (usually because it is a
  # composite foreign key), you can provide an array of columns as the first argument, and
  # you can provide the :name option to name the constraint:
  #
  #   foreign_key([:artist_name, :artist_location], :artists, name: :artist_fk)
  #   # ADD CONSTRAINT artist_fk FOREIGN KEY (artist_name, artist_location) REFERENCES artists
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#206
  def foreign_key(name, table = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Add a full text index on the given columns.
  # See #index for additional options.
  #
  # PostgreSQL specific options:
  # :index_type :: Can be set to :gist to use a GIST index instead of the
  #                default GIN index.
  # :language :: Set a language to use for the index (default: simple).
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#226
  def full_text_index(columns, opts = T.unsafe(nil)); end

  # True if the generator includes the creation of a column with the given name.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#231
  def has_column?(name); end

  # Add an index on the given column(s) with the given options. Examples:
  #
  #   index :name
  #   # CREATE INDEX table_name_index ON table (name)
  #
  #   index [:artist_id, :name]
  #   # CREATE INDEX table_artist_id_name_index ON table (artist_id, name)
  #
  #   index [:artist_id, :name], name: :foo
  #   # CREATE INDEX foo ON table (artist_id, name)
  #
  # General options:
  #
  # :include :: Include additional column values in the index, without
  #             actually indexing on those values (only supported by
  #             some databases).
  # :name :: The name to use for the index. If not given, a default name
  #          based on the table and columns is used.
  # :type :: The type of index to use (only supported by some databases,
  #          :full_text and :spatial values are handled specially).
  # :unique :: Make the index unique, so duplicate values are not allowed.
  # :where :: A filter expression, used to create a partial index (only
  #           supported by some databases).
  #
  # PostgreSQL specific options:
  #
  # :concurrently :: Create the index concurrently, so it doesn't block
  #                  operations on the table while the index is being
  #                  built.
  # :if_not_exists :: Only create the index if an index of the same name doesn't already exist.
  # :nulls_distinct :: Set whether separate NULLs should be considered distinct values in unique indexes.
  # :opclass :: Set an opclass to use for all columns (per-column opclasses require
  #             custom SQL).
  # :tablespace :: Specify tablespace for index.
  #
  # Microsoft SQL Server specific options:
  #
  # :key_index :: Sets the KEY INDEX to the given value.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#273
  def index(columns, opts = T.unsafe(nil)); end

  # Index hashes created by this generator
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#30
  def indexes; end

  # Add a column with the given type, name, and opts.  See #column for available
  # options.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#280
  def method_missing(type, name = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Adds an autoincrementing primary key column or a primary key constraint.
  # To just create a constraint, the first argument should be an array of column symbols
  # specifying the primary key columns. To create an autoincrementing primary key
  # column, a single symbol can be used. In both cases, an options hash can be used
  # as the second argument.
  #
  # If you want to create a primary key column that is not autoincrementing, you
  # should not use this method.  Instead, you should use the regular +column+ method
  # with a <tt>primary_key: true</tt> option.
  #
  # If an array of column symbols is used, you can specify the :name option
  # to name the constraint.
  #
  # Options:
  # :keep_order :: For non-composite primary keys, respects the existing order of
  #                columns, overriding the default behavior of making the primary
  #                key the first column.
  #
  # Examples:
  #   primary_key(:id)
  #   primary_key(:id, type: :Bignum, keep_order: true)
  #   primary_key([:street_number, :house_number], name: :some_constraint_name)
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#311
  def primary_key(name, *args); end

  # The name of the primary key for this generator, if it has a primary key.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#333
  def primary_key_name; end

  # Add a spatial index on the given columns.
  # See #index for additional options.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#339
  def spatial_index(columns, opts = T.unsafe(nil)); end

  # Add a unique constraint on the given columns.
  #
  #   unique(:name) # UNIQUE (name)
  #
  # Supports the same :deferrable option as #column. The :name option can be used
  # to name the constraint.
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#349
  def unique(columns, opts = T.unsafe(nil)); end

  private

  # Add a composite foreign key constraint
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#364
  def composite_foreign_key(columns, opts); end

  # Add a composite primary key constraint
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#357
  def composite_primary_key(columns, *args); end

  # This object responds to all methods.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/database/schema_generator.rb#285
  def respond_to_missing?(meth, include_private); end

  class << self
    # Add a method for each of the given types that creates a column
    # with that type as a constant.  Types given should either already
    # be constants/classes or a capitalized string/symbol with the same name
    # as a constant/class.
    #
    # source://sequel//lib/sequel/database/schema_generator.rb#59
    def add_type_method(*types); end
  end
end

# Classes specifying generic types that Sequel will convert to database-specific types.
#
# source://sequel//lib/sequel/database/schema_generator.rb#21
Sequel::Schema::CreateTableGenerator::GENERIC_TYPES = T.let(T.unsafe(nil), Array)

# Sequel doesn't pay much attention to timezones by default, but you can set it to
# handle timezones if you want.  There are three separate timezone settings:
#
# * application_timezone
# * database_timezone
# * typecast_timezone
#
# All three timezones have getter and setter methods.
# You can set all three timezones to the same value at once via <tt>Sequel.default_timezone=</tt>.
#
# The only timezone values that are supported by default are <tt>:utc</tt> (convert to UTC),
# <tt>:local</tt> (convert to local time), and +nil+ (don't convert).  If you need to
# convert to a specific timezone, or need the timezones being used to change based
# on the environment (e.g. current user), you need to use the +named_timezones+ extension (and use
# +DateTime+ as the +datetime_class+). Sequel also ships with a +thread_local_timezones+ extensions
# which allows each thread to have its own timezone values for each of the timezones.
#
# source://sequel//lib/sequel/core.rb#41
module Sequel::SequelMethods
  # The timezone you want the application to use.  This is the timezone
  # that incoming times from the database and typecasting are converted to.
  #
  # source://sequel//lib/sequel/timezones.rb#32
  def application_timezone; end

  # source://sequel//lib/sequel/timezones.rb#45
  def application_timezone=(tz); end

  # Convert the given +Time+/+DateTime+ object into the database timezone, used when
  # literalizing objects in an SQL string.
  #
  # source://sequel//lib/sequel/timezones.rb#50
  def application_to_database_timestamp(v); end

  # Returns true if the passed object could be a specifier of conditions, false otherwise.
  # Currently, Sequel considers hashes and arrays of two element arrays as
  # condition specifiers.
  #
  #   Sequel.condition_specifier?({}) # => true
  #   Sequel.condition_specifier?([[1, 2]]) # => true
  #   Sequel.condition_specifier?([]) # => false
  #   Sequel.condition_specifier?([1]) # => false
  #   Sequel.condition_specifier?(1) # => false
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/core.rb#83
  def condition_specifier?(obj); end

  # Creates a new database object based on the supplied connection string
  # and optional arguments.  The specified scheme determines the database
  # class used, and the rest of the string specifies the connection options.
  # For example:
  #
  #   DB = Sequel.connect('sqlite:/') # Memory database
  #   DB = Sequel.connect('sqlite://blog.db') # ./blog.db
  #   DB = Sequel.connect('sqlite:///blog.db') # /blog.db
  #   DB = Sequel.connect('postgres://user:password@host:port/database_name')
  #   DB = Sequel.connect('sqlite:///blog.db', max_connections: 10)
  #
  # You can also pass a single options hash:
  #
  #   DB = Sequel.connect(adapter: 'sqlite', database: './blog.db')
  #
  # If a block is given, it is passed the opened +Database+ object, which is
  # closed when the block exits.  For example:
  #
  #   Sequel.connect('sqlite://blog.db'){|db| puts db[:users].count}
  #
  # If a block is not given, a reference to this database will be held in
  # <tt>Sequel::DATABASES</tt> until it is removed manually.  This is by
  # design, and used by <tt>Sequel::Model</tt> to pick the default
  # database.  It is recommended to pass a block if you do not want the
  # resulting Database object to remain in memory until the process
  # terminates, or use the <tt>keep_reference: false</tt> Database option.
  #
  # For details, see the {"Connecting to a Database" guide}[rdoc-ref:doc/opening_databases.rdoc].
  # To set up a primary/replica or sharded database connection, see the {"Primary/Replica Database Configurations and Sharding" guide}[rdoc-ref:doc/sharding.rdoc].
  #
  # source://sequel//lib/sequel/core.rb#123
  def connect(*args, &block); end

  # Convert the +exception+ to the given class.  The given class should be
  # <tt>Sequel::Error</tt> or a subclass.  Returns an instance of +klass+ with
  # the message and backtrace of +exception+.
  #
  # source://sequel//lib/sequel/core.rb#136
  def convert_exception_class(exception, klass); end

  # Converts the object to the given +output_timezone+.
  #
  # source://sequel//lib/sequel/timezones.rb#55
  def convert_output_timestamp(v, output_timezone); end

  # Converts the given object from the given input timezone to the
  # +application_timezone+ using +convert_input_timestamp+ and
  # +convert_output_timestamp+.
  #
  # source://sequel//lib/sequel/timezones.rb#84
  def convert_timestamp(v, input_timezone); end

  # Sequel converts two digit years in <tt>Date</tt>s and <tt>DateTime</tt>s by default,
  # so 01/02/03 is interpreted at January 2nd, 2003, and 12/13/99 is interpreted
  # as December 13, 1999. You can override this to treat those dates as
  # January 2nd, 0003 and December 13, 0099, respectively, by:
  #
  #   Sequel.convert_two_digit_years = false
  #
  # source://sequel//lib/sequel/core.rb#48
  def convert_two_digit_years; end

  # Sequel converts two digit years in <tt>Date</tt>s and <tt>DateTime</tt>s by default,
  # so 01/02/03 is interpreted at January 2nd, 2003, and 12/13/99 is interpreted
  # as December 13, 1999. You can override this to treat those dates as
  # January 2nd, 0003 and December 13, 0099, respectively, by:
  #
  #   Sequel.convert_two_digit_years = false
  #
  # source://sequel//lib/sequel/core.rb#48
  def convert_two_digit_years=(_arg0); end

  # Assume the core extensions are not loaded by default, if the core_extensions
  # extension is loaded, this will be overridden.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/core.rb#129
  def core_extensions?; end

  # The current concurrency primitive, Thread.current by default.
  #
  # source://sequel//lib/sequel/core.rb#145
  def current; end

  # The timezone for storage in the database.  This is the
  # timezone to which Sequel will convert timestamps before literalizing them
  # for storage in the database.  It is also the timezone that Sequel will assume
  # database timestamp values are already in (if they don't include an offset).
  #
  # source://sequel//lib/sequel/timezones.rb#38
  def database_timezone; end

  # source://sequel//lib/sequel/timezones.rb#45
  def database_timezone=(tz); end

  # Convert the given object into an object of <tt>Sequel.datetime_class</tt> in the
  # +application_timezone+.  Used when converting datetime/timestamp columns
  # returned by the database.
  #
  # source://sequel//lib/sequel/timezones.rb#104
  def database_to_application_timestamp(v); end

  # Sequel can use either +Time+ or +DateTime+ for times returned from the
  # database.  It defaults to +Time+.  To change it to +DateTime+:
  #
  #   Sequel.datetime_class = DateTime
  #
  # Note that +Time+ and +DateTime+ objects have a different API, and in
  # cases where they implement the same methods, they often implement them
  # differently (e.g. + using seconds on +Time+ and days on +DateTime+).
  #
  # source://sequel//lib/sequel/core.rb#58
  def datetime_class; end

  # Sequel can use either +Time+ or +DateTime+ for times returned from the
  # database.  It defaults to +Time+.  To change it to +DateTime+:
  #
  #   Sequel.datetime_class = DateTime
  #
  # Note that +Time+ and +DateTime+ objects have a different API, and in
  # cases where they implement the same methods, they often implement them
  # differently (e.g. + using seconds on +Time+ and days on +DateTime+).
  #
  # source://sequel//lib/sequel/core.rb#58
  def datetime_class=(_arg0); end

  # Sets the database, application, and typecasting timezones to the given timezone.
  #
  # source://sequel//lib/sequel/timezones.rb#109
  def default_timezone=(tz); end

  # The elapsed seconds since the given timer object was created.  The
  # timer object should have been created via Sequel.start_timer.
  #
  # source://sequel//lib/sequel/core.rb#335
  def elapsed_seconds_since(timer); end

  # Load all Sequel extensions given.  Extensions are just files that exist under
  # <tt>sequel/extensions</tt> in the load path, and are just required.
  # In some cases, requiring an extension modifies classes directly, and in others,
  # it just loads a module that you can extend other classes with.  Consult the documentation
  # for each extension you plan on using for usage.
  #
  #   Sequel.extension(:blank)
  #   Sequel.extension(:core_extensions, :named_timezones)
  #
  # source://sequel//lib/sequel/core.rb#157
  def extension(*extensions); end

  # The exception classed raised if there is an error parsing JSON.
  # This can be overridden to use an alternative json implementation.
  #
  # source://sequel//lib/sequel/core.rb#163
  def json_parser_error_class; end

  # Convert given object to json and return the result.
  # This can be overridden to use an alternative json implementation.
  #
  # source://sequel//lib/sequel/core.rb#169
  def object_to_json(obj, *args, &block); end

  # Parse the string as JSON and return the result.
  # This can be overridden to use an alternative json implementation.
  #
  # source://sequel//lib/sequel/core.rb#175
  def parse_json(json); end

  # Convert each item in the array to the correct type, handling multi-dimensional
  # arrays.  For each element in the array or subarrays, call the converter,
  # unless the value is nil.
  #
  # source://sequel//lib/sequel/core.rb#193
  def recursive_map(array, converter); end

  # For backwards compatibility only.  require_relative should be used instead.
  #
  # source://sequel//lib/sequel/core.rb#204
  def require(files, subdir = T.unsafe(nil)); end

  # Set whether Sequel is being used in single threaded mode. By default,
  # Sequel uses a thread-safe connection pool, which isn't as fast as the
  # single threaded connection pool, and also has some additional thread
  # safety checks.  If your program will only have one thread,
  # and speed is a priority, you should set this to true:
  #
  #   Sequel.single_threaded = true
  #
  # source://sequel//lib/sequel/core.rb#67
  def single_threaded; end

  # Set whether Sequel is being used in single threaded mode. By default,
  # Sequel uses a thread-safe connection pool, which isn't as fast as the
  # single threaded connection pool, and also has some additional thread
  # safety checks.  If your program will only have one thread,
  # and speed is a priority, you should set this to true:
  #
  #   Sequel.single_threaded = true
  #
  # source://sequel//lib/sequel/core.rb#67
  def single_threaded=(_arg0); end

  # Splits the symbol into three parts, if symbol splitting is enabled (not the default).
  # Each part will either be a string or nil. If symbol splitting
  # is disabled, returns an array with the first and third parts
  # being nil, and the second part beind a string version of the symbol.
  #
  # For columns, these parts are the table, column, and alias.
  # For tables, these parts are the schema, table, and alias.
  #
  # source://sequel//lib/sequel/core.rb#216
  def split_symbol(sym); end

  # Setting this to true enables Sequel's historical behavior of splitting
  # symbols on double or triple underscores:
  #
  #   :table__column         # table.column
  #   :column___alias        # column AS alias
  #   :table__column___alias # table.column AS alias
  #
  # It is only recommended to turn this on for backwards compatibility until
  # such symbols have been converted to use newer Sequel APIs such as:
  #
  #   Sequel[:table][:column]            # table.column
  #   Sequel[:column].as(:alias)         # column AS alias
  #   Sequel[:table][:column].as(:alias) # table.column AS alias
  #
  # Sequel::Database instances do their own caching of literalized
  # symbols, and changing this setting does not affect those caches.  It is
  # recommended that if you want to change this setting, you do so directly
  # after requiring Sequel, before creating any Sequel::Database instances.
  #
  # Disabling symbol splitting will also disable the handling
  # of double underscores in virtual row methods, causing such methods to
  # yield regular identifers instead of qualified identifiers:
  #
  #   # Sequel.split_symbols = true
  #   Sequel.expr{table__column}  # table.column
  #   Sequel.expr{table[:column]} # table.column
  #
  #   # Sequel.split_symbols = false
  #   Sequel.expr{table__column}  # table__column
  #   Sequel.expr{table[:column]} # table.column
  #
  # source://sequel//lib/sequel/core.rb#267
  def split_symbols=(v); end

  # Whether Sequel currently splits symbols into qualified/aliased identifiers.
  #
  # @return [Boolean]
  #
  # source://sequel//lib/sequel/core.rb#273
  def split_symbols?; end

  # :nocov:
  #
  # source://sequel//lib/sequel/core.rb#322
  def start_timer; end

  # Converts the given +string+ into a +Date+ object.
  #
  #   Sequel.string_to_date('2010-09-10') # Date.civil(2010, 09, 10)
  #
  # source://sequel//lib/sequel/core.rb#280
  def string_to_date(string); end

  # Converts the given +string+ into a +Time+ or +DateTime+ object, depending on the
  # value of <tt>Sequel.datetime_class</tt>.
  #
  #   Sequel.string_to_datetime('2010-09-10 10:20:30') # Time.local(2010, 09, 10, 10, 20, 30)
  #
  # source://sequel//lib/sequel/core.rb#290
  def string_to_datetime(string); end

  # Converts the given +string+ into a <tt>Sequel::SQLTime</tt> object.
  #
  #   v = Sequel.string_to_time('10:20:30') # Sequel::SQLTime.parse('10:20:30')
  #   DB.literal(v) # => '10:20:30'
  #
  # source://sequel//lib/sequel/core.rb#304
  def string_to_time(string); end

  # Unless in single threaded mode, protects access to any mutable
  # global data structure in Sequel.
  # Uses a non-reentrant mutex, so calling code should be careful.
  # In general, this should only be used around the minimal possible code
  # such as Hash#[], Hash#[]=, Hash#delete, Array#<<, and Array#delete.
  #
  # source://sequel//lib/sequel/core.rb#315
  def synchronize(&block); end

  # If a mutex is given, synchronize access using it.  If nil is given, just
  # yield to the block.  This is designed for cases where a mutex may or may
  # not be provided.
  #
  # source://sequel//lib/sequel/core.rb#182
  def synchronize_with(mutex); end

  # Uses a transaction on all given databases with the given options. This:
  #
  #   Sequel.transaction([DB1, DB2, DB3]){}
  #
  # is equivalent to:
  #
  #   DB1.transaction do
  #     DB2.transaction do
  #       DB3.transaction do
  #       end
  #     end
  #   end
  #
  # except that if Sequel::Rollback is raised by the block, the transaction is
  # rolled back on all databases instead of just the last one.
  #
  # Note that this method cannot guarantee that all databases will commit or
  # rollback.  For example, if DB3 commits but attempting to commit on DB2
  # fails (maybe because foreign key checks are deferred), there is no way
  # to uncommit the changes on DB3.  For that kind of support, you need to
  # have two-phase commit/prepared transactions (which Sequel supports on
  # some databases).
  #
  # source://sequel//lib/sequel/core.rb#361
  def transaction(dbs, opts = T.unsafe(nil), &block); end

  # The timezone that incoming data that Sequel needs to typecast
  # is assumed to be already in (if they don't include an offset).
  #
  # source://sequel//lib/sequel/timezones.rb#42
  def typecast_timezone; end

  # source://sequel//lib/sequel/timezones.rb#45
  def typecast_timezone=(tz); end

  # Convert the given object into an object of <tt>Sequel.datetime_class</tt> in the
  # +application_timezone+.  Used when typecasting values when assigning them
  # to model datetime attributes.
  #
  # source://sequel//lib/sequel/timezones.rb#118
  def typecast_to_application_timestamp(v); end

  # If the supplied block takes a single argument,
  # yield an <tt>SQL::VirtualRow</tt> instance to the block
  # argument.  Otherwise, evaluate the block in the context of a
  # <tt>SQL::VirtualRow</tt> instance.
  #
  #   Sequel.virtual_row{a} # Sequel::SQL::Identifier.new(:a)
  #   Sequel.virtual_row{|o| o.a} # Sequel::SQL::Function.new(:a)
  #
  # source://sequel//lib/sequel/core.rb#385
  def virtual_row(&block); end

  private

  # Return a hash of date information parsed from the given string.
  #
  # source://sequel//lib/sequel/core.rb#398
  def _date_parse(string); end

  # Helper method that the database adapter class methods that are added to Sequel via
  # metaprogramming use to parse arguments.
  #
  # source://sequel//lib/sequel/core.rb#404
  def adapter_method(adapter, *args, &block); end

  # Convert the given +DateTime+ to the given input_timezone, keeping the
  # same time and just modifying the timezone.
  #
  # source://sequel//lib/sequel/timezones.rb#126
  def convert_input_datetime_no_offset(v, input_timezone); end

  # Convert the given +DateTime+ to the given input_timezone that is not supported
  # by default (i.e. one other than +nil+, <tt>:local</tt>, or <tt>:utc</tt>).  Raises an +InvalidValue+ by default.
  # Can be overridden in extensions.
  #
  # @raise [InvalidValue]
  #
  # source://sequel//lib/sequel/timezones.rb#141
  def convert_input_datetime_other(v, input_timezone); end

  # Convert the given +Time+ to the given input_timezone that is not supported
  # by default (i.e. one other than +nil+, <tt>:local</tt>, or <tt>:utc</tt>).  Raises an +InvalidValue+ by default.
  # Can be overridden in extensions.
  #
  # @raise [InvalidValue]
  #
  # source://sequel//lib/sequel/timezones.rb#148
  def convert_input_time_other(v, input_timezone); end

  # Converts the object from a +String+, +Array+, +Date+, +DateTime+, or +Time+ into an
  # instance of <tt>Sequel.datetime_class</tt>.  If given an array or a string that doesn't
  # contain an offset, assume that the array/string is already in the given +input_timezone+.
  #
  # source://sequel//lib/sequel/timezones.rb#155
  def convert_input_timestamp(v, input_timezone); end

  # Convert the given +DateTime+ to the given output_timezone that is not supported
  # by default (i.e. one other than +nil+, <tt>:local</tt>, or <tt>:utc</tt>).  Raises an +InvalidValue+ by default.
  # Can be overridden in extensions.
  #
  # @raise [InvalidValue]
  #
  # source://sequel//lib/sequel/timezones.rb#224
  def convert_output_datetime_other(v, output_timezone); end

  # Convert the given +Time+ to the given output_timezone that is not supported
  # by default (i.e. one other than +nil+, <tt>:local</tt>, or <tt>:utc</tt>).  Raises an +InvalidValue+ by default.
  # Can be overridden in extensions.
  #
  # @raise [InvalidValue]
  #
  # source://sequel//lib/sequel/timezones.rb#231
  def convert_output_time_other(v, output_timezone); end

  # Convert the timezone setter argument.  Returns argument given by default,
  # exists for easier overriding in extensions.
  #
  # source://sequel//lib/sequel/timezones.rb#237
  def convert_timezone_setter_arg(tz); end

  # Method that adds a database adapter class method to Sequel that calls
  # Sequel.adapter_method.
  #
  # source://sequel//lib/sequel/core.rb#417
  def def_adapter_method(*adapters); end

  # Takes a DateTime dt, and returns the correct local offset for that dt, daylight savings included, in fraction of a day.
  #
  # source://sequel//lib/sequel/timezones.rb#242
  def local_offset_for_datetime(dt); end

  # Alias of original require method, as Sequel.require does a relative
  # require for backwards compatibility.
  def orig_require(path); end

  # Caches offset conversions to avoid excess Rational math.
  #
  # source://sequel//lib/sequel/timezones.rb#247
  def time_offset_to_datetime_offset(offset_secs); end
end

# source://sequel//lib/sequel/exceptions.rb#75
class Sequel::SerializationFailure < ::Sequel::DatabaseError; end

# The tiny version of Sequel.  Usually 0, only bumped for bugfix
# releases that fix regressions from previous versions.
#
# source://sequel//lib/sequel/version.rb#13
Sequel::TINY = T.let(T.unsafe(nil), Integer)

# Backwards compatible alias
#
# source://sequel//lib/sequel/timezones.rb#10
Sequel::Timezones = Sequel::SequelMethods

# source://sequel//lib/sequel/model/exceptions.rb#24
class Sequel::UndefinedAssociation < ::Sequel::Error; end

# source://sequel//lib/sequel/exceptions.rb#70
class Sequel::UniqueConstraintViolation < ::Sequel::ConstraintViolation; end

# The version of Sequel you are using, as a string (e.g. "2.11.0")
#
# source://sequel//lib/sequel/version.rb#16
Sequel::VERSION = T.let(T.unsafe(nil), String)

# The version of Sequel you are using, as a number (2.11.0 -> 20110)
#
# source://sequel//lib/sequel/version.rb#19
Sequel::VERSION_NUMBER = T.let(T.unsafe(nil), Integer)

# source://sequel//lib/sequel/sql.rb#1933
Sequel::VIRTUAL_ROW = T.let(T.unsafe(nil), Sequel::SQL::VirtualRow)

# Exception class raised when +raise_on_save_failure+ is set and validation fails
#
# source://sequel//lib/sequel/model/exceptions.rb#34
class Sequel::ValidationFailed < ::Sequel::Error
  # @return [ValidationFailed] a new instance of ValidationFailed
  #
  # source://sequel//lib/sequel/model/exceptions.rb#41
  def initialize(errors = T.unsafe(nil)); end

  # The Sequel::Model::Errors object related to this exception.
  #
  # source://sequel//lib/sequel/model/exceptions.rb#39
  def errors; end

  # The Sequel::Model object related to this exception.
  #
  # source://sequel//lib/sequel/model/exceptions.rb#36
  def model; end
end

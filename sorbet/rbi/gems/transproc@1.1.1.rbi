# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `transproc` gem.
# Please instead update this file by running `bin/tapioca gem transproc`.

# source://transproc//lib/transproc/version.rb#3
module Transproc; end

# Transformation functions for Array objects
#
# @api public
# @example
#   require 'transproc/array'
#
#   include Transproc::Helper
#
#   fn = t(:map_array, t(:symbolize_keys)) >> t(:wrap, :address, [:city, :zipcode])
#
#   fn.call(
#   [
#   { 'city' => 'Boston', 'zipcode' => '123' },
#   { 'city' => 'NYC', 'zipcode' => '312' }
#   ]
#   )
#   # => [{:address=>{:city=>"Boston", :zipcode=>"123"}}, {:address=>{:city=>"NYC", :zipcode=>"312"}}]
#
# source://transproc//lib/transproc/array/combine.rb#4
module Transproc::ArrayTransformations
  extend ::Transproc::Registry

  class << self
    # Adds missing keys with nil value to all tuples in array
    #
    # @api public
    # @param keys [Array]
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#176
    def add_keys(array, keys); end

    # @api public
    #
    # source://transproc//lib/transproc/array.rb#124
    def combine(array, mappings); end

    # Converts the array of hashes to array of values, extracted by given key
    #
    # @api public
    # @example
    #   fn = t(:extract_key, :name)
    #   fn.call [
    #   { name: 'Alice', role: 'sender' },
    #   { name: 'Bob', role: 'receiver' },
    #   { role: 'listener' }
    #   ]
    #   # => ['Alice', 'Bob', nil]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#145
    def extract_key(array, key); end

    # Group array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Transproc(:group, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    #   # => [{ task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }]]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#85
    def group(array, key, keys); end

    # Wraps every value of the array to tuple with given key
    #
    # The transformation partially inverses the `extract_key`.
    #
    # @api public
    # @example
    #   fn = t(:insert_key, 'name')
    #   fn.call ['Alice', 'Bob', nil]
    #   # => [{ 'name' => 'Alice' }, { 'name' => 'Bob' }, { 'name' => nil }]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#164
    def insert_key(array, key); end

    # Map array values using transformation function
    #
    # @api public
    # @example
    #
    #   fn = Transproc(:map_array, -> v { v.upcase })
    #
    #   fn.call ['foo', 'bar'] # => ["FOO", "BAR"]
    # @param array [Array] The input array
    # @param fn [Proc] The transformation function
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#43
    def map_array(array, fn); end

    # Ungroup array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Transproc(:ungroup, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }] }
    #   ]
    #   # => [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#120
    def ungroup(array, key, keys); end

    # Wrap array values using HashTransformations.nest function
    #
    # @api public
    # @example
    #   fn = Transproc(:wrap, :address, [:city, :zipcode])
    #
    #   fn.call [{ city: 'NYC', zipcode: '123' }]
    #   # => [{ address: { city: 'NYC', zipcode: '123' } }]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://transproc//lib/transproc/array.rb#62
    def wrap(array, key, keys); end
  end
end

# source://transproc//lib/transproc/array/combine.rb#5
class Transproc::ArrayTransformations::Combine
  class << self
    # source://transproc//lib/transproc/array/combine.rb#9
    def combine(array, mappings); end

    private

    # source://transproc//lib/transproc/array/combine.rb#22
    def add_groups_to_element(element, groups, mappings); end

    # source://transproc//lib/transproc/array/combine.rb#30
    def element_candidates(element, candidates, keys); end

    # source://transproc//lib/transproc/array/combine.rb#54
    def element_candidates_key(element, keys); end

    # source://transproc//lib/transproc/array/combine.rb#41
    def group_candidates(candidates, mapping); end

    # source://transproc//lib/transproc/array/combine.rb#47
    def group_candidates_by_keys(candidates, keys); end

    # source://transproc//lib/transproc/array/combine.rb#34
    def group_nodes(nodes, mappings); end
  end
end

# source://transproc//lib/transproc/array/combine.rb#6
Transproc::ArrayTransformations::Combine::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# Transformation functions for Classes
#
# @api public
# @example
#   require 'transproc/class'
#
#   include Transproc::Helper
#
#   fn = t(:constructor_inject, Struct)
#
#   fn['User', :name, :age]
#   # => Struct::User
#
# source://transproc//lib/transproc/class.rb#17
module Transproc::ClassTransformations
  extend ::Transproc::Registry

  class << self
    # Inject given arguments into the constructor of the class
    #
    # @api public
    # @example
    #   Transproct(:constructor_inject, Struct)['User', :name, :age]
    #   # => Struct::User
    # @param A [*Mixed] list of arguments to inject
    # @return [Object] An instance of the given klass
    #
    # source://transproc//lib/transproc/class.rb#31
    def constructor_inject(*args, klass); end

    # Set instance variables from the hash argument (key/value pairs) on the object
    #
    # @api public
    # @example
    #   Transproc(:set_ivars, Object)[name: 'Jane', age: 25]
    #   # => #<Object:0x007f411d06a210 @name="Jane", @age=25>
    # @param [Object]
    # @return [Object]
    #
    # source://transproc//lib/transproc/class.rb#46
    def set_ivars(ivar_hash, klass); end
  end
end

# Coercion functions for common types
#
# @api public
#
# source://transproc//lib/transproc/coercions.rb#12
module Transproc::Coercions
  extend ::Transproc::Registry

  class << self
    # Does nothing and returns a value
    #
    # @api public
    # @example
    #   fn = Coercions[:identity]
    #   fn[:foo] # => :foo
    # @param value [Object]
    # @return [Object]
    #
    # source://transproc//lib/transproc/coercions.rb#33
    def identity(value = T.unsafe(nil)); end

    # Coerce value into a boolean
    #
    # @api public
    # @example
    #   Transproc(:to_boolean)['true']
    #   # => true
    #   Transproc(:to_boolean)['f']
    #   # => false
    # @param value [Object] The input value
    # @return [TrueClass, FalseClass]
    #
    # source://transproc//lib/transproc/coercions.rb#125
    def to_boolean(value); end

    # Coerce value into a date
    #
    # @api public
    # @example
    #   Transproc(:to_date)['2015-04-14']
    #   # => #<Date: 2015-04-14 ((2457127j,0s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [Date]
    #
    # source://transproc//lib/transproc/coercions.rb#140
    def to_date(value); end

    # Coerce value into a datetime
    #
    # @api public
    # @example
    #   Transproc(:to_datetime)['2015-04-14 12:01:45']
    #   # => #<DateTime: 2015-04-14T12:01:45+00:00 ((2457127j,43305s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [DateTime]
    #
    # source://transproc//lib/transproc/coercions.rb#170
    def to_datetime(value); end

    # Coerce value into a decimal
    #
    # @api public
    # @example
    #   Transproc(:to_decimal)[1.2]
    #   # => #<BigDecimal:7fca32acea50,'0.12E1',18(36)>
    # @param value [Object] The input value
    # @return [Decimal]
    #
    # source://transproc//lib/transproc/coercions.rb#108
    def to_decimal(value); end

    # Coerce value into a float
    #
    # @api public
    # @example
    #   Transproc(:to_float)['1.2']
    #   # => 1.2
    # @param value [Object] The input value
    # @return [Float]
    #
    # source://transproc//lib/transproc/coercions.rb#93
    def to_float(value); end

    # Coerce value into a integer
    #
    # @api public
    # @example
    #   Transproc(:to_integer)['1']
    #   # => 1
    # @param value [Object] The input value
    # @return [Integer]
    #
    # source://transproc//lib/transproc/coercions.rb#78
    def to_integer(value); end

    # Coerce value into a string
    #
    # @api public
    # @example
    #   Transproc(:to_string)[1]
    #   # => "1"
    # @param value [Object] The input value
    # @return [String]
    #
    # source://transproc//lib/transproc/coercions.rb#48
    def to_string(value); end

    # Coerce value into a symbol
    #
    # @api public
    # @example
    #   Transproc(:to_symbol)['foo']
    #   # => :foo
    # @param value [#to_s] The input value
    # @return [Symbol]
    #
    # source://transproc//lib/transproc/coercions.rb#63
    def to_symbol(value); end

    # Coerce value into a time
    #
    # @api public
    # @example
    #   Transproc(:to_time)['2015-04-14 12:01:45']
    #   # => 2015-04-14 12:01:45 +0200
    # @param value [Object] The input value
    # @return [Time]
    #
    # source://transproc//lib/transproc/coercions.rb#155
    def to_time(value); end

    # Coerce value into an array containing tuples only
    #
    # If the source is not an array, or doesn't contain a tuple, returns
    # an array with one empty tuple
    #
    # @api public
    # @example
    #   Transproc(:to_tuples)[:foo]                  # => [{}]
    #   Transproc(:to_tuples)[[]]                    # => [{}]
    #   Transproc(:to_tuples)[[{ foo: :FOO, :bar }]] # => [{ foo: :FOO }]
    # @param value [Object]
    # @return [Array<Hash>]
    #
    # source://transproc//lib/transproc/coercions.rb#188
    def to_tuples(value); end
  end
end

# @api public
#
# source://transproc//lib/transproc/coercions.rb#18
Transproc::Coercions::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://transproc//lib/transproc/coercions.rb#16
Transproc::Coercions::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://transproc//lib/transproc/coercions.rb#15
Transproc::Coercions::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://transproc//lib/transproc/compiler.rb#5
class Transproc::Compiler
  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://transproc//lib/transproc/compiler.rb#10
  def initialize(registry, transformer = T.unsafe(nil)); end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#15
  def call(ast); end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#8
  def registry; end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#8
  def transformer; end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#19
  def visit(node); end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#37
  def visit_arg(arg); end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#24
  def visit_fn(node); end

  # @api private
  #
  # source://transproc//lib/transproc/compiler.rb#41
  def visit_t(node); end
end

# @api private
#
# source://transproc//lib/transproc/compiler.rb#6
class Transproc::Compiler::InvalidFunctionNameError < ::StandardError; end

# Helper extension handy for composing many functions in multiple steps
#
# @api public
# @example
#   include Transproc::Composer
#
#   fn = compose do |fns|
#   fns << t(:map_array, t(:symbolize_keys))
#   fns << t(:map_array, t(:nest, :address, [:city, :zipcode]))
#   end
#
#   fn.call [{ 'city' => 'NYC', 'zipcode' => '123' }]
#   # => [{ address: { city: 'NYC', zipcode: '123' }]
#
# source://transproc//lib/transproc/composer.rb#20
module Transproc::Composer
  # Gather and compose functions and fall-back to a default one if provided
  #
  # @api public
  # @example
  #   include Transproc::Composer
  #
  #   fn = compose(-> v { v }) do |fns|
  #   fns << t(:to_string) if something
  #   end
  #
  #   fn[1] # => "1"
  # @see Composer
  # @yield [factory]
  #
  # source://transproc//lib/transproc/composer.rb#63
  def compose(default = T.unsafe(nil)); end
end

# @api private
#
# source://transproc//lib/transproc/composer.rb#22
class Transproc::Composer::Factory
  # @api private
  # @return [Factory] a new instance of Factory
  #
  # source://transproc//lib/transproc/composer.rb#26
  def initialize(default = T.unsafe(nil)); end

  # @api private
  #
  # source://transproc//lib/transproc/composer.rb#32
  def <<(other); end

  # @api private
  #
  # source://transproc//lib/transproc/composer.rb#23
  def default; end

  # @api private
  #
  # source://transproc//lib/transproc/composer.rb#23
  def fns; end

  # @api public
  # @deprecated
  #
  # source://transproc//lib/transproc/composer.rb#44
  def t(*args, &block); end

  # @api private
  #
  # source://transproc//lib/transproc/composer.rb#38
  def to_fn; end
end

# Composition of two functions
#
# @api private
#
# source://transproc//lib/transproc/composite.rb#7
class Transproc::Composite
  # @api private
  # @return [Composite] a new instance of Composite
  #
  # source://transproc//lib/transproc/composite.rb#19
  def initialize(left, right); end

  # @api public
  # @see Function#compose
  #
  # source://transproc//lib/transproc/composite.rb#39
  def +(other); end

  # @api public
  # @see Function#compose
  #
  # source://transproc//lib/transproc/composite.rb#39
  def >>(other); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  #
  # source://transproc//lib/transproc/composite.rb#31
  def [](value); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  #
  # source://transproc//lib/transproc/composite.rb#31
  def call(value); end

  # @api public
  # @see Function#compose
  #
  # source://transproc//lib/transproc/composite.rb#39
  def compose(other); end

  # @api private
  # @return [Proc]
  #
  # source://transproc//lib/transproc/composite.rb#11
  def left; end

  # @api private
  # @return [Proc]
  #
  # source://transproc//lib/transproc/composite.rb#16
  def right; end

  # @api public
  # @see Function#to_ast
  #
  # source://transproc//lib/transproc/composite.rb#48
  def to_ast; end
end

# Conditional transformation functions
#
# @api public
# @example
#   require 'transproc/conditional'
#
#   include Transproc::Helper
#
#   fn = t(:guard, -> s { s.is_a?(::String) }, -> s { s.to_sym })
#
#   [fn[2], fn['Jane']]
#   # => [2, :Jane]
#
# source://transproc//lib/transproc/conditional.rb#17
module Transproc::Conditional
  extend ::Transproc::Registry

  class << self
    # Apply the transformation function to subject if the predicate returns true, or return un-modified
    #
    # @api public
    # @example
    #   [2, 'Jane'].map do |subject|
    #   Transproc(:guard, -> s { s.is_a?(::String) }, -> s { s.to_sym })[subject]
    #   end
    #   # => [2, :Jane]
    # @param [Mixed]
    # @return [Mixed]
    #
    # source://transproc//lib/transproc/conditional.rb#50
    def guard(value, predicate, fn); end

    # Calls a function when type-check passes
    #
    # @api public
    # @example
    #   fn = Transproc(:is, Array, -> arr { arr.map(&:upcase) })
    #   fn.call(['a', 'b', 'c']) # => ['A', 'B', 'C']
    #
    #   fn = Transproc(:is, Array, -> arr { arr.map(&:upcase) })
    #   fn.call('foo') # => "foo"
    # @param [Object]
    # @param [Class]
    # @param [Proc]
    # @return [Object]
    #
    # source://transproc//lib/transproc/conditional.rb#70
    def is(value, type, fn); end

    # Negates the result of transformation
    #
    # @api public
    # @example
    #   fn = Conditional[:not, -> value { value.is_a? ::String }]
    #   fn[:foo]  # => true
    #   fn["foo"] # => false
    # @param value [Object]
    # @param fn [Proc]
    # @return [Boolean]
    #
    # source://transproc//lib/transproc/conditional.rb#33
    def not(value, fn); end
  end
end

# source://transproc//lib/transproc/support/deprecations.rb#4
module Transproc::Deprecations
  class << self
    # source://transproc//lib/transproc/support/deprecations.rb#5
    def announce(name, msg); end
  end
end

# source://transproc//lib/transproc/error.rb#4
class Transproc::Error < ::StandardError; end

# Transformation proc wrapper allowing composition of multiple procs into
# a data-transformation pipeline.
#
# This is used by Transproc to wrap registered methods.
#
# @api private
#
# source://transproc//lib/transproc/function.rb#12
class Transproc::Function
  # @api private
  # @return [Function] a new instance of Function
  #
  # source://transproc//lib/transproc/function.rb#35
  def initialize(fn, options = T.unsafe(nil)); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://transproc//lib/transproc/function.rb#62
  def +(other); end

  # @api public
  #
  # source://transproc//lib/transproc/function.rb#78
  def ==(other); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://transproc//lib/transproc/function.rb#62
  def >>(other); end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  #
  # source://transproc//lib/transproc/function.rb#48
  def [](*value); end

  # Additional arguments that will be passed to the wrapped proc
  #
  # @api private
  # @return [Array]
  #
  # source://transproc//lib/transproc/function.rb#25
  def args; end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  #
  # source://transproc//lib/transproc/function.rb#48
  def call(*value); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://transproc//lib/transproc/function.rb#62
  def compose(other); end

  # @api public
  #
  # source://transproc//lib/transproc/function.rb#78
  def eql?(other); end

  # Wrapped proc or another composite function
  #
  # @api private
  # @return [Proc, Composed]
  #
  # source://transproc//lib/transproc/function.rb#18
  def fn; end

  # @api public
  # @return [<type] The name of the function] <type] The name of the function
  #
  # source://transproc//lib/transproc/function.rb#32
  def name; end

  # Return a simple AST representation of this function
  #
  # @api public
  # @return [Array]
  #
  # source://transproc//lib/transproc/function.rb#89
  def to_ast; end

  # Converts a transproc to a simple proc
  #
  # @api private
  # @return [Proc]
  #
  # source://transproc//lib/transproc/function.rb#98
  def to_proc; end

  # Return a new fn with curried args
  #
  # @api private
  # @return [Function]
  #
  # source://transproc//lib/transproc/function.rb#73
  def with(*args); end
end

# source://transproc//lib/transproc/error.rb#5
class Transproc::FunctionAlreadyRegisteredError < ::Transproc::Error; end

# source://transproc//lib/transproc/error.rb#7
class Transproc::FunctionNotFoundError < ::Transproc::Error
  # @return [FunctionNotFoundError] a new instance of FunctionNotFoundError
  #
  # source://transproc//lib/transproc/error.rb#8
  def initialize(function, source = T.unsafe(nil)); end
end

# Function container extension
#
# @api public
# @example
#   module MyTransformations
#   extend Transproc::Functions
#
#   def boom!(value)
#   "#{value} BOOM!"
#   end
#   end
#
#   Transproc(:boom!)['w00t!'] # => "w00t! BOOM!"
#
# source://transproc//lib/transproc/functions.rb#18
module Transproc::Functions
  # @api public
  #
  # source://transproc//lib/transproc/functions.rb#24
  def method_added(meth); end

  class << self
    # @api public
    # @private
    #
    # source://transproc//lib/transproc/functions.rb#19
    def extended(mod); end
  end
end

# Transformation functions for Hash objects
#
# @api public
# @example
#   require 'transproc/hash'
#
#   include Transproc::Helper
#
#   fn = t(:symbolize_keys) >> t(:nest, :address, [:street, :zipcode])
#
#   fn["street" => "Street 1", "zipcode" => "123"]
#   # => {:address => {:street => "Street 1", :zipcode => "123"}}
#
# source://transproc//lib/transproc/hash.rb#19
module Transproc::HashTransformations
  extend ::Transproc::Registry

  class << self
    # Accepts specified keys from a hash
    #
    # @api public
    # @example
    #   Transproc(:accept_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:name=>"Jane"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be accepted
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#228
    def accept_keys(hash, keys); end

    # Copy all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Transproc(:copy_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:user_name => "Jane", :name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-copy mapping
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#189
    def copy_keys(source_hash, mapping); end

    # Merge a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => { 'one' => 1 } }
    #   other = { 'foo' => 'buz', 'baz' => { :one => 'one', :two => 2 } }
    #
    #   t(:deep_merge)[input, other]
    #   # => { 'foo' => "buz", :baz => { :one => 'one', 'one' => 1, :two => 2 } }
    # @param [Hash]
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#443
    def deep_merge(hash, other); end

    # Stringify keys in a hash recursively
    #
    # @api public
    # @example
    #   input = { :foo => "bar", :baz => [{ :one => 1 }] }
    #
    #   t(:deep_stringify_keys)[input]
    #   # => { "foo" => "bar", "baz" => [{ "one" => 1 }] }
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#120
    def deep_stringify_keys(hash); end

    # Symbolize keys in a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => [{ 'one' => 1 }] }
    #
    #   t(:deep_symbolize_keys)[input]
    #   # => { :foo => "bar", :baz => [{ :one => 1 }] }
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#76
    def deep_symbolize_keys(hash); end

    # Recursively evaluate hash values if they are procs/lambdas
    #
    # @api public
    # @example
    #   hash = {
    #   num: -> i { i + 1 },
    #   str: -> i { "num #{i}" }
    #   }
    #
    #   t(:eval_values, 1)[hash]
    #   # => {:num => 2, :str => "num 1" }
    #
    #   # with filters
    #   t(:eval_values, 1, [:str])[hash]
    #   # => {:num => #{still a proc}, :str => "num 1" }
    # @param [Hash]
    # @param args [Array, Object] Anything that should be passed to procs
    # @param filters [Array] A list of attribute names that should be evaluated
    #
    # source://transproc//lib/transproc/hash.rb#405
    def eval_values(hash, args, filters = T.unsafe(nil)); end

    # Folds array of tuples to array of values from a specified key
    #
    # @api public
    # @example
    #   source = {
    #   name: "Jane",
    #   tasks: [{ title: "be nice", priority: 1 }, { title: "sleep well" }]
    #   }
    #   Transproc(:fold, :tasks, :title)[source]
    #   # => { name: "Jane", tasks: ["be nice", "sleep well"] }
    #   Transproc(:fold, :tasks, :priority)[source]
    #   # => { name: "Jane", tasks: [1, nil] }
    # @param hash [Hash]
    # @param key [Object] The key to fold values to
    # @param tuple_key [Object] The key to take folded values from
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#340
    def fold(hash, key, tuple_key); end

    # Map all keys in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_keys, -> s { s.upcase })['name' => 'Jane']
    #   # => {"NAME" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#36
    def map_keys(source_hash, fn); end

    # Map a key in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_value, 'name', -> s { s.upcase })['name' => 'jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#248
    def map_value(hash, key, fn); end

    # Map all values in a hash using transformation function
    #
    # @api public
    # @example
    #   Transproc(:map_values, -> v { v.upcase })[:name => 'Jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#148
    def map_values(source_hash, fn); end

    # Nest values from specified keys under a new key
    #
    # @api public
    # @example
    #   Transproc(:nest, :address, [:street, :zipcode])[street: 'Street', zipcode: '123']
    #   # => {address: {street: "Street", zipcode: "123"}}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#263
    def nest(hash, root, keys); end

    # Rejects specified keys from a hash
    #
    # @api public
    # @example
    #   Transproc(:reject_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:email => "jane@doe.org"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be rejected
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#211
    def reject_keys(hash, keys); end

    # Rename all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Transproc(:rename_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-rename mapping
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#171
    def rename_keys(source_hash, mapping); end

    # Splits hash to array by all values from a specified key
    #
    # The operation adds missing keys extracted from the array to regularize the output.
    #
    # @api public
    # @example
    #   input = {
    #   name: 'Joe',
    #   tasks: [
    #   { title: 'sleep well', priority: 1 },
    #   { title: 'be nice',    priority: 2 },
    #   {                      priority: 2 },
    #   { title: 'be cool'                 }
    #   ]
    #   }
    #   Transproc(:split, :tasks, [:priority])[input]
    #   => [
    #   { name: 'Joe', priority: 1,   tasks: [{ title: 'sleep well' }]              },
    #   { name: 'Joe', priority: 2,   tasks: [{ title: 'be nice' }, { title: nil }] },
    #   { name: 'Joe', priority: nil, tasks: [{ title: 'be cool' }]                 }
    #   ]
    # @param hash [Hash]
    # @param key [Object] The key to split a hash by
    # @param subkeys [Array] The list of subkeys to be extracted from key
    # @return [Array<Hash>]
    #
    # source://transproc//lib/transproc/hash.rb#372
    def split(hash, key, keys); end

    # Stringify all keys in a hash
    #
    # @api public
    # @example
    #   Transproc(:stringify_keys)[:name => 'Jane']
    #   # => {"name" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#103
    def stringify_keys(hash); end

    # Symbolize all keys in a hash
    #
    # @api public
    # @example
    #   Transproc(:symbolize_keys)['name' => 'Jane']
    #   # => {:name => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#58
    def symbolize_keys(hash); end

    # Collapse a nested hash from a specified key
    #
    # @api public
    # @example
    #   Transproc(:unwrap, :address, [:street, :zipcode])[address: { street: 'Street', zipcode: '123' }]
    #   # => {street: "Street", zipcode: "123"}
    # @option options
    # @param options [Hash] hash of options (optional)
    # @param root [Mixed] The root key to unwrap values from
    # @param source_hash [Hash]
    # @param selected [Array] The keys that should be unwrapped (optional)
    # @return [Hash]
    #
    # source://transproc//lib/transproc/hash.rb#301
    def unwrap(source_hash, root, selected = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# @api public
#
# source://transproc//lib/transproc/hash.rb#22
Transproc::HashTransformations::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Transformation functions for Procs
#
# @api public
# @example
#   require 'ostruct'
#   require 'transproc/proc'
#
#   include Transproc::Helper
#
#   fn = t(
#   :map_value,
#   'foo_bar',
#   t(:bind, OpenStruct.new(prefix: 'foo'), -> s { [prefix, s].join('_') })
#   )
#
#   fn["foo_bar" => "bar"]
#   # => {"foo_bar" => "foo_bar"}
#
# source://transproc//lib/transproc/proc.rb#22
module Transproc::ProcTransformations
  extend ::Transproc::Registry

  class << self
    # Change the binding for the given function
    #
    # @api public
    # @example
    #   Transproc(
    #   :bind,
    #   OpenStruct.new(prefix: 'foo'),
    #   -> s { [prefix, s].join('_') }
    #   )['bar']
    #   # => "foo_bar"
    # @param [Proc]
    # @return [Proc]
    #
    # source://transproc//lib/transproc/proc.rb#40
    def bind(value, binding, fn); end
  end
end

# Recursive transformation functions
#
# @api public
# @example
#   require 'transproc/recursion'
#
#   include Transproc::Helper
#
#   fn = t(:hash_recursion, t(:symbolize_keys))
#
#   fn["name" => "Jane", "address" => { "street" => "Street 1" }]
#   # => {:name=>"Jane", :address=>{:street=>"Street 1"}}
#
# source://transproc//lib/transproc/recursion.rb#19
module Transproc::Recursion
  extend ::Transproc::Registry

  class << self
    # Recursively apply the provided transformation function to an array
    #
    # @api public
    # @example
    #   Transproc(:array_recursion, -> s { s.compact })[
    #   [['Joe', 'Jane', nil], ['Smith', 'Doe', nil]]
    #   ]
    #   # =>  [["Joe", "Jane"], ["Smith", "Doe"]]
    # @param [Array]
    # @return [Array]
    #
    # source://transproc//lib/transproc/recursion.rb#86
    def array_recursion(value, fn); end

    # Recursively apply the provided transformation function to a hash
    #
    # @api public
    # @example
    #   Transproc(:hash_recursion, Transproc(:symbolize_keys))[
    #   ["name" => "Jane", "address" => { "street" => "Street 1", "zipcode" => "123" }]
    #   ]
    #   # =>  {:name=>"Jane", :address=>{:street=>"Street 1", :zipcode=>"123"}}
    # @param [Hash]
    # @return [Hash]
    #
    # source://transproc//lib/transproc/recursion.rb#108
    def hash_recursion(value, fn); end

    # Recursively apply the provided transformation function to an enumerable
    #
    # @api public
    # @example
    #   Transproc(:recursion, Transproc(:is, ::Hash, Transproc(:symbolize_keys)))[
    #   {
    #   'id' => 1,
    #   'name' => 'Jane',
    #   'tasks' => [
    #   { 'id' => 1, 'description' => 'Write some code' },
    #   { 'id' => 2, 'description' => 'Write some more code' }
    #   ]
    #   }
    #   ]
    #   => {
    #   :id=>1,
    #   :name=>"Jane",
    #   :tasks=>[
    #   {:id=>1, :description=>"Write some code"},
    #   {:id=>2, :description=>"Write some more code"}
    #   ]
    #   }
    # @param [Enumerable]
    # @return [Enumerable]
    #
    # source://transproc//lib/transproc/recursion.rb#55
    def recursion(value, fn); end
  end
end

# @api public
#
# source://transproc//lib/transproc/recursion.rb#24
Transproc::Recursion::IF_ARRAY = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://transproc//lib/transproc/recursion.rb#22
Transproc::Recursion::IF_ENUMERABLE = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://transproc//lib/transproc/recursion.rb#26
Transproc::Recursion::IF_HASH = T.let(T.unsafe(nil), Proc)

# Container to define transproc functions in, and access them via `[]` method
# from the outside of the module
#
# @api public
# @example
#   module FooMethods
#   extend Transproc::Registry
#
#   def self.foo(name, prefix)
#   [prefix, '_', name].join
#   end
#   end
#
#   fn = FooMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   module BarMethods
#   extend FooMethods
#
#   def self.bar(*args)
#   foo(*args).upcase
#   end
#   end
#
#   fn = BarMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   fn = BarMethods[:bar, 'baz']
#   fn['qux'] # => 'QUX_BAZ'
#
# source://transproc//lib/transproc/registry.rb#35
module Transproc::Registry
  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  #
  # source://transproc//lib/transproc/registry.rb#48
  def [](fn, *args); end

  # Returns wether the registry contains such transformation by its key
  #
  # @api public
  # @param key [Symbol]
  # @return [Boolean]
  #
  # source://transproc//lib/transproc/registry.rb#62
  def contain?(key); end

  # Gets the procedure for creating a transproc
  #
  # @api public
  # @param fn [#call, Symbol] Either the procedure, or the name of the method of the current module,
  #   or the registered key of imported procedure in a store.
  # @return [#call]
  #
  # source://transproc//lib/transproc/registry.rb#132
  def fetch(fn); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  #
  # source://transproc//lib/transproc/registry.rb#110
  def import(*args); end

  # store.register(:to_json) { |v| v.to_json }
  #
  # @api public
  #
  # source://transproc//lib/transproc/registry.rb#73
  def register(name, fn = T.unsafe(nil), &block); end

  # The store of procedures imported from external modules
  #
  # @api public
  # @return [Transproc::Store]
  #
  # source://transproc//lib/transproc/registry.rb#120
  def store; end

  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  #
  # source://transproc//lib/transproc/registry.rb#48
  def t(fn, *args); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  #
  # source://transproc//lib/transproc/registry.rb#110
  def uses(*args); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://transproc//lib/transproc/registry.rb#142
  def already_wrapped?(func); end
end

# Immutable collection of named procedures from external modules
#
# @api private
#
# source://transproc//lib/transproc/store.rb#9
class Transproc::Store
  # source://transproc//lib/transproc/store.rb#25
  def initialize(methods = T.unsafe(nil)); end

  # source://transproc//lib/transproc/store.rb#46
  def contain?(key); end

  # source://transproc//lib/transproc/store.rb#36
  def fetch(key); end

  # source://transproc//lib/transproc/store.rb#65
  def import(*args); end

  # @api private
  # @return [Hash] The associated list of imported procedures
  #
  # source://transproc//lib/transproc/store.rb#14
  def methods; end

  # source://transproc//lib/transproc/store.rb#57
  def register(name, fn = T.unsafe(nil), &block); end

  protected

  # source://transproc//lib/transproc/store.rb#118
  def import_all(source); end

  # source://transproc//lib/transproc/store.rb#89
  def import_method(source, name, new_name = T.unsafe(nil)); end

  # source://transproc//lib/transproc/store.rb#106
  def import_methods(source, names); end
end

# Transfomer class for defining transprocs with a class DSL.
#
# @api public
# @example
#   require 'anima'
#   require 'transproc/all'
#
#   class User
#   include Anima.new(:name, :address)
#   end
#
#   class Address
#   include Anima.new(:city, :street, :zipcode)
#   end
#
#   class UsersMapper < Transproc::Transformer
#   map_array do
#   symbolize_keys
#   rename_keys user_name: :name
#   nest :address, %i(city street zipcode)
#   map_value :address do
#   constructor_inject Address
#   end
#   constructor_inject User
#   end
#   end
#
#   UsersMapper.new.call(
#   [
#   { 'user_name' => 'Jane',
#   'city' => 'NYC',
#   'street' => 'Street 1',
#   'zipcode' => '123'
#   }
#   ]
#   )
#   # => [
#   #<User
#   name="Jane"
#   address=#<Address city="NYC" street="Street 1" zipcode="123">>
#   ]
#
# source://transproc//lib/transproc/transformer/dsl.rb#6
class Transproc::Transformer
  extend ::Transproc::Transformer::ClassInterface
  extend ::Transproc::Transformer::Deprecated::ClassInterface

  # Execute the transformation pipeline with the given input.
  #
  # @api public
  # @example
  #
  #   class SymbolizeKeys < Transproc::Transformer
  #   symbolize_keys
  #   end
  #
  #   SymbolizeKeys.new.call('name' => 'Jane')
  #   # => {:name=>"Jane"}
  # @param input [mixed] The input to pass to the pipeline
  # @return [mixed] output The output returned from the pipeline
  #
  # source://transproc//lib/transproc/transformer.rb#71
  def call(input); end

  # @api public
  #
  # source://transproc//lib/transproc/transformer.rb#53
  def transproc; end
end

# @api public
#
# source://transproc//lib/transproc/transformer/class_interface.rb#8
module Transproc::Transformer::ClassInterface
  # Return a base Transproc::Transformer class with the
  # container configured to the passed argument.
  #
  # @api public
  # @example
  #
  #   class MyTransformer < Transproc::Transformer[Transproc]
  #   end
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [subclass of Transproc::Transformer]
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#26
  def [](container); end

  # Get or set the container to resolve transprocs from.
  #
  # @api private
  # @example
  #
  #   # Setter
  #   Transproc::Transformer.container(Transproc)
  #   # => Transproc
  #
  #   # Getter
  #   Transproc::Transformer.container
  #   # => Transproc
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [Transproc::Registry]
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#59
  def container(container = T.unsafe(nil)); end

  # @api public
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#73
  def define!(&block); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#10
  def dsl; end

  # @api public
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#68
  def import(*args); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#33
  def inherited(subclass); end

  # @api public
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#80
  def new(*_arg0, **_arg1); end

  # Get a transformation from the container,
  # without adding it to the transformation pipeline
  #
  # @api public
  # @example
  #
  #   class Stringify < Transproc::Transformer
  #   map_values t(:to_string)
  #   end
  #
  #   Stringify.new.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  #
  # source://transproc//lib/transproc/transformer/class_interface.rb#108
  def t(fn, *args); end
end

# @api public
#
# source://transproc//lib/transproc/transformer/dsl.rb#8
class Transproc::Transformer::DSL
  # @api private
  # @return [DSL] a new instance of DSL
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#16
  def initialize(container, ast: T.unsafe(nil), &block); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#13
  def ast; end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#28
  def call(transformer); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#10
  def container; end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#23
  def dup; end

  private

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#45
  def method_missing(meth, *args, &block); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#35
  def node(&block); end

  # @api private
  # @return [Boolean]
  #
  # source://transproc//lib/transproc/transformer/dsl.rb#40
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end
end

# source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#5
module Transproc::Transformer::Deprecated; end

# @api public
#
# source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#7
module Transproc::Transformer::Deprecated::ClassInterface
  # Define an anonymous transproc derived from given Transformer
  # Evaluates block with transformations and returns initialized transproc.
  # Does not mutate original Transformer
  #
  # @api public
  # @example
  #   class MyTransformer < Transproc::Transformer[MyContainer]
  #   end
  #
  #   transproc = MyTransformer.define do
  #   map_values t(:to_string)
  #   end
  #   transproc.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @return [Function] Composed transproc
  # @yield Block allowing to define transformations. The same as class level DSL
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#45
  def build(&block); end

  # Define an anonymous transproc derived from given Transformer
  # Evaluates block with transformations and returns initialized transproc.
  # Does not mutate original Transformer
  #
  # @api public
  # @example
  #
  #   class MyTransformer < Transproc::Transformer[MyContainer]
  #   end
  #
  #   transproc = MyTransformer.define do
  #   map_values t(:to_string)
  #   end
  #   transproc.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @return [Function] Composed transproc
  # @yield Block allowing to define transformations. The same as class level DSL
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#45
  def define(&block); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#17
  def inherited(subclass); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#53
  def method_missing(method, *args, &block); end

  # @api public
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#9
  def new(*_arg0, **_arg1); end

  # @api private
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#66
  def transproc; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#61
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end

  # An array containing the transformation pipeline
  #
  # @api private
  #
  # source://transproc//lib/transproc/transformer/deprecated/class_interface.rb#75
  def transformations; end
end

# source://transproc//lib/transproc/constants.rb#4
Transproc::Undefined = T.let(T.unsafe(nil), Object)

# source://transproc//lib/transproc/version.rb#4
Transproc::VERSION = T.let(T.unsafe(nil), String)
